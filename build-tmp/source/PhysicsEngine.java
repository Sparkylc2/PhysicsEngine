/* autogenerated by Processing revision 1293 on 2024-03-01 */
import processing.core.*;
import processing.data.*;
import processing.event.*;
import processing.opengl.*;

import java.util.*;
import java.util.Stack;
import java.math.*;
import java.awt.event.KeyEvent;
import java.awt.event.KeyListener;
import java.lang.Enum;
import processing.data.JSONArray;
import processing.data.JSONObject;
import processing.core.*;
import processing.javafx.*;
import java.awt.*;
import javax.swing.JFrame;
import processing.awt.*;
import garciadelcastillo.dashedlines.*;
import processing.svg.*;

import java.util.HashMap;
import java.util.ArrayList;
import java.io.File;
import java.io.BufferedReader;
import java.io.PrintWriter;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.IOException;

public class PhysicsEngine extends PApplet {


public void setup() {

    if(System.getProperty("os.name").toLowerCase().contains("mac")) {
        windowMove(0, 22);
    }
    textFont(createFont(sketchPath() + "/data/fonts/InterDisplay-SemiBold.ttf", 128, true), 10);
    dash = new DashedLines(this);
    dash.pattern(1, 0.5f);
/*--------------------- Timing Utilities ---------------------*/
    FrameTimeUtility.init();
    frameRate(300);
/*--------------------- Camera Utilities ---------------------*/
    Camera = new Camera();
/*---------------------------- UI ----------------------------*/
    UI_Manager.init();
/*-------------------------- Rigidbodies ------------------------*/
    rigidbodyList = new ArrayList<Rigidbody>();
/*------------------------------------------------------------*/


    Rigidbody floor = RigidbodyGenerator.CreateBoxBody(1000f, 5f, 1f, 0.5f, true, true, 0.05f, new PVector(0,0,0), new PVector(255,255,255));
    Rigidbody springBody = RigidbodyGenerator.CreateBoxBody(4f, 1f, 1f, 0.5f, false, true, 0.05f, new PVector(0, 0, 0), new PVector(255, 255, 255));
    //Rigidbody test = RigidbodyGenerator.CreateCircleBody(1f, 1f, 0.5f, false, true, 0.05f, new PVector(0, 0, 0), new PVector(255, 255, 255));
    //Rigidbody spinningBody = RigidbodyGenerator.CreateCircleBody(1f, 1f, 0.5f, false, true, 0.05f, new PVector(0, 0, 0), new PVector(255, 255, 255));



    floor.SetInitialPosition(new PVector(0, 10));
    //test.SetInitialPosition(new PVector(-10, -5));
    springBody.setVelocity(new PVector(0,20));
    springBody.SetInitialPosition(new PVector(-10, -5));
    //spinningBody.SetInitialPosition(new PVector(0, -5));

    //spinningBody.setIsTranslationallyStatic(true);


    //Rod rod = new Rod(springBody, test, new PVector(), new PVector());
    Spring springLeft = new Spring(springBody, new PVector(2,0), new PVector(-8, -10));
    Spring springRight = new Spring(springBody, new PVector(-2,0), new PVector(-12, -10));

    //rod.setIsJoint(true);


    //springBody.addForceToForceRegistry(rod);
    //test.addForceToForceRegistry(rod); 

    springBody.addForceToForceRegistry(springLeft);
    springBody.addForceToForceRegistry(springRight);

    //test.addForceToForceRegistry(new Gravity(test));
    springBody.addForceToForceRegistry(new Gravity(springBody));
    //spinningBody.addForceToForceRegistry(new Gravity(spinningBody));
    //springBody.setIsTranslationallyStatic(true);

    AddBodyToBodyEntityList(springBody);
    //AddBodyToBodyEntityList(test);
    AddBodyToBodyEntityList(floor);
    //AddBodyToBodyEntityList(spinningBody);

}



public void draw() {
    FrameTimeUtility.calculateFrameTime();
        Camera.onFrameStart();
            /*--------------------- Main Methods ---------------------*/
            UI_Manager.interactionDraw();
            
            Step(FrameTimeUtility.DT, SUB_STEP_COUNT);
        
            /*--------------------------------------------------------*/
    
        Camera.onFrameEnd();
        UI_Manager.draw();
    
    FrameTimeUtility.displayTimings();
    FrameTimeUtility.updateFrameTime();
}


public class AABB {

  private final PVector Min;
  private final PVector Max;

/*
====================================================================================================
========================================== Constructors ============================================
====================================================================================================
*/

  public AABB(PVector min, PVector max) {
      this.Min = min;
      this.Max = max;
  }
  
  
/*-------------------------------------Overloaded Constructor-------------------------------------*/
  public AABB(float minX, float minY, float maxX, float maxY) {
      this.Min = new PVector(minX, maxY);
      this.Max = new PVector(maxX, maxY);
  }
  
  public AABB(PVector vec1, PVector vec2, boolean autoFix) {
      this.Min = new PVector(min(vec1.x, vec2.x), min(vec1.y, vec2.y));
      this.Max = new PVector(max(vec1.x, vec2.x), max(vec1.y, vec2.y));
  
  }
  
  public void drawAABB() {
    rectMode(CORNERS);
    dash.rect(Min.x, Min.y, Max.x, Max.y);
  }
  

  
  public void shiftAABB(PVector amount) {
    this.Min.add(amount);
    this.Max.add(amount);
  }


  public float calculateArea() {
    return abs((Max.x - Min.x) * (Max.y - Min.y));
  }

  public void recalculateMaxAndMin(ArrayList<Rigidbody> rigidbodies) {
    float minX = Float.MAX_VALUE;
    float minY = Float.MAX_VALUE;
    float maxX = -Float.MAX_VALUE;
    float maxY = -Float.MAX_VALUE;


    float prcnt = 0.125f;

    for (Rigidbody rb : rigidbodies) {
      PVector rbMin = rb.GetAABB().getMin();
      PVector rbMax = rb.GetAABB().getMax();

      if (rbMin.x < minX) {
        minX = rbMin.x;
      }
      if (rbMin.y < minY) {
        minY = rbMin.y;
      }
      if (rbMax.x > maxX) {
        maxX = rbMax.x;
      }
      if (rbMax.y > maxY) {
        maxY = rbMax.y;
      }
    }

    float prcntPad = max(abs(maxX - minX) * prcnt, abs(maxY - minY) * prcnt);
    
    Min.x = minX - prcntPad;
    Min.y = minY - prcntPad;
    Max.x = maxX + prcntPad;
    Max.y = maxY + prcntPad;
  }


  public PVector calculateCenter() {
    return new PVector((Max.x + Min.x) / 2, (Max.y + Min.y) / 2);
  }



/*
====================================================================================================
==============================================GETTERS & SETTERS=====================================
====================================================================================================
*/
    public PVector getMin() {
      return Min;
    }
  
    public PVector getMax() {
      return Max;
    }
  
}


public class Camera {

    public PVector position;
    public PVector targetPosition;
    public float zoom;
    public float targetZoom;
    float easing = 0.05f;
  

    public Camera() {
        position = new PVector(-50, -50);
        targetPosition = new PVector(-50, -50);
        zoom = 10f;
        targetZoom = 10f;

    }

    public void updateCamera() {
        position.x = lerp(position.x, targetPosition.x, easing);
        position.y = lerp(position.y, targetPosition.y, easing);

        // Smoothly change the zoom level towards the target zoom level
        zoom = lerp(zoom, targetZoom, easing);
    }
    
    public void zoom(float amount, float mouseX, float mouseY) {
        PVector mouseBeforeZoom = screenToWorld(mouseX, mouseY);
        targetZoom *= amount;
        PVector mouseAfterZoom = screenToWorld(mouseX, mouseY);
        PVector shift = PVector.sub(mouseBeforeZoom, mouseAfterZoom);
        targetPosition.add(shift);
    }


    public void applyTransform() {
        pushMatrix();
        translate(width/2, height/2);
        scale(zoom);
        translate(-position.x, -position.y);
    }

    public void resetTransform() {
        popMatrix();
    }
  
    public PVector screenToWorld(float x, float y) {
        float worldX = (x - width/2) / zoom + position.x;
        float worldY = (y - height/2) / zoom + position.y;

        return new PVector(worldX, worldY);
    }

    public PVector screenToWorld(){
        return new PVector((mouseX - width / 2) / zoom + position.x, (mouseY - height / 2) / zoom + position.y);
    }

    public void move(float dx, float dy) {
        targetPosition.x += dx / zoom;
        targetPosition.y += dy / zoom;
    }

    public float[] getCameraExtents(float padding) {
        float left = screenToWorld(padding, padding).x;
        float right = screenToWorld(width - padding, padding).x;
        float top = screenToWorld(padding, padding).y;
        float bottom = screenToWorld(width - padding, height - padding).y;  

        return new float[] {left, right, top, bottom};
    }

    public PVector[] getWorldBoundsWithPadding(float padding) {
        PVector topLeft = screenToWorld(padding, padding);
        PVector topRight = screenToWorld(width - padding, padding);
        PVector bottomLeft = screenToWorld(padding, height - padding);
        PVector bottomRight = screenToWorld(width - padding, height - padding);

        return new PVector[] {topLeft, topRight, bottomLeft, bottomRight};
    }
    
    public void onFrameStart() {
        UI_Manager.onSceneDrawStart();
        Mouse.updateMouse();
        this.updateCamera();
        this.applyTransform();
        Render.draw();
        UI_Manager.onSceneDrawEnd();
        Mouse.drawCursor(); 
    }

    public void onFrameEnd() {
        popMatrix();
    }
}
public class Cloth {

    private PVector initialLeftCornerPosition;
    private PVector initialRightCornerPosition;

    private float clothWidth;
    private float clothHeight;

    private float stiffness = 300f;
    private float damping = 1f;

    private int numRowParticles;
    private int numColumnParticles;
    private int spacing = 2;
    private float particleRadius = 0.5f;

    private Rigidbody[][] clothBodyParticles;

    public Cloth(PVector initialLeftCornerPosition, PVector initialRightCornerPosition, float length) {

        this.initialLeftCornerPosition = initialLeftCornerPosition;
        this.initialRightCornerPosition = initialRightCornerPosition;
        this.clothWidth = (int)round(PVector.sub(initialLeftCornerPosition, initialRightCornerPosition).mag() / 5.0f) * 5;
        this.clothHeight = (int)round(length / spacing) * spacing;

        this.numRowParticles = (int)clothWidth/spacing;
        this.numColumnParticles = (int)clothHeight/spacing;
        clothBodyParticles = new Rigidbody[numRowParticles][numColumnParticles];
    }


    public void CreateCloth() {
        float initialParticlePositionX = this.initialLeftCornerPosition.x;
        float initialParticlePositionY = this.initialLeftCornerPosition.y;

        for(int row = 0; row < numRowParticles; row++) {
            for(int column = 0; column < numColumnParticles; column++) {

                PVector currentParticlePosition = new PVector(initialParticlePositionX + row*spacing, initialParticlePositionY + column*spacing);

                Rigidbody currentParticle = RigidbodyGenerator.CreateCircleBody(particleRadius, 0.5f, 0.02f, false, true, 0.1f, new PVector(0,0,0), new PVector(255,255,255));
                currentParticle.setPosition(currentParticlePosition);
                currentParticle.previousPosition = currentParticlePosition.copy();

                clothBodyParticles[row][column] = currentParticle;

                currentParticle.addForceToForceRegistry(new Gravity(currentParticle));
                currentParticle.setIsVisible(false);
                AddBodyToBodyEntityList(currentParticle);
            }
        }

        clothBodyParticles[0][0].setIsVisible(true);
        clothBodyParticles[numRowParticles - 1][0].setIsVisible(true);

        clothBodyParticles[0][0].setIsStatic(true);
        clothBodyParticles[numRowParticles - 1][0].setIsStatic(true);


        for(int row = 0; row < numRowParticles; row++) {
            for(int column = 0; column < numColumnParticles; column++) {
            
                Rigidbody currentParticle = clothBodyParticles[row][column];

                // Link to particle below if it exists
                if(row < numRowParticles - 1) {
                    Rigidbody particleToLinkTo = clothBodyParticles[row+1][column];
                    addSpringBetweenParticles(currentParticle, particleToLinkTo);
                }

                // Link to particle to the right if it exists
                if(column < numColumnParticles - 1) {
                    Rigidbody particleToLinkTo = clothBodyParticles[row][column+1];
                    addSpringBetweenParticles(currentParticle, particleToLinkTo);
                }

                if (row == 0 || row == numRowParticles - 1 || column == 0 || column == numColumnParticles - 1) {
                    // If the particle is on the edge, set its collidability to true
                    currentParticle.setCollidability(true);
                } else {
                    // If the particle is not on the edge, set its collidability to false
                    currentParticle.setCollidability(false);
                }
                
            }
        }
    }

    private void addSpringBetweenParticles(Rigidbody particleA, Rigidbody particleB) {
        Spring spring = new Spring(particleA, particleB, new PVector(), new PVector());
        spring.setSpringLength(PVector.dist(particleA.getPosition(), particleB.getPosition()));
        spring.setSpringConstant(this.stiffness);
        spring.setDamping(this.damping);
        spring.drawSpring = false;

        particleA.addForceToForceRegistry(spring);
        particleB.addForceToForceRegistry(spring);
    }

    public void updateCloth() {
      draw();
    }




    public void draw() {
beginShape(LINES);
for (int row = 0; row < numRowParticles; row++) {
    for (int column = 0; column < numColumnParticles - 1; column++) {
        PVector pos = clothBodyParticles[row][column].getPosition();
        PVector rightPos = clothBodyParticles[row][column + 1].getPosition();
        vertex(pos.x, pos.y);
        vertex(rightPos.x, rightPos.y);
    }
}
endShape();

// Draw vertical lines
beginShape(LINES);
for (int column = 0; column < numColumnParticles; column++) {
    for (int row = 0; row < numRowParticles - 1; row++) {
        PVector pos = clothBodyParticles[row][column].getPosition();
        PVector bottomPos = clothBodyParticles[row + 1][column].getPosition();
        vertex(pos.x, pos.y);
        vertex(bottomPos.x, bottomPos.y);
    }
}
endShape();


    }


}

public class CollisionManifold {

    private final Rigidbody RigidbodyA;
    private final Rigidbody RigidbodyB;
    private final PVector Normal;
    private final float Depth;

    private final PVector[] PointsOfContact;
    private final int ContactCount;

    public CollisionManifold(Rigidbody rigidbodyA, Rigidbody rigidbodyB,
                             CollisionResult collisionResult) {

        this.RigidbodyA = rigidbodyA;
        this.RigidbodyB = rigidbodyB;
        this.Normal = collisionResult.getNormal();
        this.Depth = collisionResult.getDepth();
        this.PointsOfContact = collisionResult.getPointsOfContact();
        this.ContactCount = collisionResult.getContactCount();
    }
    

    public Rigidbody getRigidbodyA() {
        return RigidbodyA;
    }

    public Rigidbody getRigidbodyB() {
        return RigidbodyB;
    }

    public PVector getNormal() {
        return Normal;
    }

    public float getDepth() {
        return Depth;
    }

    public PVector[] getPointsOfContact() {
        return PointsOfContact;
    }

    public int getContactCount() {
        return ContactCount;
    }


}
public class CollisionResult {
 
  private boolean isColliding;
  private PVector normal = new PVector();
  private float depth;

  private float distanceSquared;

  private PVector[] pointsOfContact;

  private int contactCount;

  


/*
====================================================================================================
================================ PointSegmentDistance Constructor ==================================
====================================================================================================
*/

//Default constructor for no collision
  public CollisionResult(){

    this.isColliding = false;
    this.normal.set(0,0,0);
    this.depth = 0f;
    this.pointsOfContact = null;
    this.contactCount = 0;
  }


  public CollisionResult(float distanceSquared, PVector pointOfContact) {


    this.distanceSquared = distanceSquared;

    this.pointsOfContact = new PVector[] {pointOfContact};
  }



  public CollisionResult(PVector[] pointsOfContact) {
    this.isColliding = true;

    this.pointsOfContact = pointsOfContact;
    this.contactCount = pointsOfContact.length;
  }

  public CollisionResult(boolean isColliding, PVector normal, float depth, PVector[] pointsOfContact) {
    this.isColliding = isColliding;
    this.normal = normal;
    this.depth = depth;

    this.pointsOfContact = pointsOfContact;
    this.contactCount = pointsOfContact.length;
  }

  
  public CollisionResult(boolean isColliding, PVector normal, float depth) {
    this.isColliding = isColliding;
    this.normal = normal;
    this.depth = depth;
    this.pointsOfContact = null;
    this.contactCount = 0;
  }
 
  /*
  =====================================================================================================
  =========================================== Getters/Setters =========================================
  =====================================================================================================
  */

  public boolean getIsColliding() {
    return isColliding;
  }
  
  public PVector getNormal() {
    return normal;
  }

  public float getDepth() {
    return depth;
  }

  public PVector[] getPointsOfContact() {
    return pointsOfContact;
  }

  public int getContactCount() {
    return contactCount;
  }
  
  public float getDistanceSquared() {
    return distanceSquared;
  }


  public void setIsColliding(boolean isColliding) {
    this.isColliding = isColliding;
  }

  public void setNormal(PVector normal) {
    this.normal = normal;
  }

  public void setDepth(float depth) {
    this.depth = depth;
  }
  public void setDistanceSquared(float distanceSquared) {
    this.distanceSquared = distanceSquared;
  }

  //Overloaded Methods
  public void setPointsOfContact(PVector[] pointsOfContact) {
    this.pointsOfContact = pointsOfContact;
  }
  
  public void setPointsOfContact(PVector pointOfContact) {
    this.pointsOfContact = new PVector[] {pointOfContact};
  }

  public void setPointsOfContact(PVector pointOfContactA, PVector pointOfContactB) {
    this.pointsOfContact = new PVector[] {pointOfContactA, pointOfContactB};
  }

  public void setContactCount(int contactCount) {
    this.contactCount = contactCount;
  }

}
public static class Collisions {
  CollisionResult collisionResult;

  //This is required as there is no enclosing instance of physics class for collisionResult
  public static PhysicsEngine physicsEngine = new PhysicsEngine();




  /*------------------- Reusable  ------------------- */
  public static PVector ZeroNormal = new PVector();
/*
====================================================================================================
===================================== COLLIDE INFO =================================================
====================================================================================================
*/

/*optimizied*/
public static CollisionResult Collide(Rigidbody rigidbodyA, Rigidbody rigidbodyB) {

    ShapeType shapeTypeA = rigidbodyA.getShapeType();
    ShapeType shapeTypeB = rigidbodyB.getShapeType();

    if(shapeTypeA == ShapeType.BOX) {

      if(shapeTypeB == ShapeType.BOX) {

        return IntersectPolygon(rigidbodyA.getPosition(),
                                           rigidbodyA.GetTransformedVertices(),
                                           rigidbodyB.getPosition(),
                                           rigidbodyB.GetTransformedVertices());

      } else if(shapeTypeB == ShapeType.CIRCLE) {
        CollisionResult result = Collisions.IntersectCirclePolygon(rigidbodyB.getPosition(),
                                                                   rigidbodyB.getRadius(),
                                                                   rigidbodyA.getPosition(),
                                                                   rigidbodyA.GetTransformedVertices()
                                                                   );
        result.setNormal(result.getNormal().mult(-1));
        return result;

      }

    }
  if (shapeTypeA == ShapeType.CIRCLE) {
        
        if(shapeTypeB == ShapeType.BOX) {

          return IntersectCirclePolygon(rigidbodyA.getPosition(), 
                                                   rigidbodyA.getRadius(), 
                                                   rigidbodyB.getPosition(), 
                                                   rigidbodyB.GetTransformedVertices());

        } else if(shapeTypeB == ShapeType.CIRCLE) {

          return IntersectCircle(rigidbodyA.getPosition(), rigidbodyB.getPosition(), rigidbodyA.getRadius(), rigidbodyB.getRadius());

        }
      }

    return physicsEngine.new CollisionResult();
  }


/*
====================================================================================================
===================================== CONTACT-POINTS COLLISIONS ====================================
======================================= COLLISION-RESULT ===========================================
*/

/*optimized*/

public static void FindCollisionPoints(Rigidbody rigidbodyA, Rigidbody rigidbodyB,
                                                  CollisionResult collisionResult) {
    int contactCount = 0;

    ShapeType shapeTypeA = rigidbodyA.getShapeType();
    ShapeType shapeTypeB = rigidbodyB.getShapeType();

    if(shapeTypeA == ShapeType.BOX) {

      if(shapeTypeB == ShapeType.BOX) {
        PVector[] pointsOfContact = FindPolygonsCollisionPoints(rigidbodyA.GetTransformedVertices(),
                                                                rigidbodyB.GetTransformedVertices());
        collisionResult.setPointsOfContact(pointsOfContact);
        collisionResult.setContactCount(pointsOfContact.length);
        return;

      } else if(shapeTypeB == ShapeType.CIRCLE) {
        PVector[] pointsOfContact = FindCirclePolygonCollisionPoint(rigidbodyB.getPosition(),
                                                                    rigidbodyB.getRadius(),
                                                                    rigidbodyA.getPosition(),
                                                                    rigidbodyA.GetTransformedVertices());
        collisionResult.setPointsOfContact(pointsOfContact);
        collisionResult.setContactCount(1);
        return;
      }

    }
  if (shapeTypeA == ShapeType.CIRCLE) {
        
        if(shapeTypeB == ShapeType.BOX) {
          PVector[] pointsOfContact = FindCirclePolygonCollisionPoint(rigidbodyA.getPosition(),
                                                                      rigidbodyA.getRadius(),
                                                                      rigidbodyB.getPosition(),
                                                                      rigidbodyB.GetTransformedVertices());
          collisionResult.setPointsOfContact(pointsOfContact);
          collisionResult.setContactCount(1);
          return;

        } else if(shapeTypeB == ShapeType.CIRCLE) {
           PVector[] pointsOfContact = FindCirclesCollisionPoint(rigidbodyA.getPosition(),
                                                                 rigidbodyA.getRadius(),
                                                                 rigidbodyB.getPosition(),
                                                                 rigidbodyB.getRadius());
            collisionResult.setPointsOfContact(pointsOfContact);
            collisionResult.setContactCount(1);
            return;
        }
      }

    /*
    For displaying the points of contact
        for(PVector point : pointsOfContact) {
             //pointsOfContactList.add(point);
        }
   */

}
/*
====================================================================================================
============================== CIRCLE-CIRCLE COLLISION CONTACT POINT ===============================
======================================= COLLISION-RESULT ===========================================
====================================================================================================
*/
 private static PVector[] FindCirclesCollisionPoint(PVector centerA, float radiusA,
                                                         PVector centerB, float radiusB) {
    

    return new PVector[] {PVector.add(centerA, PVector.sub(centerB, centerA).normalize().mult(radiusA))};
    }
/*
====================================================================================================
=============================POLYGON-POLYGON COLLISION CONTACT POINT ===============================
======================================= COLLISION-RESULT ===========================================
====================================================================================================
*/


private static PVector[] FindPolygonsCollisionPoints(PVector[] transformedVerticesA,
                                                           PVector[] transformedVerticesB) {
  PVector contactPointA = new PVector();
  PVector contactPointB = new PVector();

  PVector vertexA = new PVector();
  PVector vertexB = new PVector();
  
  PVector point = new PVector();
  int contactCount = 0;

  float minDistanceSquared = Float.MAX_VALUE;

  for(int i = 0; i < transformedVerticesA.length; i++) {

      point.set(transformedVerticesA[i]);

      for(int j = 0; j < transformedVerticesB.length; j++) {
        
        CollisionResult pointSegmentDistanceResult = PointSegmentDistance(point, transformedVerticesB[j], transformedVerticesB[(j + 1) % transformedVerticesB.length]);

        if(PhysEngMath.Equals(pointSegmentDistanceResult.getDistanceSquared(),minDistanceSquared)) {

            if(!PhysEngMath.Equals(pointSegmentDistanceResult.getPointsOfContact()[0], contactPointA)) {

              contactPointB.set(pointSegmentDistanceResult.getPointsOfContact()[0]);
              contactCount = 2;

            }
            
        } else if(pointSegmentDistanceResult.getDistanceSquared() < minDistanceSquared) {

            minDistanceSquared = pointSegmentDistanceResult.getDistanceSquared();
            contactPointA.set(pointSegmentDistanceResult.getPointsOfContact()[0]);
            contactCount = 1;
        }
      }
    }


  for(int i = 0; i < transformedVerticesB.length; i++) {

      point.set(transformedVerticesB[i]);

      for(int j = 0; j < transformedVerticesA.length; j++) {
          
          vertexA.set(transformedVerticesA[j]);
          vertexB.set(transformedVerticesA[(j + 1) % transformedVerticesA.length]);
  
          CollisionResult pointSegmentDistanceResult = PointSegmentDistance(point, transformedVerticesA[j], transformedVerticesA[(j + 1) % transformedVerticesA.length]);

        if(PhysEngMath.Equals(pointSegmentDistanceResult.getDistanceSquared(),minDistanceSquared)) {

            if(!PhysEngMath.Equals(pointSegmentDistanceResult.getPointsOfContact()[0], contactPointA)) {
              contactPointB.set(pointSegmentDistanceResult.getPointsOfContact()[0]);
              contactCount = 2;
            }

        } else if(pointSegmentDistanceResult.getDistanceSquared() < minDistanceSquared) {
            minDistanceSquared = pointSegmentDistanceResult.getDistanceSquared();
            contactPointA.set(pointSegmentDistanceResult.getPointsOfContact()[0]);
            contactCount = 1;
        }
      }
    }

    if(contactCount == 1){
      return new PVector[] {contactPointA};
    }
    
    return new PVector[] {contactPointA, contactPointB};
  
}

/*
====================================================================================================
=============================CIRCLE-POLYGON COLLISION CONTACT POINT ===============================
======================================= COLLISION-RESULT ===========================================
====================================================================================================
*/

/*Somewhat optimized */

private static PVector[] FindCirclePolygonCollisionPoint(PVector circleCenter,
                                                         float circleRadius,
                                                         PVector polygonCenter,
                                                         PVector[] transformedVertices) {

    float minDistanceSquared = Float.MAX_VALUE;
    PVector contactPoint = new PVector();

    for(int i = 0; i < transformedVertices.length; i++) {

        CollisionResult pointSegmentDistanceResult = PointSegmentDistance(circleCenter, transformedVertices[i], transformedVertices[(i + 1) % transformedVertices.length]); 

        if(pointSegmentDistanceResult.getDistanceSquared() < minDistanceSquared) {

            minDistanceSquared = pointSegmentDistanceResult.getDistanceSquared();
            contactPoint.set(pointSegmentDistanceResult.getPointsOfContact()[0]);
        }
    }

    return new PVector[] {contactPoint};
  }


/*
====================================================================================================
===================================== AABB-AABB Collisions =========================================
====================================================================================================
*/
public static boolean IntersectAABB (AABB aabbA, AABB aabbB) {

  if(aabbA.getMax().x <= aabbB.getMin().x || aabbB.getMax().x <= aabbA.getMin().x
    || aabbA.getMax().y <= aabbB.getMin().y || aabbB.getMax().y <= aabbA.getMin().y) {

    return false;
  }

  return true;
}

/*
====================================================================================================
===================================== AABB-AABB Point Collision ====================================
====================================================================================================
*/
public static boolean IntersectAABBWithPoint(AABB aabb, PVector point) {
    if (point.x >= aabb.getMin().x && point.x <= aabb.getMax().x &&
        point.y >= aabb.getMin().y && point.y <= aabb.getMax().y) {
        return true; // The point is within the AABB
    }
    return false; // The point is outside the AABB
  }

/*
====================================================================================================
===================================== CIRCLE-CIRCLE COLLISIONS =====================================
======================================= COLLISION-RESULT ===========================================
====================================================================================================
*/
/*somewhat Optimized*/
  public static CollisionResult IntersectCircle(PVector centerA, PVector centerB,
                                                float radiusA, float radiusB) {

    PVector direction = PVector.sub(centerB, centerA);
    float distance = direction.mag();
    float radiusSum = (radiusA + radiusB);
    
    if(distance < radiusSum) {
      return physicsEngine.new CollisionResult(true, direction.normalize(), radiusSum - distance);
    } else {
      return physicsEngine.new CollisionResult();
    }
  }
  
                                             

/*
====================================================================================================
===================================== POLYGON-POLYGON COLLISIONS ===================================
======================================= COLLISION-RESULT============================================
====================================================================================================
*/

/*Optimized somewhat*/
public static CollisionResult IntersectPolygon(PVector centerA,
                                               PVector[] transformedVerticesA,
                                               PVector centerB,
                                               PVector[] transformedVerticesB) {

    float depth = Float.MAX_VALUE;

    PVector axis = new PVector();
    PVector normal = new PVector();
    PVector edge = new PVector();

    PVector transformedVertexA = new PVector();
    PVector transformedVertexB = new PVector();

    PVector secondTransformedVertexA = new PVector();
    PVector secondTransformedVertexB = new PVector();


    for(int vertexIndexA = 0; vertexIndexA < transformedVerticesA.length; vertexIndexA++) {
 

      //Gets the transformed vertices in polygon A, when at the end of the list, loops back to the start
      transformedVertexA.set(transformedVerticesA[vertexIndexA]);
      transformedVertexB.set(transformedVerticesA[(vertexIndexA + 1) % transformedVerticesA.length]);

      //Finds the edge between the two vertices,
      edge.set(PVector.sub(transformedVertexB, transformedVertexA));

      //Finds the normal or "axis" from the edge vector
      axis.set(-edge.y, edge.x);
      axis.normalize();

      //Projects the vertices of polygon A onto the axis. Format is [min, max]
      float[] minMaxA = ProjectVertices(transformedVerticesA, axis);
      float[] minMaxB = ProjectVertices(transformedVerticesB, axis);

      if(minMaxA[0] >= minMaxB[1] || minMaxB[0] >= minMaxA[1]) {
        return physicsEngine.new CollisionResult();
      }

      float axisDepth = min(minMaxB[1]-minMaxA[0], minMaxA[1]-minMaxB[0]);

      if(axisDepth < depth) {
        depth = axisDepth;
        normal.set(axis);
      }
    }

    for(int vertexIndexB = 0; vertexIndexB < transformedVerticesB.length; vertexIndexB++) {
      //!!!ALL OF THIS ASSUMES A CLOCKWISE WINDING ORDER!!!

      //Gets the transformed vertices in polygon A, when at the end of the list, loops back to the start
      secondTransformedVertexA.set(transformedVerticesB[vertexIndexB]);
      secondTransformedVertexB.set(transformedVerticesB[(vertexIndexB + 1) % transformedVerticesB.length]);

      //Finds the edge between the two vertices, 
      edge.set(PVector.sub(secondTransformedVertexB, secondTransformedVertexA));

      //Finds the normal or "axis" from the edge vector
      axis.set(-edge.y, edge.x);
      axis.normalize();

      //Projects the vertices of polygon A onto the axis. Format is [min, max]
      float[] minMaxA = ProjectVertices(transformedVerticesA, axis);
      float[] minMaxB = ProjectVertices(transformedVerticesB, axis);

      if(minMaxA[0] >= minMaxB[1] || minMaxB[0] >= minMaxA[1]) {        
        return physicsEngine.new CollisionResult();
      }

      float axisDepth = min(minMaxB[1]-minMaxA[0], minMaxA[1]-minMaxB[0]);
      
      if(axisDepth < depth) {
        depth = axisDepth;
        normal.set(axis);
      }
    }

    //This is correction code so that the normal points in the correct direction
    //If its not pointing in the correct direction, flip the normal
  
    if(PVector.dot(PVector.sub(centerB, centerA), normal) < 0) {
      normal.mult(-1);
    }

    return physicsEngine.new CollisionResult(true, normal, depth);
  }

//The overloaded method is used when the center of the polygon is not known


/*
====================================================================================================
===================================== CIRCLE-POLYGON COLLISIONS ====================================
======================================= COLLISION-RESULT ===========================================
====================================================================================================
*/


public static CollisionResult IntersectCirclePolygon(PVector circleCenter, float circleRadius,
                                                     PVector polygonCenter,
                                                     PVector[] transformedVertices){
    boolean isColliding;
    float depth = Float.MAX_VALUE;
    PVector normal = new PVector();

    PVector edge = new PVector();
    PVector axis = new PVector();

    float axisDepth = 0f;

    for(int vertexIndex = 0; vertexIndex < transformedVertices.length; vertexIndex++) {
      //!!!ALL OF THIS ASSUMES A CLOCKWISE WINDING ORDER!!!

      //Finds the edge between the two vertices,
      edge.set(PVector.sub(transformedVertices[(vertexIndex + 1) % transformedVertices.length], transformedVertices[vertexIndex]));
      
      //Finds the normal or "axis" from the edge vector
       axis.set(-edge.y, edge.x);
       axis.normalize();

      //Projects the vertices of polygon A onto the axis. Format is [min, max]
      float[] minMaxA = ProjectVertices(transformedVertices, axis);

      //Projects the circle onto the axis. Format is [min, max]
      float[] minMaxB = ProjectCircle(circleCenter, axis, circleRadius);

      if(minMaxA[0] >= minMaxB[1] || minMaxB[0] >= minMaxA[1]) {

        return physicsEngine.new CollisionResult();
      }

       axisDepth = min(minMaxB[1]-minMaxA[0], minMaxA[1]-minMaxB[0]);
        if(axisDepth < depth) {
            depth = axisDepth;
            normal.set(axis);
        }
  }

    int index = FindClosestPointOnPolygon(circleCenter, transformedVertices);
    
    if(index == -1) {
      return physicsEngine.new CollisionResult();
    }
    axis.set(PVector.sub(transformedVertices[index], circleCenter).normalize());

     //Projects the vertices of polygon A onto the axis. Format is [min, max]
      float[] minMaxA = ProjectVertices(transformedVertices, axis);
      //Projects the circle onto the axis. Format is [min, max]
      float[] minMaxB = ProjectCircle(circleCenter, axis, circleRadius);


      if(minMaxA[0] >= minMaxB[1] || minMaxB[0] >= minMaxA[1]) {
        
        return physicsEngine.new CollisionResult();
      }

      axisDepth = min(minMaxB[1]-minMaxA[0], minMaxA[1]-minMaxB[0]);

      if(axisDepth < depth) {
        depth = axisDepth;
        normal.set(axis);
      }

        if(PVector.dot(PVector.sub(polygonCenter, circleCenter), normal) < 0) {
          normal.mult(-1);
        }
  
        isColliding = true;

        return physicsEngine.new CollisionResult(isColliding, normal, depth);
}




/*
====================================================================================================
========================================= HELPER-METHODS ===========================================
====================================================================================================
*/

//Returns an array with array = [min, max]
private static float[] ProjectVertices(PVector[] vertices, PVector axis){

  float min = Float.MAX_VALUE;
  float max = Float.MIN_VALUE;

  for(PVector vertex : vertices) {

    float projectedVertex = PVector.dot(vertex, axis);

    if(projectedVertex < min) {
      min = projectedVertex;
    }

    if(projectedVertex > max) {
      max = projectedVertex;
    }

  }
  return new float[] {min, max};
}

private static float[] ProjectCircle(PVector center, PVector axis, float radius) {
  
  PVector directionAndRadius = PVector.mult(axis, radius);

  float min = PVector.dot(PVector.add(center, directionAndRadius), axis);
  float max = PVector.dot(PVector.sub(center, directionAndRadius), axis);
   
  if(min > max){
    float temp = min;
    min = max;
    max = temp;
  }

  return new float[] {min, max};
}

private static int FindClosestPointOnPolygon(PVector circleCenter, PVector[] transformedVertices) {
    int result = -1;
    float minDistanceSq = Float.MAX_VALUE;

    // Check for null or empty input
    if (transformedVertices == null || transformedVertices.length == 0 || circleCenter == null) {
        System.out.println("Input is null or empty");
        return result; // Return -1 to indicate error
    }

    for (int vertexIndex = 0; vertexIndex < transformedVertices.length; vertexIndex++) {
        // Additional check for null vertices, if necessary
        if (transformedVertices[vertexIndex] == null) {
            continue; // Skip this iteration
        }

        float distanceSq = PVector.sub(circleCenter, transformedVertices[vertexIndex]).magSq();

        if (distanceSq < minDistanceSq) {
            minDistanceSq = distanceSq;
            result = vertexIndex;
        }
    }

    return result;
}



public static CollisionResult PointSegmentDistance(PVector point, PVector lineSegmentStart, PVector lineSegmentEnd) {
    //PVector.sub(point, lineSegmentStart) is equivalent to pointToLineSegment

    PVector lineSegment = new PVector();
    lineSegment.set(PVector.sub(lineSegmentEnd, lineSegmentStart));

    float projection = PVector.dot(PVector.sub(point, lineSegmentStart), lineSegment);
    float lineSegmentLengthSquared = lineSegment.magSq();

    float distance = projection / lineSegmentLengthSquared;

    PVector closestPoint = new PVector();

    if (distance <= 0f) {
        closestPoint.set(lineSegmentStart);
    } else if (distance >= 1f) {
        closestPoint.set(lineSegmentEnd);
    } else {
        closestPoint.set(PVector.add(lineSegmentStart, PVector.mult(lineSegment, distance)));
    }

    float distanceSquared = PVector.sub(point, closestPoint).magSq();

    return physicsEngine.new CollisionResult(distanceSquared, closestPoint);
}
} 
/*
public class Editor {


	private Rigidbody rigidbody;

    private PVector dragStart = null;
    private PVector dragEnd = null;

    private ArrayList<Rigidbody> selectedRigidbodies = new ArrayList<Rigidbody>();
 	private boolean inEditMode = false;
	private int count = 0;

	public Editor () {
	}


	public void onEditorSelect (Rigidbody rigidbody) {
		if(rigidbody.getShapeType() == ShapeType.CIRCLE) {
			return;
		}
		this.rigidbody = rigidbody;
		this.inEditMode = true;
	}

    public void onDrag() {
        if(dragStart == null) {
            dragStart = Mouse.getMouseCoordinates();
        } else {
            dragEnd = Mouse.getMouseCoordinates();
        }
    }

    public void onRelease() {
        if(dragStart != null && dragEnd != null) {
            selectRigidbodiesInDragArea();
        }
        dragStart = null;
        dragEnd = null;
    }

    public void dragSnap() {
        if(selectedRigidbodies.size() > 0){
            updateRigidbodiesInDragArea();
        }
    }

    public void onClick() {
        this.selectedRigidbodies.clear();
    }

private void selectRigidbodiesInDragArea() {
    selectedRigidbodies.clear();

    float minX = min(Mouse.getMouseDownCoordinates().x, Mouse.getMouseCoordinates().x);
    float maxX = max(Mouse.getMouseDownCoordinates().x, Mouse.getMouseCoordinates().x);
    float minY = min(Mouse.getMouseDownCoordinates().y, Mouse.getMouseCoordinates().y);
    float maxY = max(Mouse.getMouseDownCoordinates().y, Mouse.getMouseCoordinates().y);
    
    for (Rigidbody rb : rigidbodyList) { 
        PVector pos = rb.getPosition();
        if (pos.x >= minX && pos.x <= maxX && pos.y >= minY && pos.y <= maxY) {
            selectedRigidbodies.add(rb);
        }
    }
}

    private void updateRigidbodiesInDragArea() {
        PVector dragVector = PVector.sub(Mouse.getMouseCoordinates(), Mouse.getPreviousMouseCoordinates());

        if(selectedRigidbodies.size() > 0){
            for(Rigidbody rigidbody : selectedRigidbodies) {
                rigidbody.setPosition(PVector.add(rigidbody.getPosition(), dragVector));
            }
        }

    }

	//ID -1 corresponds to drawing the vertices in the main draw loop
	//ID 0 corresponds to a click
	//ID 1 corresponds to a drag
	//ID 2 corresponds to a delete press

	public void whileEditorSelect(int id) {
		if(inEditMode) {
			if(id == -1) {
				//int index = this.selectVertex(VERTEX_SNAP_RADIUS);
				//this.drawVertices(index);
				this.drawVertices();
				return;
			} else if(id == 0){
				this.addVertexClick();
			} else if(id == 1) {
				int index = this.selectVertex(VERTEX_SNAP_RADIUS);
				if(index != -1) {
					this.moveVertex(index);
				}
			} else if(id == 2) {
				int index = this.selectVertex(VERTEX_SNAP_RADIUS);
				if(index != -1) {
					this.deleteVertex(index);
				}
            }
		}
	}


	public int selectVertex(float radius) {
		PVector[] rigidbodyVertices = rigidbody.GetTransformedVertices();

		for(int i = 0; i < rigidbodyVertices.length; i++) {
			if(PVector.sub(PVector.add(rigidbody.getPosition(), PhysEngMath.SnapController(interactivityListener, rigidbody, interactivityListener.screenToWorld())), rigidbodyVertices[i]).magSq() < radius) {
				//System.out.println(i);
				return i;
			}
		}
		return -1;
	}

	public void addVertexClick() {
		PVector vertex = PhysEngMath.ReverseTransform(interactivityListener.screenToWorld(), this.rigidbody.getPosition().copy().mult(-1), -this.rigidbody.getAngle());
		PVector[] rigidbodyVertices = this.rigidbody.getVertices();
		PVector[] newRigidbodyVertices = new PVector[rigidbodyVertices.length + 1];

		for(int i = 0; i < rigidbodyVertices.length; i++) {
			newRigidbodyVertices[i] = rigidbodyVertices[i];
		}

		newRigidbodyVertices[newRigidbodyVertices.length - 1] = vertex;

		this.rigidbody.updatePolygon(newRigidbodyVertices);
	} 

	public void deleteVertex(int index) {
		ArrayList<PVector> vertexList = new ArrayList<PVector>(Arrays.asList(this.rigidbody.getVertices()));
		vertexList.remove(index);
		this.rigidbody.updatePolygon(vertexList.toArray(new PVector[vertexList.size()]));
	}


	public void drawVertices() {
		PVector[] currentVertices = this.rigidbody.GetTransformedVertices();
		for(PVector vertex : currentVertices) {
			pushMatrix();
			translate(vertex.x, vertex.y);

			fill(0, 255, 0);
			noStroke();
			ellipse(0, 0, 0.25, 0.25);
			popMatrix();

		}
	}


	public void moveVertex(int index) {
		PVector vertex = interactivityListener.screenToWorld();
		PVector[] rigidbodyCoreVertices = this.rigidbody.getVertices();

		PVector[] vertexList = Arrays.copyOf(rigidbodyCoreVertices, rigidbodyCoreVertices.length);

		vertexList[index] = PhysEngMath.ReverseTransform(vertex, this.rigidbody.getPosition().copy().mult(-1), -this.rigidbody.getAngle());

		this.rigidbody.updatePolygon(vertexList);
	}

	public void onEditorDeselect() {
		this.rigidbody = null;
		this.inEditMode = false;
	}

	public void onSelection() {

	}

	public boolean getInEditMode() {
		return this.inEditMode;
	}

	public Rigidbody getSelectedRigidbody() {
		return this.rigidbody;
	}
}
*/
public interface ForceRegistry {
    public PVector getForce(Rigidbody rigidbody, PVector position);
    public void draw();
    public PVector getApplicationPoint(Rigidbody rigidbody, PVector position);
    public Rigidbody getRigidbodyA();
    public Rigidbody getRigidbodyB();
}

public enum ForceType {
  SPRING,
  ROD,
  MOTOR
}
public class FrameTimeUtility {

    private int currentFrameTime;
    private int lastFrameTime;


    private long totalWorldStepTimeStart;
    private long subWorldStepTimeStart;

    private long totalWorldStepTime;
    private long subWorldStepTime;

    private int totalBodyCount;
    private double systemTime;

    private int totalSampleCount;
    private int subSampleCount;

    private String totalStepTime;
    private String subStepTime;
    private int bodyCount;

    private String totalStepTimeUnit;
    private String subStepTimeUnit;

    public float DT = 0.0f;
    private float fps;
    private float displayTimeStep;



    public void displayTimings() {
        if(millis() - systemTime >= 200) {
            this.totalStepTime = calculateAverageTime(this.totalWorldStepTime, this.totalSampleCount);
            this.subStepTime = calculateAverageTime(this.subWorldStepTime, this.subSampleCount);
            this.bodyCount = rigidbodyList.size();

            //updates the counter and resets values
            this.totalWorldStepTime = 0;
            this.subWorldStepTime = 0;
            this.totalSampleCount = 0;
            this.subSampleCount = 0;
            this.systemTime = millis();

            this.fps = frameRate;
            this.displayTimeStep = this.DT;
        }
    
        stroke(255);
        fill(255);
        text("Total Step Time: " + totalStepTime, 10, 40);
        text("Sub Step Time: " + subStepTime, 10, 60);
        text("Body Count: " + bodyCount, 10, 80);
        text("FPS: " + fps, 10, 100);
        text("dt: " + displayTimeStep, 10, 120);
    }


    public void startTotalWorldStepTime() {
        this.totalWorldStepTimeStart = System.nanoTime();
    }
    public void updateTotalWorldStepTime() {
        this.totalSampleCount++;
        this.totalWorldStepTime += System.nanoTime() - totalWorldStepTimeStart;
    }
    
    public void startSubWorldStepTime() {
        this.subWorldStepTimeStart = System.nanoTime();
    }

    public void updateSubWorldStepTime() {
        this.subSampleCount++;
        this.subWorldStepTime += System.nanoTime() - subWorldStepTimeStart;
    }

    private String calculateAverageTime(long totalTime, int sampleCount) {
        double averageTime = ((double)totalTime) / sampleCount;
        String timeUnit = "ns";

        if(averageTime > 1000) {
            averageTime /= 1000;
            timeUnit = "Î¼s";
        }
        if (averageTime > 1000) {
            averageTime /= 1000;
            timeUnit = "ms";
        }

        averageTime = new BigDecimal(averageTime).setScale(3, RoundingMode.HALF_UP).doubleValue();
        return averageTime + timeUnit;
    }

    public void init() {
        this.lastFrameTime = millis();
    }

    public void calculateFrameTime() {
        this.currentFrameTime = millis();
        this.DT = (float)(this.currentFrameTime - this.lastFrameTime) / 1000.0F;
    }

    public void updateFrameTime() {
        this.lastFrameTime = this.currentFrameTime;
    }
}
public class Gravity implements ForceRegistry {
  private final Rigidbody rigidbody;

  public Gravity(Rigidbody rigidbody) {
    this.rigidbody = rigidbody;
  }

  @Override
  public PVector getForce(Rigidbody rigidbody, PVector position) {
    return PVector.mult(GRAVITY_VECTOR, rigidbody.getMass());
  }

  @Override
  public void draw() {
    // Do nothing
  }

    @Override
    public PVector getApplicationPoint(Rigidbody rigidbody, PVector position) {
      return rigidbody.getPosition();
    }
    @Override
    public Rigidbody getRigidbodyA() {
      return this.rigidbody;
    }
    @Override
    public Rigidbody getRigidbodyB(){
      return this.rigidbody;
    }
}
public class KeyHandler {

    private boolean[] keyDownCache = new boolean[256];




/*-------------------------------------- Rigidbody Tab -------------------------------------------*/

/*
====================================================================================================
====================================== Key & Mouse Listeners =======================================
====================================================================================================
*/
    public void onKeyPressed(int keyCode) {
        if(keyCode < keyDownCache.length) {
            keyDownCache[keyCode] = true;
        }
    }

    public void onKeyReleased(int keyCode) {
        if(keyCode < keyDownCache.length) {
            keyDownCache[keyCode] = false;
        }
    }

    public boolean isKeyDown(int keyCode) {
        if(keyCode < keyDownCache.length) {
            return keyDownCache[keyCode];
        }
        return false;
    }

    public boolean isKeyUp(int keyCode) {
        if(keyCode < keyDownCache.length) {
            return !keyDownCache[keyCode];
        }
        return false;
    }

/*
====================================================================================================
====================================== Getters and Setters =========================================
====================================================================================================
*/    
}
@Override public 
void exit() {
 java.lang.System.exit(0);
}

public void keyPressed() {
    KeyHandler.onKeyPressed(keyCode);

    UI_Manager.getPropertiesEditorWindow().onKeyPress(keyCode);


    UI_Manager.onKeyPress(keyCode);
    if(KeyHandler.isKeyDown(KeyEvent.VK_Q)) {
        UI_Manager.getTabBar().onQPressed();
        return;
    }
    
    if(KeyHandler.isKeyDown(KeyEvent.VK_E)) {
        UI_Manager.getTabBar().onEPressed();
        return;
    }

    if(KeyHandler.isKeyDown(KeyEvent.VK_1)) {
        UI_Manager.getHotBar().setActiveSlotID(0);
        UI_Manager.getTabBar().setActiveTabID(1);
        return;
    }

    if(KeyHandler.isKeyDown(KeyEvent.VK_2)) {
        UI_Manager.getHotBar().setActiveSlotID(1);
        UI_Manager.getTabBar().setActiveTabID(1);
        return;
    }

    if(KeyHandler.isKeyDown(KeyEvent.VK_3)) {
        UI_Manager.getHotBar().setActiveSlotID(2);
        UI_Manager.getTabBar().setActiveTabID(1);
        return;
    }

    if(KeyHandler.isKeyDown(KeyEvent.VK_4)) {
        UI_Manager.getHotBar().setActiveSlotID(3);
        UI_Manager.getTabBar().setActiveTabID(1);
        return;
    }

    if(KeyHandler.isKeyDown(KeyEvent.VK_5)) {
        UI_Manager.getHotBar().setActiveSlotID(4);
        UI_Manager.getTabBar().setActiveTabID(1);
        return;
    }


    if(KeyHandler.isKeyDown(KeyEvent.VK_6)) {
        UI_Manager.getHotBar().setActiveSlotID(5);
        UI_Manager.getTabBar().setActiveTabID(1);
        return;
    }

    if(KeyHandler.isKeyDown(KeyEvent.VK_7)) {
        UI_Manager.getHotBar().setActiveSlotID(6);
        UI_Manager.getTabBar().setActiveTabID(1);
        return;
    }

    if(keyCode == ESC) {
        exit();
        return;
    }
    
    if(keyCode == ENTER) {
        Mouse.getMouseObjectResults().clear();
        return;
    }

    if(keyCode == TAB) {
        Mouse.setSnappingEnabled(!Mouse.getSnappingEnabled());
        return;
    }

    if(key == ' ') {
        if(!IS_PAUSED_LOCK) {
            IS_PAUSED = !IS_PAUSED;
        }
        return;
    }
    if(key == 'r') {
        rigidbodyList.clear();
        ALL_FORCES_ARRAYLIST.clear();
        softbodyList.clear();
        return;
    }
    if(keyCode == BACKSPACE || keyCode == DELETE) {
        ArrayList<Rigidbody> rigidbodiesToDelete = UI_Manager.getPropertiesEditorWindow().getSelectedRigidbodies();
        if(rigidbodiesToDelete.size() != 0) {
            for(Rigidbody rigidbody : rigidbodiesToDelete) {
                rigidbody.delete();
            }

            if(UI_Manager.getPropertiesEditorWindow().selectedRigidbodiesOnClick()) {
                return;
            }
        } else {
            Rigidbody rigidbodyToDelete = Mouse.getCurrentRigidbodyUnderMouse();
            if(rigidbodyToDelete != null) {
                rigidbodyToDelete.delete();
                return;
            }
        }
        return;
    }


    if(KeyHandler.isKeyDown(KeyEvent.VK_L)) {
        UI_Manager.getCreationWindow().triggerLevelSnapshot();
    }
}

public void keyReleased() {  
    KeyHandler.onKeyReleased(keyCode);

    if(!KeyHandler.isKeyDown(KeyEvent.VK_Q)) {
        UI_Manager.getTabBar().onQReleased();
    }

    if(!KeyHandler.isKeyDown(KeyEvent.VK_E)) {
        UI_Manager.getTabBar().onEReleased();
    }
}


public class Level {

	public Level() {
		//Do Nothing
	}


	public void loadLevelState() {
		IS_PAUSED = true;
		JSONArray rigidbodyArray = loadJSONArray("TRAIN.json");
		ALL_FORCES_ARRAYLIST.clear();
		rigidbodyList.clear();

		for(int i = 0; i < rigidbodyArray.size()-1; i++) {
			JSONObject rigidbodyJSON = rigidbodyArray.getJSONObject(i);
			Rigidbody rigidbody = this.deserializeRigidbody(rigidbodyJSON);
			rigidbody.addForceToForceRegistry(new Gravity(rigidbody));
			rigidbodyList.add(rigidbody);

		}

		JSONArray forcesArray = rigidbodyArray.getJSONArray(rigidbodyArray.size() - 1);

		for(int i = 0; i < forcesArray.size(); i++) {
			Spring spring = null;
			Rod rod = null;
			Motor motor = null;
			Gravity gravity = null;

			JSONObject forceJSON = forcesArray.getJSONObject(i);

            System.out.println(forceJSON.getString("ForceType"));
			if(forceJSON.getString("ForceType").equals("Spring")){
				spring = this.deserializeSpring(forceJSON);
			} else if (forceJSON.getString("ForceType").equals("Rod")) {
				rod = this.deserializeRod(forceJSON);
			} else if (forceJSON.getString("ForceType").equals("Motor")) {
				motor = this.deserializeMotor(forceJSON);
			} else if(forceJSON.getString("ForceType").equals("Gravity")) {
				gravity = this.deserializeGravity(forceJSON);
			}

			if(spring != null) {
				if(spring.getIsTwoBodySpring()) {
					spring.getRigidbodyA().addForceToForceRegistry(spring);
					spring.getRigidbodyB().addForceToForceRegistry(spring);
					ALL_FORCES_ARRAYLIST.add(spring);
				} else {
					spring.getRigidbodyA().addForceToForceRegistry(spring);
					ALL_FORCES_ARRAYLIST.add(spring);
				}
			} else if(rod != null) {
				if(rod.getTwoBodyRod()) {
					rod.getRigidbodyA().addForceToForceRegistry(rod);
					rod.getRigidbodyB().addForceToForceRegistry(rod);

					if(rod.getIsJoint()) {
						rod.getRigidbodyA().addBodyToCollisionExclusionList(rod.getRigidbodyB());
						rod.getRigidbodyB().addBodyToCollisionExclusionList(rod.getRigidbodyA());
					}
					ALL_FORCES_ARRAYLIST.add(rod);
				} else {
					rod.getRigidbodyA().addForceToForceRegistry(rod);
					ALL_FORCES_ARRAYLIST.add(rod);
				}
			} else if(motor != null) {
				motor.getRigidbodyA().addForceToForceRegistry(motor);
				ALL_FORCES_ARRAYLIST.add(spring);

			} else if(gravity != null) {
				gravity.getRigidbodyA().addForceToForceRegistry(gravity);
				ALL_FORCES_ARRAYLIST.add(gravity);
			}
		}
		IS_PAUSED = false;
	}

	public void saveLevelState() {
		JSONArray rigidbodyArray = new JSONArray();

		for(Rigidbody body : rigidbodyList) {

			String ID = body.getID();

			/*---------------- Main Rigidbody JSON Object --------------*/
			JSONObject rigidbodyJSON = new JSONObject();
			/*----------------------------------------------------------*/

			JSONObject IDJSON = new JSONObject();
					IDJSON.setString("ID", ID);
				rigidbodyJSON.setJSONObject("RigidbodyID", IDJSON);

			JSONObject positionAndVelocityJSON = new JSONObject();
					positionAndVelocityJSON.setJSONObject("position", this.serialize2DPVector(body.getPosition()));
					positionAndVelocityJSON.setJSONObject("velocity", this.serialize2DPVector(body.getVelocity()));
				rigidbodyJSON.setJSONObject("positionAndVelocity", positionAndVelocityJSON);


			JSONObject angleAndAngularVelocityJSON = new JSONObject();
					angleAndAngularVelocityJSON.setFloat("angle", body.getAngle());
					angleAndAngularVelocityJSON.setFloat("angularVelocity", body.getAngularVelocity());
				rigidbodyJSON.setJSONObject("angleAndAngularVelocity", angleAndAngularVelocityJSON);

			JSONObject shapeTypeJSON = new JSONObject();
					shapeTypeJSON.setString("shapeType", body.getShapeType().name());
				rigidbodyJSON.setJSONObject("shapeType", shapeTypeJSON);

			JSONObject densityAndRestitutionJSON = new JSONObject();
					densityAndRestitutionJSON.setFloat("density", body.getDensity());
					densityAndRestitutionJSON.setFloat("restitution", body.getRestitution());
				rigidbodyJSON.setJSONObject("densityAndRestitution", densityAndRestitutionJSON);

			JSONObject geometryJSON = new JSONObject();
					JSONArray verticesArray = serializePVectorArray(body.getVertices());
					geometryJSON.setJSONArray("vertices", verticesArray);
					geometryJSON.setFloat("radius", body.getRadius());
					geometryJSON.setFloat("width", body.getWidth());
					geometryJSON.setFloat("height", body.getHeight());
				rigidbodyJSON.setJSONObject("geometry", geometryJSON);

		JSONObject frictionJSON = new JSONObject();
				frictionJSON.setFloat("coeffOfStaticFriction", body.getCoefficientOfStaticFriction());
				frictionJSON.setFloat("coeffOfKineticFriction", body.getCoefficientOfKineticFriction());
			rigidbodyJSON.setJSONObject("friction", frictionJSON);

		JSONObject staticityJSON = new JSONObject();
				staticityJSON.setBoolean("isStatic", body.getIsStatic());
				staticityJSON.setBoolean("isTranslationallyStatic", body.getIsTranslationallyStatic());
				staticityJSON.setBoolean("isRotationallyStatic", body.getIsRotationallyStatic());
			rigidbodyJSON.setJSONObject("staticity", staticityJSON);

		JSONObject drawingPropertiesJSON = new JSONObject();
				drawingPropertiesJSON.setFloat("strokeWeight", body.getStrokeWeight());
				drawingPropertiesJSON.setJSONObject("strokeColour", serialize3DPVector(body.getStrokeColour()));
				drawingPropertiesJSON.setJSONObject("fillColour", serialize3DPVector(body.getFillColour()));
			rigidbodyJSON.setJSONObject("drawingProperties", drawingPropertiesJSON);

		JSONObject visibilityAndCollidabilityJSON = new JSONObject();
				visibilityAndCollidabilityJSON.setBoolean("visibility", body.getIsVisible());
				visibilityAndCollidabilityJSON.setBoolean("collidability", body.getCollidability());
			rigidbodyJSON.setJSONObject("visibilityAndCollidability", visibilityAndCollidabilityJSON);


			rigidbodyArray.append(rigidbodyJSON);
		}

		rigidbodyArray.append(this.serializeForces());

		saveJSONArray(rigidbodyArray, "test.json");
	}

	private JSONArray serializeForces() {
			JSONArray forcesArray = new JSONArray();

			for(int i = 0; i < ALL_FORCES_ARRAYLIST.size(); i++) {
				JSONObject forceJSON = new JSONObject();
				ForceRegistry force = ALL_FORCES_ARRAYLIST.get(i);

				if(force instanceof Spring) {
					forceJSON = serializeSpring((Spring)force);
				} else if(force instanceof Rod) {
					forceJSON = serializeRod((Rod)force);
				} else if(force instanceof Motor) {
					forceJSON = serializeMotor((Motor)force);
				} else if(force instanceof Gravity) {
					forceJSON = serializeGravity((Gravity)force);
				}
				forcesArray.append(forceJSON);
			}
			return forcesArray;
	}


	private Rigidbody deserializeRigidbody(JSONObject rigidbodyJSON) {
		Rigidbody rigidbody;
		ShapeType shapeType = this.deserializeShapeType(rigidbodyJSON.getJSONObject("shapeType"));

		if(shapeType == ShapeType.CIRCLE) {
			rigidbody = RigidbodyGenerator.CreateCircleBody(rigidbodyJSON.getJSONObject("geometry").getFloat("radius"),
															rigidbodyJSON.getJSONObject("densityAndRestitution").getFloat("density"),
															rigidbodyJSON.getJSONObject("densityAndRestitution").getFloat("restitution"),
															rigidbodyJSON.getJSONObject("staticity").getBoolean("isStatic"),
															rigidbodyJSON.getJSONObject("visibilityAndCollidability").getBoolean("collidability"),
															rigidbodyJSON.getJSONObject("drawingProperties").getFloat("strokeWeight"),
															this.deserialize3DPVector(rigidbodyJSON.getJSONObject("drawingProperties").getJSONObject("strokeColour")),
															this.deserialize3DPVector(rigidbodyJSON.getJSONObject("drawingProperties").getJSONObject("fillColour")));

		} else {
			rigidbody = RigidbodyGenerator.CreatePolygon(this.deserializePVectorArray(rigidbodyJSON.getJSONObject("geometry").getJSONArray("vertices")),
															rigidbodyJSON.getJSONObject("densityAndRestitution").getFloat("density"),
															rigidbodyJSON.getJSONObject("densityAndRestitution").getFloat("restitution"),
															rigidbodyJSON.getJSONObject("staticity").getBoolean("isStatic"),
															rigidbodyJSON.getJSONObject("staticity").getBoolean("isTranslationallyStatic"),
															rigidbodyJSON.getJSONObject("staticity").getBoolean("isRotationallyStatic"),
															rigidbodyJSON.getJSONObject("visibilityAndCollidability").getBoolean("collidability"),
															rigidbodyJSON.getJSONObject("drawingProperties").getFloat("strokeWeight"),
															this.deserialize3DPVector(rigidbodyJSON.getJSONObject("drawingProperties").getJSONObject("strokeColour")),
															this.deserialize3DPVector(rigidbodyJSON.getJSONObject("drawingProperties").getJSONObject("fillColour")));
		}

			rigidbody.setID(rigidbodyJSON.getJSONObject("RigidbodyID").getString("ID"));
			rigidbody.setIsStatic(rigidbodyJSON.getJSONObject("staticity").getBoolean("isStatic"));
			rigidbody.setIsTranslationallyStatic(rigidbodyJSON.getJSONObject("staticity").getBoolean("isTranslationallyStatic"));
			rigidbody.setIsRotationallyStatic(rigidbodyJSON.getJSONObject("staticity").getBoolean("isRotationallyStatic"));

			rigidbody.SetInitialPosition(this.deserialize2DPVector(rigidbodyJSON.getJSONObject("positionAndVelocity").getJSONObject("position")));
			rigidbody.setVelocity(this.deserialize2DPVector(rigidbodyJSON.getJSONObject("positionAndVelocity").getJSONObject("velocity")));
			rigidbody.setAngle(rigidbodyJSON.getJSONObject("angleAndAngularVelocity").getFloat("angle"));
			rigidbody.setAngularVelocity(rigidbodyJSON.getJSONObject("angleAndAngularVelocity").getFloat("angularVelocity"));


			return rigidbody;
	}

	private Spring deserializeSpring(JSONObject springJSON) {

		boolean isTwoBodySpring = springJSON.getBoolean("isTwoBodySpring");
		if(isTwoBodySpring) {
			Rigidbody rigidbodyA = this.getRigidbodyByID(springJSON.getString("rigidbodyAID"));
			Rigidbody rigidbodyB = this.getRigidbodyByID(springJSON.getString("rigidbodyBID"));


			PVector localAnchorA = this.deserialize2DPVector(springJSON.getJSONObject("localAnchorA"));
			PVector localAnchorB = this.deserialize2DPVector(springJSON.getJSONObject("localAnchorB"));

			Spring spring = new Spring(rigidbodyA, rigidbodyB, localAnchorA, localAnchorB);

			spring.setSpringConstant(springJSON.getFloat("springConstant"));
			spring.setEquilibriumLength(springJSON.getFloat("equilibriumLength"));
			spring.setDamping(springJSON.getFloat("damping"));
			spring.setDrawSpring(springJSON.getBoolean("drawSpring"));
			spring.setLockTranslationToXAxis(springJSON.getBoolean("lockTranslationToXAxis"));
			spring.setLockTranslationToYAxis(springJSON.getBoolean("lockTranslationToYAxis"));
			spring.setPerfectSpring(springJSON.getBoolean("isPerfectSpring"));
			spring.setSpringLength(springJSON.getFloat("springLength"));

			return spring;
		} else {
			Rigidbody rigidbodyA = this.getRigidbodyByID(springJSON.getString("rigidbodyAID"));
			PVector localAnchorA = this.deserialize2DPVector(springJSON.getJSONObject("localAnchorA"));
			PVector anchorPoint = this.deserialize2DPVector(springJSON.getJSONObject("anchorPoint"));

			Spring spring = new Spring(rigidbodyA, localAnchorA, anchorPoint);
			spring.setSpringConstant(springJSON.getFloat("springConstant"));
			spring.setEquilibriumLength(springJSON.getFloat("equilibriumLength"));
			spring.setDamping(springJSON.getFloat("damping"));
			spring.setDrawSpring(springJSON.getBoolean("drawSpring"));
			spring.setLockTranslationToXAxis(springJSON.getBoolean("lockTranslationToXAxis"));
			spring.setLockTranslationToYAxis(springJSON.getBoolean("lockTranslationToYAxis"));
			spring.setPerfectSpring(springJSON.getBoolean("isPerfectSpring"));
			spring.setSpringLength(springJSON.getFloat("springLength"));

			return spring;
		}
	}

	private Rod deserializeRod(JSONObject rodJSON) {
			boolean isTwoBodyRod = rodJSON.getBoolean("isTwoBodyRod");
			if(isTwoBodyRod) {
					Rigidbody rigidbodyA = this.getRigidbodyByID(rodJSON.getString("rigidbodyAID"));
					Rigidbody rigidbodyB = this.getRigidbodyByID(rodJSON.getString("rigidbodyBID"));

					PVector localAnchorA = this.deserialize2DPVector(rodJSON.getJSONObject("localAnchorA"));
					PVector localAnchorB = this.deserialize2DPVector(rodJSON.getJSONObject("localAnchorB"));

					Rod rod = new Rod(rigidbodyA, rigidbodyB, localAnchorA, localAnchorB);
					System.out.println(rodJSON.getFloat("length"));
					rod.setLength(rodJSON.getFloat("length"));
					rod.setDamping(rodJSON.getFloat("damping"));
					rod.setIsJoint(rodJSON.getBoolean("isJoint"));

					return rod;
			} else {
					Rigidbody rigidbodyA = this.getRigidbodyByID(rodJSON.getString("rigidbodyAID"));
					PVector localAnchorA = this.deserialize2DPVector(rodJSON.getJSONObject("localAnchorA"));
					PVector anchorPoint = this.deserialize2DPVector(rodJSON.getJSONObject("anchorPoint"));

					Rod rod = new Rod(rigidbodyA, localAnchorA, anchorPoint);
					rod.setLength(rodJSON.getFloat("length"));
					rod.setDamping(rodJSON.getFloat("damping"));
					rod.setIsJoint(rodJSON.getBoolean("isJoint"));
					return rod;
			}
	}

	private Motor deserializeMotor(JSONObject motorJSON) {
			Rigidbody rigidbody = this.getRigidbodyByID(motorJSON.getString("rigidbodyID"));

			Motor motor = new Motor(rigidbody, motorJSON.getFloat("targetAngularVelocity"));
			motor.setLocalAnchor(this.deserialize2DPVector(motorJSON.getJSONObject("localAnchor")));
			motor.setDrawMotor(motorJSON.getBoolean("drawMotor"));
			motor.setDrawMotorForce(motorJSON.getBoolean("drawMotorForce"));
			return motor;

		}

	private Gravity deserializeGravity(JSONObject gravityJSON) {
			Rigidbody rigidbody = this.getRigidbodyByID(gravityJSON.getString("rigidbodyID"));
			return new Gravity(rigidbody);
	}


	private JSONObject serializeSpring(Spring spring) {
			JSONObject springJSON = new JSONObject();

			springJSON.setString("rigidbodyAID", spring.getRigidbodyA().getID());

			if(spring.getIsTwoBodySpring()) {
					springJSON.setString("rigidbodyBID", spring.getRigidbodyB().getID());
			}

			springJSON.setString("ForceType", "Spring");
			springJSON.setFloat("springConstant", spring.getSpringConstant());
			springJSON.setFloat("equilibriumLength", spring.getEquilibriumLength());
			springJSON.setFloat("damping", spring.getDamping());

			springJSON.setJSONObject("localAnchorA", serialize2DPVector(spring.getLocalAnchorA()));
			springJSON.setJSONObject("localAnchorB", serialize2DPVector(spring.getLocalAnchorB()));
			springJSON.setJSONObject("anchorPoint", serialize2DPVector(spring.getAnchorPoint()));

			springJSON.setBoolean("drawSpring", spring.getDrawSpring());
			springJSON.setBoolean("lockTranslationToXAxis", spring.getLockTranslationToXAxis());
			springJSON.setBoolean("lockTranslationToYAxis", spring.getLockTranslationToYAxis());

			springJSON.setBoolean("isPerfectSpring", spring.getPerfectSpring());
			springJSON.setBoolean("isTwoBodySpring", spring.getIsTwoBodySpring());
			springJSON.setFloat("springLength", spring.getSpringLength());

			return springJSON;
	}

	private JSONObject serializeRod(Rod rod) {
			JSONObject rodJSON = new JSONObject();

			rodJSON.setString("rigidbodyAID", rod.getRigidbodyA().getID());
			if(rod.getTwoBodyRod()) {
					rodJSON.setString("rigidbodyBID", rod.getRigidbodyB().getID());
			}
			rodJSON.setString("ForceType", "Rod");
			rodJSON.setFloat("length", rod.getLength());
			rodJSON.setFloat("damping", rod.getDamping());

			rodJSON.setJSONObject("localAnchorA", serialize2DPVector(rod.getLocalAnchorA()));
			rodJSON.setJSONObject("localAnchorB", serialize2DPVector(rod.getLocalAnchorB()));
			rodJSON.setJSONObject("anchorPoint", serialize2DPVector(rod.getAnchorPoint()));

			rodJSON.setBoolean("isTwoBodyRod", rod.getTwoBodyRod());
			rodJSON.setBoolean("isJoint", rod.getIsJoint());

			return rodJSON;
	}

	private JSONObject serializeMotor(Motor motor) {
			JSONObject motorJSON = new JSONObject();

			motorJSON.setString("ForceType", "Motor");
			motorJSON.setString("rigidbodyID", motor.getRigidbodyA().getID());
			motorJSON.setJSONObject("localAnchor", serialize2DPVector(motor.getLocalAnchor()));
			motorJSON.setFloat("targetAngularVelocity", motor.getTargetAngularVelocity());
			motorJSON.setBoolean("drawMotorForce", motor.getDrawMotorForce());
			motorJSON.setBoolean("drawMotor", motor.getDrawMotor());
			
			return motorJSON;
	}

	private JSONObject serializeGravity(Gravity gravity) {
			JSONObject gravityJSON = new JSONObject();

			gravityJSON.setString("ForceType", "Gravity");
			gravityJSON.setString("rigidbodyID", gravity.getRigidbodyA().getID());
			return gravityJSON;
	}


	private ShapeType deserializeShapeType(JSONObject shapeTypeJSON) {
			return ShapeType.valueOf(shapeTypeJSON.getString("shapeType"));
	}

	private JSONObject serialize2DPVector(PVector vector) {
			JSONObject vectorJSON = new JSONObject();

			vectorJSON.setFloat("x", vector.x);
			vectorJSON.setFloat("y", vector.y);
			return vectorJSON;
	}

	private PVector deserialize2DPVector(JSONObject vectorJSON) {
			return new PVector(vectorJSON.getFloat("x"), vectorJSON.getFloat("y"));
	}

	private JSONObject serialize3DPVector(PVector vector) {
			JSONObject vectorJSON = new JSONObject();

			vectorJSON.setFloat("x", vector.x);
			vectorJSON.setFloat("y", vector.y);
			vectorJSON.setFloat("z", vector.z);
			return vectorJSON;
	}

	private PVector deserialize3DPVector(JSONObject vectorJSON) {
			return new PVector(vectorJSON.getFloat("x"), vectorJSON.getFloat("y"), vectorJSON.getFloat("z"));
	}


	private JSONArray serializePVectorArray(PVector[] vectors) {
			JSONArray vectorArray = new JSONArray();
			if(vectors == null || vectors.length == 0) {
				return vectorArray;
			}
			for(PVector vector : vectors) {
				vectorArray.append(this.serialize2DPVector(vector));
			}
			return vectorArray;
	}

	private PVector[] deserializePVectorArray(JSONArray vectorArrayJSON) {
			PVector[] vectorArray = new PVector[vectorArrayJSON.size()];

			for(int i = 0; i < vectorArrayJSON.size(); i++) {
				vectorArray[i] = this.deserialize2DPVector(vectorArrayJSON.getJSONObject(i));
			}
			return vectorArray;
	}


	private Rigidbody getRigidbodyByID(String id) {
			for(Rigidbody body : rigidbodyList) {
					if(body.getID().equals(id)) {
						return body;
					}
			}
		return null;
	}

}
















public class Motor implements ForceRegistry {

    private final Rigidbody rigidbody;
    private PVector localAnchor;

    private float targetAngularVelocity;

    private boolean drawMotorForce;
    private boolean drawMotor;


    public Motor(Rigidbody rigidbody) {
        this.rigidbody = rigidbody;
        this.localAnchor = new PVector(this.rigidbody.getRadius(), 0);
        this.drawMotorForce = true;
    }

    public Motor(Rigidbody rigidbody, float targetAngularVelocity) {
        this.rigidbody = rigidbody;
        this.targetAngularVelocity = targetAngularVelocity;
        this.localAnchor = new PVector(this.rigidbody.getRadius(), 0);
        this.drawMotorForce = true;
    }


@Override
public PVector getForce(Rigidbody rigidbody, PVector position) {

    if(this.rigidbody != rigidbody) {
        throw new IllegalArgumentException("Rigidbody is not the same as the one this force is applied to");
    }

    this.rigidbody.setAngularVelocity(targetAngularVelocity);
    
    return new PVector(0, 0);
    
    
}

@Override
public void draw() {

    if(!drawMotorForce) {
        return;
    }
    if(PhysEngMath.Equals(this.targetAngularVelocity, 0)) {
        return;
    }
    PVector position = this.rigidbody.getPosition();
    boolean isClockwise = targetAngularVelocity > 0;

    float size = this.rigidbody.getRadius() * 0.5f;
    float arrowSize = size * 0.15f;
    float startAngle = 0;
    float endAngle = 3 * PI/2;// Change this to control the curvature of the arrow

    // Draw the curved part of the arrow
    pushMatrix();
    translate(position.x, position.y);
    rotate(this.rigidbody.getAngle() + PI/6);
    noFill();
    stroke(255, 0, 0); // Red color
    arc(0, 0, size, size, startAngle, endAngle);

    // Calculate the start and end of the arc
    float startX =  size * cos(startAngle)/2;
    float startY = size * sin(startAngle)/2;
    float endX = size * cos(endAngle)/2;
    float endY = size * sin(endAngle)/2;

    fill(255, 0, 0); // Red color
    noStroke();
    
    if(isClockwise) {
        triangle(endX, endY-arrowSize, endX, endY+arrowSize, endX+arrowSize*2, endY);
    } else {
        triangle(startX-arrowSize, startY, startX + arrowSize, startY, startX, startY - 2 * arrowSize);
    }

    popMatrix();

}
@Override
public PVector getApplicationPoint(Rigidbody rigidbody, PVector position) {
    return PhysEngMath.Transform(localAnchor, position, rigidbody.getAngle());
}


/*
====================================================================================================
======================================== Getters and Setters ========================================
====================================================================================================
*/
    public void setTargetAngularVelocity(float targetAngularVelocity) {
        this.targetAngularVelocity = targetAngularVelocity;
    }

    public void setLocalAnchor(PVector localAnchor) {
        this.localAnchor = localAnchor;
    } 
    public void setDrawMotor(boolean drawMotor) {
        this.drawMotor = drawMotor;
    }

    public boolean getDrawMotor() {
        return drawMotor;
    }


    public boolean getDrawMotorForce() {
        return drawMotorForce;
    }

    public void setDrawMotorForce(boolean drawMotorForce) {
        this.drawMotorForce = drawMotorForce;
    }

    public float getTargetAngularVelocity() {
        return targetAngularVelocity;
    }

    public PVector getLocalAnchor() {
        return localAnchor;
    }
    @Override
    public Rigidbody getRigidbodyA(){
        return this.rigidbody;
    }
    @Override
    public Rigidbody getRigidbodyB(){
        return this.rigidbody;
    }



}

public void mousePressed(){
    if(mouseButton == LEFT){
        Mouse.updateMouseDownCoordinates();
        UI_Manager.onMousePress();
        return;
    }
}

public void mouseReleased() {
    if(mouseButton == LEFT) {
        Mouse.updateMouseUpCoordinates();
        UI_Manager.onMouseRelease();
        return;
    }

}

public void mouseClicked() {
    if(mouseButton == LEFT) {
        UI_Manager.onMouseClick();
        return;
    }
} 

public void mouseWheel(MouseEvent event) {
    if(UI_Manager.getIsOverWindows()) {
        return;
    }
    
    float e = -event.getCount();
    Camera.zoom(pow(1.1f, e), mouseX, mouseY);
}

public void mouseDragged() {
    if(!UI_Manager.getIsOverWindows() && mouseButton == RIGHT) {
        Camera.move(pmouseX - mouseX, pmouseY - mouseY);
        return;
    }

    if(mouseButton == LEFT) {
        UI_Manager.onMouseDrag();
        return;
    }
}

public void mouseMoved() {
    //editor.dragSnap();
}


public class MouseObject {

	private ArrayList<MouseObjectResult> interactionResults = new ArrayList<MouseObjectResult>();

	private PVector mouseCoordinates = new PVector();
    private PVector previousMouseCoordinates = new PVector();

    private float easing = 0.175f;
    private boolean mLeft, mRight, mCenter;
    private boolean isMouseDown = false;
    private boolean mouseDownLeft = false;
    private boolean mouseDownRight = false;
    private PVector mouseDownCoordinates = new PVector();
    private boolean isMouseUp = false;
    private PVector mouseUpCoordinates = new PVector();


    private boolean isMouseOverUI = false;
    private boolean wasMousePressedOverWindow = false;

	private Rigidbody currentRigidbodyUnderMouse;

  	private boolean showCursorTrail = true;
  	private ArrayList<PVector> cursorTrailArrayList = new ArrayList<PVector>();


    private boolean snappingEnabled = true;


	public MouseObject() {
        //do nothing
	}


    public void updateMouse() {
        this.updateMouseCoordinates();
        this.currentRigidbodyUnderMouse = this.getRigidbodyUnderMouse();
    }

	public Rigidbody getRigidbodyUnderMouse() {
        PVector mouseCoordinates = Camera.screenToWorld();
    	for (Rigidbody rigidbody : rigidbodyList) {
            if(!Collisions.IntersectAABBWithPoint(rigidbody.GetAABB(), mouseCoordinates)) {
           		continue;
            }
            if (rigidbody.contains(mouseCoordinates.x, mouseCoordinates.y)) {
           		return rigidbody;
            }
    	}
    	return null;
	}	


	public void addSelectedRigidbody() {
		if(this.interactionResults.size() > 2) {
            this.interactionResults.clear();
		}
		this.interactionResults.add(new MouseObjectResult(this.currentRigidbodyUnderMouse, this.mouseCoordinates));
        if(this.interactionResults.size() == 2) {
            if(this.interactionResults.get(0).getSelectedRigidbody() == null && this.interactionResults.get(1).getSelectedRigidbody() == null) {
                this.interactionResults.clear();
            }
        }

	}

	public void updateMouseCoordinates() {
        PVector snappedMouseCoordinates = PhysEngMath.WorldSnapController(this, this.currentRigidbodyUnderMouse, Camera.screenToWorld());
        this.previousMouseCoordinates.set(this.mouseCoordinates);
        this.mouseCoordinates.x = lerp(this.mouseCoordinates.x, snappedMouseCoordinates.x, this.easing);
        this.mouseCoordinates.y = lerp(this.mouseCoordinates.y, snappedMouseCoordinates.y, this.easing);
	}

    public void updateMouseDownCoordinates() {
        this.isMouseDown = true;
        this.isMouseUp = false;

        if(mouseButton == LEFT) {
            this.mouseDownLeft = true;
        }
        this.mouseDownCoordinates.set(PhysEngMath.WorldSnapController(this, this.currentRigidbodyUnderMouse, Camera.screenToWorld()));
    }

    public void updateMouseUpCoordinates() {
        this.isMouseUp = true;
        this.isMouseDown = false;
        this.addSelectedRigidbody();

        if(this.mouseDownLeft) {
            this.mouseDownLeft = false;
        }

        this.mouseUpCoordinates.set(PhysEngMath.WorldSnapController(this, this.currentRigidbodyUnderMouse, Camera.screenToWorld()));
    }
    
    public void drawCursor() {
        if(!showCursorTrail) {
            return;
        }
        fill(255, 255, 255, 121);
        stroke(0, 0, 0, 180);
        strokeWeight(0.025f);

        ellipse(Camera.screenToWorld().x, Camera.screenToWorld().y, 0.175f, 0.175f);
        fill(255, 0, 0);
        strokeWeight(0.1f);
        stroke(255, 0, 0);
        ellipse(this.mouseCoordinates.x, this.mouseCoordinates.y, 0.1f, 0.1f);


        if(cursorTrailArrayList.size() < 20) {
            cursorTrailArrayList.add(new PVector(mouseCoordinates.x, mouseCoordinates.y));
        } else {
            cursorTrailArrayList.add(cursorTrailArrayList.get(0).set(this.mouseCoordinates.x, this.mouseCoordinates.y));
            cursorTrailArrayList.remove(0);
        }
        noFill();
        beginShape();
            // Add the first point twice to guide the beginning of the curve
            curveVertex(cursorTrailArrayList.get(0).x, cursorTrailArrayList.get(0).y);
            for(PVector cursorTrailVertex : cursorTrailArrayList) {
                curveVertex(cursorTrailVertex.x, cursorTrailVertex.y);
            }
            // Add the last point twice to guide the end of the curve
            curveVertex(cursorTrailArrayList.get(cursorTrailArrayList.size() - 1).x, cursorTrailArrayList.get(cursorTrailArrayList.size() - 1).y);
        endShape();
    }

    public void setMouseCoordinates(PVector mouseCoordinates) {
        this.mouseCoordinates.set(mouseCoordinates);
    }

	public PVector getMouseCoordinates() {
		return this.mouseCoordinates;
	}

    public PVector getPreviousMouseCoordinates() {
        return this.previousMouseCoordinates;
    }
    
    public boolean getIsMouseDown() {
        return this.isMouseDown;
    }

    public PVector getMouseDownCoordinates() {
        return this.mouseDownCoordinates;
    }

    public boolean getIsMouseUp() {
        return this.isMouseUp;
    }
    public PVector getMouseUpCoordinates() {
        return this.mouseUpCoordinates;
    }

    public Rigidbody getCurrentRigidbodyUnderMouse() {
        return this.currentRigidbodyUnderMouse;
    }

    public ArrayList<MouseObjectResult> getMouseObjectResults() {
        return this.interactionResults;
    }

    public void clearMouseObjectResults() {
        this.interactionResults.clear();
    }
    
    public void setSnappingEnabled(boolean snappingEnabled) {
        this.snappingEnabled = snappingEnabled;
    }

    public boolean getSnappingEnabled() {
        return this.snappingEnabled;
    }

    public boolean getIsMouseDownLeft() {
        return this.mouseDownLeft;
    }
}
public class MouseObjectResult {
	private Rigidbody SelectedRigidbody;
	private PVector SelectedRigidbodyPosition = new PVector();
	private PVector Coordinate = new PVector();
    private PVector LocalCoordinate = new PVector();


	public MouseObjectResult(Rigidbody selectedRigidbody, PVector coordinate) {

		this.SelectedRigidbody = selectedRigidbody;
        
		if(this.SelectedRigidbody != null) {
			this.SelectedRigidbodyPosition.set(selectedRigidbody.getPosition());
            //this.LocalCoordinate.set(PVector.sub(coordinate, this.SelectedRigidbody.getPosition()));
            this.LocalCoordinate.set(PhysEngMath.Transform(PVector.sub(coordinate, this.SelectedRigidbodyPosition), -this.SelectedRigidbody.getAngle()));
		}
		this.Coordinate.set(coordinate);
	}


	public Rigidbody getSelectedRigidbody() {
		return this.SelectedRigidbody;
	}

	public PVector getWorldCoordinate() {
		return this.Coordinate.copy();
	}

    public PVector getTransformedLocalCoordinate() {
        if(this.SelectedRigidbody == null) {
            return this.Coordinate.copy();
        }
        
        return this.LocalCoordinate.copy();
    }

	public String toString() {
		return "MouseObjectResult: " + SelectedRigidbody + ", " + Coordinate;
	}


}

public static class PhysEngMath {

    private static final PVector emptyVector = new PVector(0, 0);
    
    //Precision for float comparison, equal to 0.00005 meters
    public static final float precision = 0.0001f;

    public static float Clamp(float value, float min, float max) {
        if (min == max) {
            return min;
        } else if (min > max) {
            throw new IllegalArgumentException("min must be less than max");
        } else if (value < min) {
            return min;
        } else if (value > max) {
            return max;
        } else {
            return value;
        }
  }


public static float fastInverseSq(PVector vector) {
    return fastInverseSq(vector.x * vector.x + vector.y * vector.y);
}


public static float fastInverseSq (float number) {
    float x = number;
    float xhalf = 0.5f * x;
    int i = Float.floatToIntBits(x);
    i = 0x5f3759df - (i >> 1);
    x = Float.intBitsToFloat(i);
    for (int it = 0; it < 2; it++) { // Reduced iterations for float
        x = x * (1.5f - xhalf * x * x);
    }
    x *= number;
    return x;
}

public static PVector[] OrderVerticesClockwise(PVector[] vertices) {
  // Calculate the centroid
  PVector centroid = new PVector(0, 0);
  for (PVector v : vertices) {
    centroid.add(v);
  }
  centroid.div(vertices.length);

  // Calculate angle for each vertex
  float[] angles = new float[vertices.length];
  for (int i = 0; i < vertices.length; i++) {
    angles[i] = PVector.sub(vertices[i], centroid).heading();
  }

  // Sort vertices based on angles
  for (int i = 0; i < angles.length; i++) {
    for (int j = i + 1; j < angles.length; j++) {
      if (angles[i] > angles[j]) {
        // Swap angles
        float tempAngle = angles[i];
        angles[i] = angles[j];
        angles[j] = tempAngle;
        // Swap vertices
        PVector tempVertex = vertices[i];
        vertices[i] = vertices[j];
        vertices[j] = tempVertex;
      }
    }
  }

  // Return ordered vertices
  return vertices;
}

public static PVector MouseVelocityCalculationAndClamp(PVector initial, PVector current, float min, float max) {

    float dx = current.x - initial.x;
    float dy = current.y - initial.y;

    float magnitude = fastInverseSq(dx * dx + dy * dy);  

    if (Equals(magnitude, 0f)) { // To avoid division by zero
        dx = 0f;
        dy = 0f;
    } else {
        dx /= magnitude;
        dy /= magnitude;
    }

    magnitude = constrain(magnitude, min, max);

    dx *= magnitude;
    dy *= magnitude;

    return new PVector(dx, dy);
}


public static PVector SquareVelocity(PVector vector) {
    float x = vector.x;
    float y = vector.y;

    float magSq = x * x + y * y;
    float mag = fastInverseSq(magSq);

    if(Equals(mag, 0f)) {
        x = 0f;
        y = 0f;
    } else {
        x /= mag;
        y /= mag;
    }

    return new PVector(x * magSq, y * magSq);
}

public static PVector Clamp(PVector vector, float min, float max) {

    float dx = vector.x;
    float dy = vector.y;

    float mag = fastInverseSq(dx * dx + dy * dy);

    if (Equals(mag, 0f)) { // To avoid division by zero
        dx = 0f;
        dy = 0f;
    } else {
        dx /= mag;
        dy /= mag;
    }

    mag = constrain(mag, min, max);

    dx *= mag;
    dy *= mag;

    return new PVector(dx, dy);
  }

  public static int Clamp(int value, int min, int max) {
    if (min == max) {
      return min;
    } else if (min > max) {
      throw new IllegalArgumentException("min must be less than max");
    } else if (value < min) {
      return min;
    } else if (value > max) {
      return max;
    } else {
      return value;
    }
  }
  

  public static PVector Transform(PVector vertex, float angle) {
    float sin = sin(angle);
    float cos = cos(angle);

    return new PVector(vertex.x * cos - vertex.y * sin, vertex.x * sin + vertex.y * cos);
  }
  
  public static PVector Transform(PVector vertex, PVector position, float angle){
    float sin = sin(angle);
    float cos = cos(angle);
    
    return new PVector(vertex.x * cos - vertex.y * sin + position.x, vertex.x * sin + vertex.y * cos + position.y);
  }

  public static PVector ReverseTransform(PVector vertex, PVector position, float angle){
  // Translate the vertex by the position first
  PVector translatedVertex = new PVector(vertex.x + position.x, vertex.y + position.y);

  // Then, calculate sine and cosine for the angle to rotate the translated vertex
  float sin = (float) Math.sin(angle); // Use Math.sin for Java
  float cos = (float) Math.cos(angle); // Use Math.cos for Java

  // Rotate the translated vertex
  return new PVector(
    translatedVertex.x * cos - translatedVertex.y * sin, // Rotate x
    translatedVertex.x * sin + translatedVertex.y * cos  // Rotate y
  );
}

  
  //Overloaded method for Transform
    public static PVector Transform(float x, float y, float angle) {
        float sin = sin(angle);
        float cos = cos(angle);
    
        return new PVector(x * cos - y * sin + x, x * sin + y * cos + y);
  }

  

  public static PVector zeroTransform = Transform(0, 0, 0);



    public static boolean Equals(float a, float b) {
        return Math.abs(a - b) < precision;
    }

public static boolean Equals(PVector a, PVector b) {
    return PVector.sub(a, b).magSq() < precision * precision; //magSq is faster than mag
  }

    

public static PVector SnapController(MouseObject Mouse, Rigidbody rigidbody, PVector point) {
    if(rigidbody == null) {
        return point;
    }
    
    if(Mouse.getSnappingEnabled()) {
        if(rigidbody.getShapeType() == ShapeType.BOX) {
            PVector[] vertices = rigidbody.GetTransformedVertices();

            for(int i = 0; i < vertices.length; i++) {
                if(PVector.sub(vertices[i], point).magSq() < VERTEX_SNAP_RADIUS) {
                    return PVector.sub(vertices[i], rigidbody.getPosition());
                }
            }

            PVector closestPoint = new PVector();
            float minDistanceSq = Float.MAX_VALUE;

            for (int i = 0; i < vertices.length; i++) {
                PVector start = vertices[i];
                PVector end = vertices[(i + 1) % vertices.length]; // Loop back to the first vertex

                PVector closestOnEdge = getClosestPointOnLine(start, end, point);
                float distanceSq = PVector.dist(closestOnEdge, point);

                if (distanceSq < minDistanceSq) {
                    minDistanceSq = distanceSq;
                    closestPoint = closestOnEdge;
                }
            }

            if(PVector.sub(closestPoint, rigidbody.getPosition()).magSq() / 2 > PVector.sub(point, rigidbody.getPosition()).magSq()) {
                return new PVector();
            } else {
                return PVector.sub(closestPoint, rigidbody.getPosition());
            }

        } else if(rigidbody.getShapeType() == ShapeType.CIRCLE) {
            if(PVector.sub(point, rigidbody.getPosition()).magSq() < rigidbody.getRadius()/2) {
                return new PVector();
            } else {
                return point.sub(rigidbody.getPosition()).normalize().mult(rigidbody.getRadius()).copy();
            }
        } else {
            throw new IllegalArgumentException("Rigidbody is not a circle or box");
        }
    } else {
        return PVector.sub(point, rigidbody.getPosition());
    }
}

public static PVector WorldSnapController(MouseObject Mouse, Rigidbody rigidbody, PVector point) {
    if(rigidbody == null) {
        return point;
    }

    if(Mouse.getSnappingEnabled()) {
        if(rigidbody.getShapeType() == ShapeType.BOX) {
            PVector[] vertices = rigidbody.GetTransformedVertices();

            for(int i = 0; i < vertices.length; i++) {
                if(PVector.sub(vertices[i], point).magSq() < VERTEX_SNAP_RADIUS) {
                    return vertices[i];
                }
            }

            PVector closestPoint = new PVector();
            float minDistanceSq = Float.MAX_VALUE;

            for (int i = 0; i < vertices.length; i++) {
                PVector start = vertices[i];
                PVector end = vertices[(i + 1) % vertices.length]; // Loop back to the first vertex

                PVector closestOnEdge = getClosestPointOnLine(start, end, point);
                float distanceSq = PVector.dist(closestOnEdge, point);

                if (distanceSq < minDistanceSq) {
                    minDistanceSq = distanceSq;
                    closestPoint = closestOnEdge;
                }
            }

            if(PVector.sub(closestPoint, rigidbody.getPosition()).magSq() / 2 > PVector.sub(point, rigidbody.getPosition()).magSq()) {
                return rigidbody.getPosition();
            } else {
                return closestPoint;
            }

        } else if(rigidbody.getShapeType() == ShapeType.CIRCLE) {
            if(PVector.sub(point, rigidbody.getPosition()).magSq() < rigidbody.getRadius()/2) {
                return rigidbody.getPosition();
            } else {
                return point.sub(rigidbody.getPosition()).normalize().mult(rigidbody.getRadius()).add(rigidbody.getPosition());
            }
        } else {
            throw new IllegalArgumentException("Rigidbody is not a circle or box");
        }
    } else {
        return point;
    }
}


    public static PVector[] reverseVertices(PVector[] vertices) {
        PVector[] reversedVertices = new PVector[vertices.length];

        for (int i = 0; i < vertices.length; i++) {
            reversedVertices[i] = vertices[vertices.length - 1 - i];
        }
        return reversedVertices;
    }

    private static PVector getClosestPointOnLine(PVector start, PVector end, PVector point) {
        PVector line = PVector.sub(end, start);
        float len = line.mag();
        line.normalize();
        PVector v = PVector.sub(point, start);
        float d = PVector.dot(v, line);
        d = constrain(d, 0, len);
        return PVector.add(start, line.mult(d));
    }

}
public void settings() {
    smooth(8);
    String os = System.getProperty("os.name").toLowerCase();
    if(os.contains("mac")) {
        size(displayWidth, displayHeight - 125);
    } else if(os.contains("windows")) {
        fullScreen(FX2D);
    } else {
        throw new RuntimeException("OS not supported");
    }
}

/*
====================================================================================================
===================================  PHYSICS ENGINE OBJECTS  =======================================
====================================================================================================
*/
/*------------------------------------ NEVER CHANGE THIS -----------------------------------------*/

public static boolean IS_PAUSED = false;
public static boolean IS_PAUSED_LOCK = false;

public static ArrayList<PVector> pointsOfContactList = new ArrayList<PVector>();

public static ArrayList<Rigidbody> rigidbodyList = new ArrayList<Rigidbody>();
public static ArrayList<Softbody> softbodyList = new ArrayList<Softbody>();

public ArrayList<ArrayList<Integer>> collisionPairs = new ArrayList<ArrayList<Integer>>();
    

public PVector[] contactList = new PVector[0];
public PVector[] impulseList = new PVector[2];
public PVector[] raList = new PVector[2]; 
public PVector[] rbList = new PVector[2];
public PVector[] frictionImpulseList = new PVector[2];
public float[] jList = new float[2];

/*
====================================================================================================
===================================  PHYSICS ENGINE CONSTANTS  =====================================
====================================================================================================
*/

public final float MIN_BODY_AREA = 0.001f * 0.001f; // m^2
public final float MAX_BODY_AREA = 300f * 300f; // m^2

public final float MIN_BODY_DENSITY = 0.01f; //g/cm^3
public final float MAX_BODY_DENSITY = 300.0f; //g/cm^3

public final float MIN_BODY_WIDTH = 0.01f; // m
public final float MAX_BODY_WIDTH = 300; // m

public final float MIN_BODY_HEIGHT = 0.01f; // m
public final float MAX_BODY_HEIGHT = 300.0f; // m

public final float MIN_BODY_RADIUS = 0.01f;
public final float MAX_BODY_RADIUS = 300.0f;

public final float MIN_MOUSE_VELOCITY_MAG = 0.0f;
public final float MAX_MOUSE_VELOCITY_MAG = 15.0f;

public final int MIN_ITERATIONS = 1;
public final int MAX_ITERATIONS = 1024;

public PVector BACKGROUND_COLOUR = new PVector(16, 18, 19);

public int SUB_STEP_COUNT = 128;
public boolean DRAW_CONTACT_POINTS = false;
public boolean DRAW_AABBS = false;


public final PVector GRAVITY_VECTOR = new PVector(0, 9.81f, 0);
public final float GRAVITY_MAG = 9.81f;

public ArrayList<ForceRegistry> ALL_FORCES_ARRAYLIST = new ArrayList<ForceRegistry>();


public static float VERTEX_SNAP_RADIUS = 0.25f;



/*
====================================================================================================
===================================  PHYSICS ENGINE METHODS  =======================================
====================================================================================================
*/


//Iterations for substeps for each frame
public void Step(float dt, int totalIterations) {
    
    
    /*-----------------Related to Timekeeping Debugging -----------------*/
    FrameTimeUtility.startTotalWorldStepTime();
    /*-------------------------------------------------------------------*/
    
    
    totalIterations = PhysEngMath.Clamp(totalIterations, MIN_ITERATIONS, MAX_ITERATIONS);
    
    for (int currentIteration = 0; currentIteration < totalIterations; currentIteration++) {
        
        /*-----------------Related to Timekeeping Debugging -----------------*/
        FrameTimeUtility.startSubWorldStepTime();
        /*-------------------------------------------------------------------*/
        
        
        this.collisionPairs.clear();

        StepBodies(dt, totalIterations);
        BroadPhaseStep();
        NarrowPhaseStep();
        
        /*-----------------Related to Timekeeping Debugging -----------------*/
        FrameTimeUtility.updateSubWorldStepTime();
        /*-------------------------------------------------------------------*/
    }
    /*-----------------Related to Timekeeping Debugging -----------------*/
    FrameTimeUtility.updateTotalWorldStepTime();
    /*-------------------------------------------------------------------*/
}


/*
====================================================================================================
=================================== Collision Resolution Methods ===================================
====================================================================================================
*/

public void SeperateBodies(Rigidbody rigidbodyA, Rigidbody rigidbodyB, PVector minimumTranslationVector) {
    
    if (rigidbodyA.getIsStatic() || rigidbodyA.getIsTranslationallyStatic()) {
        
        rigidbodyB.Move(minimumTranslationVector);
        
    } else if (rigidbodyB.getIsStatic() || rigidbodyB.getIsTranslationallyStatic()) {
        
        rigidbodyA.Move(PVector.mult(minimumTranslationVector, -1.0f));
        
    } else {
        
        rigidbodyA.Move(PVector.mult(minimumTranslationVector, -0.5f));
        rigidbodyB.Move(PVector.mult(minimumTranslationVector, 0.5f));
    }
}


public void ResolveCollisionLinear(CollisionManifold collisionManifold) {
    
    Rigidbody rigidbodyA = collisionManifold.getRigidbodyA();
    Rigidbody rigidbodyB = collisionManifold.getRigidbodyB();
    PVector normal = collisionManifold.getNormal();
    float depth = collisionManifold.getDepth();
    
    
    PVector velocityA = rigidbodyA.getVelocity().copy();
    PVector velocityB = rigidbodyB.getVelocity().copy();
    float restitution = min(rigidbodyA.getRestitution(), rigidbodyB.getRestitution());
    PVector relativeVelocity = PVector.sub(velocityB, velocityA);
    
    if (PVector.dot(relativeVelocity, normal) > 0.0f) {
        return;
    }
    
    float invMassA = rigidbodyA.getInvMass();
    float invMassB = rigidbodyB.getInvMass();
    
    float j = -(1f + restitution) * PVector.dot(relativeVelocity, normal) / (invMassA + invMassB);
    
    PVector impulse = PVector.mult(normal, j);
    
    
    velocityA = PVector.add(velocityA, PVector.mult(PVector.mult(impulse, -1), invMassA));
    velocityB = PVector.add(velocityB, PVector.mult(impulse, invMassB));
    
    rigidbodyA.setVelocity(velocityA);
    rigidbodyB.setVelocity(velocityB);
    
}

public void ResolveCollisionRotation(CollisionManifold contact) {
    
    Rigidbody rigidbodyA = contact.getRigidbodyA();
    Rigidbody rigidbodyB = contact.getRigidbodyB();
    float invMassA = rigidbodyA.getInvMass();
    float invMassB = rigidbodyB.getInvMass();
    float invRotationalInertiaA = rigidbodyA.getInvRotationalInertia();
    float invRotationalInertiaB = rigidbodyB.getInvRotationalInertia();
    PVector normal = contact.getNormal();
    PVector velocityA = rigidbodyA.getVelocity();
    PVector velocityB = rigidbodyB.getVelocity();
    float angularVelocityA = rigidbodyA.getAngularVelocity();
    float angularVelocityB = rigidbodyB.getAngularVelocity();

    int contactCount = contact.getContactCount();
    contactList = contact.getPointsOfContact();

    float e = min(rigidbodyA.getRestitution(), rigidbodyB.getRestitution());


    for(int i = 0; i < contactCount; i++) {
        this.impulseList[i] = new PVector();
        this.raList[i] = new PVector();
        this.rbList[i] = new PVector();
    }

    for (int i = 0; i < contactCount; i++) {
        PVector ra = PVector.sub(contactList[i], rigidbodyA.getPosition());
        PVector rb = PVector.sub(contactList[i], rigidbodyB.getPosition());

        raList[i] = ra;
        rbList[i] = rb;

        PVector raPerp = new PVector(-ra.y, ra.x);
        PVector rbPerp = new PVector(-rb.y, rb.x);

        PVector angularLinearVelocityA = PVector.mult(raPerp, angularVelocityA);
        PVector angularLinearVelocityB = PVector.mult(rbPerp, angularVelocityB);

        PVector relativeVelocity = PVector.sub(PVector.add(velocityB, angularLinearVelocityB),
                                               PVector.add(velocityA, angularLinearVelocityA));

        float contactVelocityMag = relativeVelocity.dot(normal);

        if (contactVelocityMag > 0f) {
            continue;
        }

        float raPerpDotN = raPerp.dot(normal);
        float rbPerpDotN = rbPerp.dot(normal);

        float denom = (invMassA + invMassB) +
            ((raPerpDotN * raPerpDotN) * invRotationalInertiaA) +
            ((rbPerpDotN * rbPerpDotN) * invRotationalInertiaB);

        float j = -(1f + e) * contactVelocityMag;
        j /= denom;
        j /= (float)contactCount;

        PVector impulse = PVector.mult(normal, j);
        impulseList[i] = impulse;
    }

    for(int i = 0; i < contactCount; i++) {
        PVector impulse = impulseList[i];
        PVector ra = raList[i];
        PVector rb = rbList[i];

        //float raCrossImpulse = ra.x * impulse.y - ra.y * impulse.x;
        //float rbCrossImpulse = rb.x * impulse.y - rb.y * impulse.x;

        velocityA.add(PVector.mult(impulse, -invMassA));
        velocityB.add(PVector.mult(impulse, invMassB));

        angularVelocityA += ra.cross(impulse).z * -1 * invRotationalInertiaA;
        angularVelocityB += rb.cross(impulse).z * invRotationalInertiaB;

        rigidbodyA.setVelocity(velocityA);
        rigidbodyB.setVelocity(velocityB);
        rigidbodyA.setAngularVelocity(angularVelocityA);
        rigidbodyB.setAngularVelocity(angularVelocityB);
    }
}


public void ResolveCollisionRotationAndFriction(CollisionManifold contact) {

    Rigidbody rigidbodyA = contact.getRigidbodyA();
    Rigidbody rigidbodyB = contact.getRigidbodyB();

    float invMassA = rigidbodyA.getInvMass();
    float invMassB = rigidbodyB.getInvMass();

    float invRotationalInertiaA = rigidbodyA.getInvRotationalInertia();
    float invRotationalInertiaB = rigidbodyB.getInvRotationalInertia();

    PVector positionA = rigidbodyA.getPosition();
    PVector positionB = rigidbodyB.getPosition();

    PVector velocityA = rigidbodyA.getVelocity();
    PVector velocityB = rigidbodyB.getVelocity();

    float angularVelocityA = rigidbodyA.getAngularVelocity();
    float angularVelocityB = rigidbodyB.getAngularVelocity();

    PVector normal = contact.getNormal();
    int contactCount = contact.getContactCount();
    contactList = contact.getPointsOfContact();



    float restitution = min(rigidbodyA.getRestitution(), rigidbodyB.getRestitution());

    float coefficientOfStaticFriction = (rigidbodyA.getCoefficientOfStaticFriction()
                                        + rigidbodyB.getCoefficientOfStaticFriction()) * 0.5f;
    float coefficientOfKineticFriction = (rigidbodyA.getCoefficientOfKineticFriction()
                                         + rigidbodyB.getCoefficientOfKineticFriction()) * 0.5f;
    
    for(int i = 0; i < contactCount; i++) {
        this.impulseList[i] = new PVector();
        this.raList[i] = new PVector();
        this.rbList[i] = new PVector();
        this.frictionImpulseList[i] = new PVector();
        this.jList[i] = 0f;
    }

    for(int i = 0; i < contactCount; i++) {

        PVector ra = PVector.sub(contactList[i], positionA);
        PVector rb = PVector.sub(contactList[i], positionB);

        raList[i] = ra;
        rbList[i] = rb;

        PVector raPerp = new PVector(-ra.y, ra.x);
        PVector rbPerp = new PVector(-rb.y, rb.x);

        PVector angularLinearVelocityA = PVector.mult(raPerp, angularVelocityA);
        PVector angularLinearVelocityB = PVector.mult(rbPerp, angularVelocityB);

        PVector relativeVelocity = PVector.sub(PVector.add(velocityB, angularLinearVelocityB),
                                               PVector.add(velocityA, angularLinearVelocityA));

        float contactVelocityMagnitude = relativeVelocity.dot(normal);
        
        if(contactVelocityMagnitude > 0f) {
            continue;
        }
        
        float raPerpendicularDotN = raPerp.dot(normal);
        float rbPerpendicularDotN = rbPerp.dot(normal);

        float denom = invMassA + invMassB
                    + (raPerpendicularDotN * raPerpendicularDotN) * invRotationalInertiaA
                    + (rbPerpendicularDotN * rbPerpendicularDotN) * invRotationalInertiaB;

        float j = -(1f + restitution) * contactVelocityMagnitude;
        j /= denom;
        j /= (float)contactCount;

        jList[i] = j;

        PVector impulse = PVector.mult(normal, j);
        impulseList[i] = impulse;
    }

    for(int i = 0; i < contactCount; i++) {

        PVector impulse = impulseList[i];
        PVector ra = raList[i];
        PVector rb = rbList[i];

        velocityA.add(PVector.mult(impulse, -invMassA));
        velocityB.add(PVector.mult(impulse, invMassB));

        angularVelocityA += -ra.cross(impulse).z * invRotationalInertiaA;
        angularVelocityB += rb.cross(impulse).z * invRotationalInertiaB;

    }

    for(int i = 0; i < contactCount; i++) {
        PVector ra = PVector.sub(contactList[i], positionA);
        PVector rb = PVector.sub(contactList[i], positionB);

        raList[i] = ra;
        rbList[i] = rb;

        PVector raPerp = new PVector(-ra.y, ra.x);
        PVector rbPerp = new PVector(-rb.y, rb.x);

        PVector angularLinearVelocityA = PVector.mult(raPerp, angularVelocityA);
        PVector angularLinearVelocityB = PVector.mult(rbPerp, angularVelocityB);

        PVector relativeVelocity = PVector.sub(PVector.add(velocityB, angularLinearVelocityB),
                                               PVector.add(velocityA, angularLinearVelocityA));
        PVector tangent = PVector.sub(relativeVelocity, PVector.mult(normal, relativeVelocity.dot(normal)));

        if(PhysEngMath.Equals(tangent, new PVector())) {

            continue;

        } else {

            tangent.normalize();

        }

        float raPerpDotT = raPerp.dot(tangent);
        float rbPerpDotT = rb.dot(tangent);

        float denom = invMassA + invMassB
                    + (raPerpDotT * raPerpDotT) * invRotationalInertiaA
                    + (rbPerpDotT * rbPerpDotT) * invRotationalInertiaB;

        float jt = -relativeVelocity.dot(tangent);
        jt /= denom;
        jt /= (float)contactCount;

        PVector frictionImpulse;
        float j = jList[i];

        if(abs(jt) <= j * coefficientOfStaticFriction) {
            frictionImpulse = PVector.mult(tangent, jt);
        } else {
            frictionImpulse = PVector.mult(tangent, -j * coefficientOfKineticFriction);
        }
        
        this.frictionImpulseList[i] = frictionImpulse;
    }
        for(int i = 0; i < contactCount; i++) {
            PVector frictionImpulse = frictionImpulseList[i];
            PVector ra = raList[i];
            PVector rb = rbList[i];

            velocityA.add(PVector.mult(frictionImpulse, -invMassA));
            velocityB.add(PVector.mult(frictionImpulse, invMassB));

            angularVelocityA += -ra.cross(frictionImpulse).z * invRotationalInertiaA;
            angularVelocityB += rb.cross(frictionImpulse).z * invRotationalInertiaB;

            rigidbodyA.setVelocity(velocityA);
            rigidbodyB.setVelocity(velocityB);

            rigidbodyA.setAngularVelocity(angularVelocityA);
            rigidbodyB.setAngularVelocity(angularVelocityB);
        }

    }

/*
====================================================================================================
============================ Broad & Narrow - Phase Collision Methods ==============================
====================================================================================================
*/

public void BroadPhaseStep() {
    for (int i = 0; i < rigidbodyList.size() - 1; i++) {
        
        Rigidbody rigidbodyA = rigidbodyList.get(i);
        ArrayList<Rigidbody> rigidbodyACollisionExclusionList = rigidbodyA.getCollisionExclusionList();
        AABB rigidbodyA_AABB = rigidbodyA.GetAABB();
        
        
        for (int j = i + 1; j < rigidbodyList.size(); j++) {
            Rigidbody rigidbodyB = rigidbodyList.get(j);
            AABB rigidbodyB_AABB = rigidbodyB.GetAABB();

            if(rigidbodyACollisionExclusionList.contains(rigidbodyB)) {
                continue;
            }

            if ((rigidbodyA.getIsStatic() && rigidbodyB.getIsStatic())) {
                continue;
            }
            

            //Remove this if shit breaks
            if(!rigidbodyA.getCollidability() || !rigidbodyB.getCollidability()) {
                continue;
            }
            
            if (!Collisions.IntersectAABB(rigidbodyA_AABB, rigidbodyB_AABB)) {
                continue;
            }

            ArrayList<Integer> pair = new ArrayList<Integer>(Arrays.asList(i, j));
            collisionPairs.add(pair);
        }
    }
}

public void NarrowPhaseStep() {
    for (int i = 0; i < collisionPairs.size(); i++)
    {
        ArrayList<Integer> pair = collisionPairs.get(i);

        Rigidbody rigidbodyA = rigidbodyList.get(pair.get(0));
        Rigidbody rigidbodyB = rigidbodyList.get(pair.get(1));
        
        CollisionResult collisionResult = Collisions.Collide(rigidbodyA, rigidbodyB);
            
        if (collisionResult.getIsColliding()) {
            
            PVector minimumTranslationVector = PVector.mult(collisionResult.getNormal(), collisionResult.getDepth());
            
            SeperateBodies(rigidbodyA, rigidbodyB, minimumTranslationVector);
            Collisions.FindCollisionPoints(rigidbodyA, rigidbodyB, collisionResult);
            CollisionManifold collisionManifold = new CollisionManifold(rigidbodyA, rigidbodyB, collisionResult);
            this.ResolveCollisionRotationAndFriction(collisionManifold);

            for(PVector contact : collisionResult.getPointsOfContact()) {
                pointsOfContactList.add(contact);
            }
        }
    }
}
    

public void StepBodies(float dt, int totalIterations) {
    if(IS_PAUSED) {
        return;
    }
    
    for(Rigidbody rigidbody : rigidbodyList) {

        if(rigidbody.getIsStatic() ) {
            continue;
        }

        rigidbody.update(dt, totalIterations);
    }
}
            
/*
==================================================================================================
======================================== Helper Methods  =========================================
==================================================================================================
*/
public void AddBodyToBodyEntityList(Rigidbody body) {
    rigidbodyList.add(body);
}

public void RemoveBodyFromBodyEntityList(Rigidbody body) {
     rigidbodyList.remove(body);
}
        
public void RemoveBodyFromBodyEntityList(int index) {
   
   if(index < 0 || index >= rigidbodyList.size()) {
        throw new IndexOutOfBoundsException("Index: " + index + ", Size: " + rigidbodyList.size());
    }

    rigidbodyList.remove(index);
}

public Rigidbody GetBodyFromBodyEntityList(int index) {

    if(index < 0 || index >= rigidbodyList.size()) {
        throw new IndexOutOfBoundsException("Index: " + index + ", Size: " + rigidbodyList.size());
    }

    return rigidbodyList.get(index);
}
                        
public void ClearBodyEntityList() {
    rigidbodyList.clear();
}



    
                                        
                                        
public KeyHandler KeyHandler = new KeyHandler();
public DashedLines dash;
public Camera Camera = new Camera();
public MouseObject Mouse = new MouseObject();
public FrameTimeUtility FrameTimeUtility = new FrameTimeUtility();



public Rigidbody RigidbodyGenerator = new Rigidbody();
public Shape Render = new Shape();
	
public UI_Constants UI_Constants;
public UI_Manager UI_Manager = new UI_Manager();




public class Rigidbody {

  //Capital letter denotes read only
  private String ID;
  private PVector position = new PVector();
  private PVector previousPosition = new PVector();
  private PVector linearVelocity = new PVector();
  private float angle;
  private float angularVelocity;
    
  private ShapeType ShapeType;
  private float Mass;
  private float InvMass;
  private float Density;
  private float Restitution;
  private float Area;
  private float RotationalInertia;
  private float InvRotationalInertia;
  private float Radius;
  private float Width;
  private float Height;
  private float coefficientOfStaticFriction;
  private float coefficientOfKineticFriction;
  

  private PVector[] Vertices = new PVector[0];
  private AABB aabb;
  private PVector[] transformedVertices = new PVector[0];

  private ArrayList<Rigidbody> collisionExclusionList = new ArrayList<Rigidbody>();

  private float strokeWeight;
  private PVector strokeColour = new PVector();
  private PVector fillColour = new PVector();
  
  private boolean transformUpdateRequired;
  private boolean aabbUpdateRequired;
  
  private boolean isStatic;
  private boolean isTranslationallyStatic;
  private boolean isRotationallyStatic;
  private boolean isVisible;
  private boolean isCollidable;


  
  private float netTorque = 0f;
  private PVector netForce = new PVector();
  
  private ArrayList<ForceRegistry> forceRegistry = new ArrayList<ForceRegistry>();
  
  
  
  
  
  
  /*
  ==================================================================================================
  ==================================CONSTRUCTORS====================================================
  ==================================================================================================
  */
  public Rigidbody() {
      //this.aabbUpdateRequired = true;
      //this.transformUpdateRequired = true;
  }
  
  private Rigidbody(float density, float mass, float rotationalIntertia, float restitution,
    float area, float radius, float width, float height, PVector[] vertices, boolean isStatic,
    boolean isCollidable, float strokeWeight, PVector strokeColour, PVector fillColour, ShapeType shapeType)
  {
    this.ID = UUID.randomUUID().toString();
    this.Mass = mass;
    this.RotationalInertia = rotationalIntertia;
    this.InvMass = mass > 0 ? 1 / mass : 0;
    this.InvRotationalInertia = rotationalIntertia > 0 ? 1 / rotationalIntertia : 0;


    this.Density = density;
    this.Restitution = restitution;
    this.Area = area;
    this.Radius = radius;
    this.Width = width;
    this.Height = height;

    this.coefficientOfStaticFriction = 0.8f;
    this.coefficientOfKineticFriction = 0.3f;
  

    this.ShapeType = shapeType;
    this.strokeWeight = strokeWeight;
    this.strokeColour = strokeColour;
    this.fillColour = fillColour;


    this.isStatic = isStatic;
    this.isCollidable = true;
    this.isVisible = true;

    this.position = new PVector();
    this.linearVelocity = new PVector();
    this.angle = 0f;
    this.angularVelocity = 0f;
    
    
    if (shapeType == ShapeType.BOX) {

        this.Vertices = vertices;
        this.transformedVertices = new PVector[this.Vertices.length];

    } else {
        this.Vertices = null;
        this.transformedVertices = null;
    }
    
    //Sets InvMass for static objects to 0

    
    this.aabbUpdateRequired = true;
    this.transformUpdateRequired = true;
  }





  
  
  
  /*
  ==================================================================================================
  ========================== BODY & COLLIDER GEOMETRY METHODS ======================================
  ==================================================================================================
  */
  private PVector[] CreateBoxVertices(float width, float height) {
    float left = -width / 2;
    float right = width / 2;
    float top = height / 2;
    float bottom = -height / 2;
    
    PVector[] vertices = new PVector[4];
    vertices[0] = new PVector(left, top);
    vertices[1] = new PVector(right, top);
    vertices[2] = new PVector(right, bottom);
    vertices[3] = new PVector(left, bottom);


    return PhysEngMath.OrderVerticesClockwise(vertices);
  }
  
  public PVector[] GetTransformedVertices() {
    if (this.transformUpdateRequired) {

      for (int i = 0; i < this.Vertices.length; i++) {

        PVector vertex = this.Vertices[i];

        this.transformedVertices[i] = PhysEngMath.Transform(vertex, this.position, this.angle);
      }
    }
    
    /*
    The way this transform system works, is that it caches the transformed vertices,
    and only transforms them once a change has been made. This means that,
    if no change is made is made, cached vertices are returned.
    if the transform is updated, the vertices are transformed, and the cache is updated.
    */
    this.aabbUpdateRequired = true;
    this.transformUpdateRequired = false;
    return this.transformedVertices;
  }
  
  
  public Rigidbody CreateCircleBody(float radius, float density,
    float restitution, boolean isStatic, boolean isCollidable, float strokeWeight,
    PVector strokeColour, PVector fillColour) {

    Rigidbody rigidbody;
    
    float area = (float) PI * radius * radius;
    

    if (area < MIN_BODY_AREA || area > MAX_BODY_AREA) {

      throw new IllegalArgumentException("Body area is too small or large");
    }

    if (density < MIN_BODY_DENSITY || density > MAX_BODY_DENSITY) {

      throw new IllegalArgumentException("Density is too small or large");
    } 

    restitution = PhysEngMath.Clamp(restitution, 0, 1);


    float mass = 0f;
    float rotationalIntertia = 0f;

    if(!isStatic) {
      mass = area * density;
      rotationalIntertia =  abs(0.5f * mass * radius * radius);
    }
    


    rigidbody = new Rigidbody(density, mass, rotationalIntertia, restitution, area, radius, 0, 0,
                              null, isStatic, isCollidable, strokeWeight,
                              strokeColour, fillColour, ShapeType.CIRCLE);
    
    return rigidbody;
  }
  


  public Rigidbody CreateBoxBody(float width, float height, float density,
    float restitution, boolean isStatic, boolean isCollidable, float strokeWeight,
    PVector strokeColour, PVector fillColour) {
    Rigidbody rigidbody;
    
    float area = width * height;
    
    //Argument exceptions for area and density
    if (area < MIN_BODY_AREA || area > MAX_BODY_AREA) {

      throw new IllegalArgumentException("Body area is too small or large");
    }

    if (density < MIN_BODY_DENSITY || density > MAX_BODY_DENSITY) {

      throw new IllegalArgumentException("Density is too small or large");
    } 
    
    //Clamps restitution between 0 and 1
    restitution = PhysEngMath.Clamp(restitution, 0, 1);
    
    //calculates mass from density and area
    float mass = 0f;
    float rotationalIntertia = 0f;

    if(!isStatic) {
      mass = area * density;
      rotationalIntertia = 0.5f * mass * width * width + height * height;
    }

    PVector[] vertices = CreateBoxVertices(width, height);
    
    rigidbody = new Rigidbody(density, mass, rotationalIntertia, restitution, area, 0, width,
                              height, vertices, isStatic, isCollidable, strokeWeight, strokeColour,
                              fillColour, ShapeType.BOX);
    
    return rigidbody;
  }


  public Rigidbody CreatePolygon(PVector[] vertices, float density,
    float restitution, boolean isStatic, boolean isTranslationallyStatic,
    boolean isRotationallyStatic, boolean isCollidable, float strokeWeight,
    PVector strokeColour, PVector fillColour) {

    Rigidbody rigidbody;

    float area = this.calculateArea(vertices);
    
    //Argument exceptions for area and density
    if (area < MIN_BODY_AREA || area > MAX_BODY_AREA) {

      throw new IllegalArgumentException("Body area is too small or large");
    }

    if (density < MIN_BODY_DENSITY || density > MAX_BODY_DENSITY) {

      throw new IllegalArgumentException("Density is too small or large");
    } 
    
    //Clamps restitution between 0 and 1
    restitution = PhysEngMath.Clamp(restitution, 0, 1);
    
    //calculates mass from density and area
    float mass = 0f;
    float rotationalIntertia = 0f;

    if(isStatic) {
      mass = 0f;
      rotationalIntertia = 0f;
    } else if(isTranslationallyStatic) {
      mass = 0f;
      rotationalIntertia = calculateMomentOfInertia(vertices, mass);
    } else if(isRotationallyStatic) {
      mass = area * density;
      rotationalIntertia = 0f;
    } else {
      mass = area * density;
      rotationalIntertia = calculateMomentOfInertia(vertices, mass);
    }

    
    rigidbody = new Rigidbody(density, mass, rotationalIntertia, restitution, area, 0, width,
                              height, vertices, isStatic, isCollidable, strokeWeight, strokeColour,
                              fillColour, ShapeType.BOX);
    
    return rigidbody;
  }


  public AABB GetAABB() {
    if(this.aabbUpdateRequired) {

    float minX = Float.MAX_VALUE;
    float minY = Float.MAX_VALUE;

    float maxX = -Float.MAX_VALUE;
    float maxY = -Float.MAX_VALUE;
    
    if(this.ShapeType == ShapeType.CIRCLE) {
      
      minX = this.position.x - this.Radius;
      minY = this.position.y - this.Radius;
      maxX = this.position.x + this.Radius;
      maxY = this.position.y + this.Radius;

    } else if (this.ShapeType == ShapeType.BOX) {

      PVector[] vertices = this.GetTransformedVertices();
      for (PVector vertex : vertices) {
        if (vertex.x < minX) {
            minX = vertex.x;
          }
          if (vertex.x > maxX) {
            maxX = vertex.x;
          }
          if (vertex.y < minY) {
            minY = vertex.y;
          }
          if (vertex.y > maxY) {
            maxY = vertex.y;
          }
        }
    }

    this.aabb = new AABB(new PVector(minX, minY), new PVector(maxX, maxY));
    this.aabbUpdateRequired = false;

  }
  return this.aabb;
}


public float calculateArea(PVector[] vertices) {
  float area = 0;
  int n = vertices.length;

  for (int i = 0, j = n - 1; i < n; j = i++) {
    area += vertices[i].x * vertices[j].y - vertices[j].x * vertices[i].y;
  }
  return Math.abs(area / 2.0f);
}


public float calculateMass(PVector[] vertices) {
  float area = calculateArea(vertices);
  return area * this.Density;
}


public float calculateMomentOfInertia(PVector[] vertices, float mass) {
  float I = 0;
  float area = calculateArea(vertices);
  int n = vertices.length;
  PVector centroid = calculateCentroid(vertices);

  for (int i = 0, j = n - 1; i < n; j = i++) {
    float xi = vertices[i].x - centroid.x, yi = vertices[i].y - centroid.y;
    float xj = vertices[j].x - centroid.x, yj = vertices[j].y - centroid.y;
    float cross = Math.abs(xi * yj - xj * yi);
    I += cross * (xi * xi + yi * yi + xi * xj + yi * yj + xj * xj + yj * yj);
  }
  I *= mass / (6 * area);
  return I;
}


public PVector calculateCentroid(PVector[] vertices) {
    float signedArea = 0;
    float cx = 0;
    float cy = 0;
    for (int i = 0, j = vertices.length - 1; i < vertices.length; j = i++) {
        float temp = (vertices[i].x * vertices[j].y) - (vertices[j].x * vertices[i].y);
        signedArea += temp;
        cx += (vertices[i].x + vertices[j].x) * temp;
        cy += (vertices[i].y + vertices[j].y) * temp;
    }
    signedArea /= 2;
    cx /= (6 * signedArea);
    cy /= (6 * signedArea);
    return new PVector(cx, cy);
}


public void adjustRigidbodyPosition(PVector[] vertices) {
    PVector newCOM = calculateCentroid(vertices);

    for(PVector vertex : vertices) {
        vertex.sub(newCOM);
    }
}

private boolean doEdgesIntersect(PVector p1, PVector p2, PVector p3, PVector p4) {

    float denominator = (p4.y - p3.y) * (p2.x - p1.x) - (p4.x - p3.x) * (p2.y - p1.y);
    if (denominator == 0) {
        return false; // Lines are parallel
    }

    float ua = ((p4.x - p3.x) * (p1.y - p3.y) - (p4.y - p3.y) * (p1.x - p3.x)) / denominator;
    float ub = ((p2.x - p1.x) * (p1.y - p3.y) - (p2.y - p1.y) * (p1.x - p3.x)) / denominator;

    if (ua >= 0 && ua <= 1 && ub >= 0 && ub <= 1) {
        return true; 
    }

    return false;
}

private boolean validatePolygonVertices(PVector[] vertices) {
    for (int i = 0; i < vertices.length; i++) {
        for (int j = i + 1; j < vertices.length; j++) {
            int nextI = (i + 1) % vertices.length;
            int nextJ = (j + 1) % vertices.length;

            if (nextI != j && i != nextJ) {
                if (doEdgesIntersect(vertices[i], vertices[nextI], vertices[j], vertices[nextJ])) {
                    return false; // Found intersecting edges
                }
            }
        }
    }
    return true;
}


public void updateCircle(float radius) {

    this.Radius = radius;
    this.Area = (float) PI * this.Radius * this.Radius;
    this.Vertices = null;

    this.transformedVertices = null;

    if(this.isStatic) {
      this.Mass = 0f;
      this.InvMass = 0f;
      this.RotationalInertia = 0f;
      this.InvRotationalInertia = 0f;
    } else if(this.isTranslationallyStatic) {
      this.Mass = this.Density * this.Area;
      this.InvMass = 0f;
      this.RotationalInertia = 0.5f * this.Mass * this.Radius * this.Radius;
      this.InvRotationalInertia = 1 / this.RotationalInertia;
    } else if(this.isRotationallyStatic) {
      this.Mass = this.Area * this.Density;
      this.InvMass = this.Mass;
      this.RotationalInertia = 0f;
      this.InvRotationalInertia = 0f;
    }

    this.transformUpdateRequired = true;
    this.aabbUpdateRequired = true;
}

public void updatePolygon(PVector[] newVertices) {

    newVertices = PhysEngMath.OrderVerticesClockwise(newVertices);

    this.Vertices = newVertices;
    this.transformedVertices = new PVector[this.Vertices.length];
    PVector newCOM = calculateCentroid(this.Vertices);

    for(int i = 0; i < this.Vertices.length; i++) {
          this.Vertices[i].sub(newCOM);
    }

    float newMass = calculateMass(this.Vertices);
    float newMomentOfInertia = calculateMomentOfInertia(this.Vertices, newMass);

    if(this.isStatic) {
      this.Mass = 0f;
      this.InvMass = 0f;
      this.RotationalInertia = 0f;
      this.InvRotationalInertia = 0f;
    } else if(this.isTranslationallyStatic) {
      this.Mass = newMass;
      this.InvMass = 0f;
      this.RotationalInertia = newMomentOfInertia;
      this.InvRotationalInertia = this.RotationalInertia > 0 ? 1 / this.RotationalInertia : 0;
    } else if(this.isRotationallyStatic) {
      this.Mass = newMass;
      this.InvMass = this.Mass > 0f ? 1 / this.Mass : 0f;
      this.InvRotationalInertia = 0f;
      this.RotationalInertia = newMomentOfInertia;
    } else {
      this.Mass = newMass;
      this.InvMass = this.Mass > 0 ? 1 / this.Mass : 0;
      this.RotationalInertia = newMomentOfInertia;
      this.InvRotationalInertia = this.RotationalInertia > 0 ? 1 / this.RotationalInertia : 0;
    }

    float newArea = calculateArea(this.Vertices);

    this.Area = newArea;

    this.transformUpdateRequired = true;
    this.aabbUpdateRequired = true;
}


public void deserializeRigidbody(String ID, ShapeType ShapeType, PVector position, PVector linearVelocity, float angle, 
                                 float angularVelocity, float Density, float Restitution, float radius, float width, 
                                 float height, float coefficientOfStaticFriction, float coefficientOfKineticFriction,
                                 PVector[] vertices, boolean isStatic, boolean isTranslationallyStatic, boolean isRotationallyStatic,
                                 boolean isCollidable, boolean isVisible, float strokeWeight, PVector strokeColour, PVector fillColour) {
    this.ID = ID; 

    this.position.set(position);
    this.linearVelocity.set(linearVelocity);
    this.angle = angle;
    this.angularVelocity = angularVelocity;

    this.Density = Density;
    this.Restitution = Restitution;
    this.ShapeType = ShapeType;

    this.isStatic = isStatic;
    this.isTranslationallyStatic = isTranslationallyStatic;
    this.isRotationallyStatic = isRotationallyStatic;

    this.isCollidable = isCollidable;
    this.isVisible = isVisible;

    this.strokeWeight = strokeWeight;
    this.strokeColour = strokeColour;
    this.fillColour = fillColour;

    this.coefficientOfStaticFriction = coefficientOfStaticFriction;
    this.coefficientOfKineticFriction = coefficientOfKineticFriction;

    if(ShapeType == ShapeType.POLYGON || ShapeType == ShapeType.BOX) {

        this.updatePolygon(vertices);
        this.Width = width;
        this.Height = height;

    } else if(ShapeType == ShapeType.CIRCLE) {
        this.updateCircle(radius);
    }
  }





  /*
  ==================================================================================================
  ==================================METHODS=========================================================
  ==================================================================================================
  */
  public void Move(PVector amount) {
    this.position.add(amount);

    this.transformUpdateRequired = true;
    this.aabbUpdateRequired = true;
  }
  
  public void MoveTo(PVector position) {
    this.position = position;

    this.transformUpdateRequired = true;
    this.aabbUpdateRequired = true;
  }

  public void SetInitialPosition(PVector position) {
    this.position.set(position);
    this.previousPosition.set(position);
    this.transformUpdateRequired = true;
    this.aabbUpdateRequired = true;
  }
  
  public void Rotate(float amount) {
    this.angle += amount;

    this.transformUpdateRequired = true;
    this.aabbUpdateRequired = true;
  }

  public void RotateTo(float angle) {
    this.angle = angle;

    this.transformUpdateRequired = true;
    this.aabbUpdateRequired = true;
  }


/*----------------------------- Mouse Detection Stuff ------------------------------------*/
  
public boolean contains(float x, float y) {

    if(this.ShapeType == ShapeType.CIRCLE) {
      return this.containsCircle(x, y);
    } else {
      return this.containsPolygon(x, y);
    }
}

public boolean containsCircle(float x, float y) {
    float distance = PVector.dist(this.position, new PVector(x, y));

    return (distance <= this.Radius);
}


public boolean containsPolygon(float x, float y) {
    boolean inside = false;
    PVector[] vertices = this.transformedVertices;

    for (int i = 0, j = vertices.length - 1; i < vertices.length; j = i++) {
        if ((vertices[i].y > y) != (vertices[j].y > y) &&
            (x < (vertices[j].x - vertices[i].x) * (y - vertices[i].y) / (vertices[j].y - vertices[i].y) + vertices[i].x)) {
            inside = !inside;
        }
    }
    
    return inside;
}



/*-------------------------------------------------------------------------------------*/
  

  /*
  ==================================================================================================
  ==================================UPDATE==========================================================
  ==================================================================================================
  */
  public void update(float dt, int iterations) {
    if(IS_PAUSED) {
      return;
    }
    if(isStatic) {
        return;
    }

    this.aabbUpdateRequired = true;
    this.transformUpdateRequired = true;
    dt /= (float)iterations;                
    this.RK4Position(dt);
    this.angularIntegration(dt);
    }


  /*
  ==================================================================================================
  ================================== INTEGRATOR ====================================================
  ==================================================================================================
  */

     public void RK4Position(float dt) {

        /*-------------- RK4 Position And Velocity Integration --------------*/
        PVector k1_v = PVector.mult(calculateAcceleration(this.position), dt);
        PVector k1_r = PVector.mult(this.linearVelocity, dt);

        PVector k2_v = PVector.mult(calculateAcceleration(PVector.add(this.position, PVector.mult(k1_r, 0.5f))), dt);
        PVector k2_r = PVector.mult(PVector.add(this.linearVelocity, PVector.mult(k1_v, 0.5f)), dt);

        PVector k3_v = PVector.mult(calculateAcceleration(PVector.add(this.position, PVector.mult(k2_r, 0.5f))), dt);
        PVector k3_r = PVector.mult(PVector.add(this.linearVelocity, PVector.mult(k2_v, 0.5f)), dt);

        PVector k4_v = PVector.mult(calculateAcceleration(PVector.add(this.position, k3_r)), dt);
        PVector k4_r = PVector.mult(PVector.add(this.linearVelocity, k3_v), dt);
        /*-------------------------------------------------------------------*/


        /*-------------- Reusable Vectors --------------*/
        PVector two_k2_r = PVector.mult(k2_r, 2);
        PVector two_k3_r = PVector.mult(k3_r, 2);

        PVector two_k2_v = PVector.mult(k2_v, 2);
        PVector two_k3_v = PVector.mult(k3_v, 2);
        /*-----------------------------------------------*/


        /*-------------- Final Position and Velocity --------------*/
        PVector finalPosition = PVector.add(this.position, PVector.div(PVector.add(k1_r, PVector.add(two_k2_r, PVector.add(two_k3_r, k4_r))), 6));
        PVector finalVelocity = PVector.add(this.linearVelocity, PVector.div(PVector.add(k1_v, PVector.add(two_k2_v, PVector.add(two_k3_v, k4_v))), 6));
        /*---------------------------------------------------------*/


        /*----------------- Update To New Values -----------------*/
        this.position = finalPosition;
        this.linearVelocity = finalVelocity;
        this.transformUpdateRequired = true;
        /*--------------------------------------------------------*/

  }


  public void angularIntegration(float dt) {

    this.angularVelocity += this.netTorque * this.InvRotationalInertia * dt;
    this.angle += this.angularVelocity*dt;


  }




    public PVector calculateAcceleration(PVector position) {

        /*--------------- Force Reset --------------*/
        this.netForce.set(0,0,0);
        this.netTorque = 0f;
        /*------------------------------------------*/

        /*------------ Net Force Calculation ------------*/
        for (ForceRegistry force : this.forceRegistry) {

            PVector currentForce = force.getForce(this, position);
            this.netForce.add(currentForce);

            PVector leverArm = PVector.sub(force.getApplicationPoint(this, this.position), this.position);
            this.netTorque += leverArm.cross(currentForce).z;

        }
        /*-----------------------------------------------*/

        /*------------ Acceleration Calculation ------------*/
        return this.netForce.mult(this.InvMass);
        /*--------------------------------------------------*/

    }



  /*
  ============================================= Methods =======================================================
  */

  public void delete() {
    for(ForceRegistry force : this.forceRegistry) {
      Rigidbody rigidbodyA = force.getRigidbodyA();
      Rigidbody rigidbodyB = force.getRigidbodyB();
      ALL_FORCES_ARRAYLIST.remove(force);

      if((rigidbodyA != null && rigidbodyA != this)) {
        rigidbodyA.removeForceFromForceRegistry(force);
      } else if(rigidbodyB != null && rigidbodyB != this) {
        rigidbodyB.removeForceFromForceRegistry(force);
      } 
    }
    rigidbodyList.remove(this);
  }

  public void copy(Rigidbody rigidbody) {
    
    this.ID = UUID.randomUUID().toString();
    this.position.set(rigidbody.position);
    this.linearVelocity.set(rigidbody.linearVelocity);
    this.angle = rigidbody.angle;
    this.angularVelocity = rigidbody.angularVelocity;
    this.ShapeType = rigidbody.ShapeType;
    this.Mass = rigidbody.Mass;
    this.InvMass = rigidbody.InvMass;
    this.Density = rigidbody.Density;
    this.Restitution = rigidbody.Restitution;
    this.Area = rigidbody.Area;
    this.Radius = rigidbody.Radius;
    this.Width = rigidbody.Width;
    this.Height = rigidbody.Height;
    this.coefficientOfStaticFriction = rigidbody.coefficientOfStaticFriction;
    this.coefficientOfKineticFriction = rigidbody.coefficientOfKineticFriction;

    this.Vertices = rigidbody.Vertices;
    this.transformedVertices = rigidbody.transformedVertices;


    this.strokeWeight = rigidbody.strokeWeight;
    this.strokeColour = rigidbody.strokeColour;
    this.fillColour = rigidbody.fillColour;
    this.isStatic = rigidbody.isStatic;
    this.isTranslationallyStatic = rigidbody.isTranslationallyStatic;
    this.isRotationallyStatic = rigidbody.isRotationallyStatic;
    this.isVisible = rigidbody.isVisible;
    this.isCollidable = rigidbody.isCollidable;

    this.aabbUpdateRequired = true;
    this.transformUpdateRequired = true;

  }

  public float getMass() {
    return this.Mass;
  }

  public void setMass(float mass) {
    this.Mass = mass;
    this.InvMass = 1/mass;
    this.RotationalInertia = (this.ShapeType == ShapeType.BOX) ? 0.5f * Mass * width * width + height * height : 0.5f * Mass * this.Radius * this.Radius;
    this.InvRotationalInertia = (this.RotationalInertia > 0) ? 1 / this.RotationalInertia : 0;
  }


  public float getDensity() {
    return this.Density;
  }

  public void setDensity(float density) {
    this.Density = density;
    this.setMass(this.Area * this.Density);
  }
  
  public float getRestitution() {
    return this.Restitution;
  }

  public void setRestitution(float restitution) {
    this.Restitution = restitution;
  }
  
  public void setArea(float area) {
    this.Area = area;
  }

  public float getArea() {
    return this.Area;
  }
  
  public float getRadius() {
    return this.Radius;
  }

  public void setRadius(float radius) {
    this.Radius = radius;
    this.Area = (float) PI * this.Radius * this.Radius;
    setDensity(this.Density);
  }

  public float getWidth() {
    return this.Width;
  }

  public void setWidth(float width) {
    if(this.ShapeType == ShapeType.BOX) {
      this.Width = width;
      this.Area = this.Width*this.Height;
      setDensity(this.Density);
      this.Vertices = CreateBoxVertices(this.Width, this.Height);
      this.transformUpdateRequired = true;
    }
  }

  public float getHeight() {
    return this.Height;
  }
  
  public void setHeight(float height) {
    this.Height = height;
    this.Area = this.Width*this.Height;
    setDensity(this.Density);
    this.Vertices = CreateBoxVertices(this.Width, this.Height);
    this.transformUpdateRequired = true;
  }

  public ShapeType getShapeType() {
    return this.ShapeType;
  }

  public void setShapeType(ShapeType shapeType) {
    this.ShapeType = shapeType;
  }

  public void setVertices(PVector[] vertices) {
    this.Vertices = vertices;
  }

  public PVector[] getVertices() {
    return this.Vertices;
  }

  public void setTransformedVerticesLength(int length) {
    this.transformedVertices = new PVector[length];
  }
  
  public float getInvMass() {
    return this.InvMass;
  }

  public float getRotationalInertia() {
    return this.RotationalInertia;
  }

  public float getInvRotationalInertia() {
    return this.InvRotationalInertia;
  }




  
/*
==================================================================================================
==================================GETTERS & SETTERS===============================================
==================================================================================================
*/
    public String getID(){
      return this.ID;
    }
    
    public void setID(String ID) {
      this.ID = ID;
    }
    
    public boolean getTransformUpdateRequired() {
      return this.transformUpdateRequired;
    }
    
    public void setTransformUpdateRequired(boolean transformUpdateRequired) {
      this.transformUpdateRequired = transformUpdateRequired;
    }
    
    public boolean getAABBUpdateRequired() {
      return this.aabbUpdateRequired;
    }
    
    public void setAABBUpdateRequired(boolean aabbUpdateRequired) {
      this.aabbUpdateRequired = aabbUpdateRequired;
    }
    
    public PVector getPosition() {
      return this.position;
    }
    
    public void setPosition(PVector position) {
      this.transformUpdateRequired = true;
      this.aabbUpdateRequired = true;
      this.position.set(position);
    }

    public void addPosition(PVector difference) {
      this.transformUpdateRequired = true;
      this.aabbUpdateRequired = true;
      this.position.add(difference);
    }

    public void addPosition(float x, float y) {
      this.transformUpdateRequired = true;
      this.aabbUpdateRequired = true;
      this.position.add(x, y);
    }

    public PVector getVelocity() {
      return this.linearVelocity;
    }
    
    public void setVelocity(PVector velocity) {
      this.linearVelocity = velocity;
    }
    
    public float getStrokeWeight() {
      return this.strokeWeight;
    }
    
    public void setStrokeWeight(float strokeWeight) {
      this.strokeWeight = strokeWeight;
    }
    
    public PVector getStrokeColour() {
      return this.strokeColour;
    }
    
    public void setStrokeColour(PVector strokeColour) {
      this.strokeColour = strokeColour;
    }
    //Overloaded method for setting stroke colour with 3 floats
    public void setStrokeColour(float r, float g, float b) {
      this.strokeColour = new PVector(r, g, b);
    }
    
    public PVector getFillColour() {
      return this.fillColour;
    }
    
    
    public void setFillColour(PVector fillColour) {
      this.fillColour = fillColour;
    }
    //Overloaded method for setting fill colour with 3 floats
    public void setFillColour(float r, float g, float b) {
      this.fillColour = new PVector(r, g, b);
    }
    
    public ArrayList<ForceRegistry> getForceRegistry() {
      return this.forceRegistry;
    }
    
    public ForceRegistry getForceFromForceRegistry(int index) {
      return this.forceRegistry.get(index);
    }
    
    public int getForceRegistrySize() {
      return this.forceRegistry.size();
    }
    
    public void addForceToForceRegistry(ForceRegistry forceRegistry) {
      this.forceRegistry.add(forceRegistry);
    }
    
    public void clearForceRegistry() {
      this.forceRegistry.clear();
    }
    
    public void removeForceFromForceRegistry(ForceRegistry forceRegistry) {
      this.forceRegistry.remove(forceRegistry);
    }
    
    public void removeForceFromForceRegistry(int index) {
      this.forceRegistry.remove(index);
    }
    
    public boolean getIsStatic() {
      return this.isStatic;
    }
    
    public void setIsStatic(boolean isStatic) {
      this.isStatic = isStatic;
      if(isStatic) {
        this.InvMass = 0f;
        this.InvRotationalInertia = 0f;
      }
    }
    
    public boolean getIsVisible() {
      return this.isVisible;
    }
    
    public void setIsVisible(boolean isVisible) {
      this.isVisible = isVisible;
    }
      public float getAngle() {
      return this.angle;
    }
    
    public void setAngle(float angle) {
      this.transformUpdateRequired = true;
      this.angle = angle;
    }
    
    public void addBodyToCollisionExclusionList(Rigidbody rigidbody) {
      this.collisionExclusionList.add(rigidbody);
    }
    
    public ArrayList<Rigidbody> getCollisionExclusionList() {
      return this.collisionExclusionList;
    }
    
    public float getAngularVelocity(){
      return this.angularVelocity;
    }
    
    public void setAngularVelocity(float angularVelocity) {
      this.angularVelocity = angularVelocity;
    }


    public float getCoefficientOfKineticFriction() {
        return this.coefficientOfKineticFriction;
    }

    public void setCoefficientOfKineticFriction(float coefficientOfKineticFriction) {
        this.coefficientOfKineticFriction = coefficientOfKineticFriction;
    }

    public float getCoefficientOfStaticFriction() {
        return this.coefficientOfStaticFriction;
    }

    public void setCoefficientOfStaticFriction(float coefficientOfStaticFriction) {
        this.coefficientOfStaticFriction = coefficientOfStaticFriction;
    }

    public boolean getIsTranslationallyStatic() {
        return this.isTranslationallyStatic;
    }

    public void setIsTranslationallyStatic(boolean isTranslationallyStatic) {
        this.isTranslationallyStatic = isTranslationallyStatic;

        if(this.isTranslationallyStatic) {
          this.InvMass = 0f;
        }
    }

    public boolean getIsRotationallyStatic() {
        return this.isRotationallyStatic;
    }

    public void setIsRotationallyStatic(boolean isRotationallyStatic) {
        this.isRotationallyStatic = isRotationallyStatic;
        if(this.isRotationallyStatic) {
          this.InvRotationalInertia = 0f;
        }
    }

    
    public boolean getCollidability() {
        return this.isCollidable;
    }

    public void setCollidability(boolean isCollidable) {
        this.isCollidable = isCollidable;
    }

}
public class Rod implements ForceRegistry {
/*-------------------------------------------------------------------------------------------------*/
    private float length = 0f;
    private float stiffness = 250000.0f;
    private float damping = 1.0f;

    private PVector localAnchorA = new PVector();
    private PVector localAnchorB = new PVector();
    private PVector anchorPoint = new PVector();

    private boolean isTwoBodyRod;
    private boolean isJoint;

    private Rigidbody rigidbodyA;
    private Rigidbody rigidbodyB;


/*-------------------------------------------------------------------------------------------------*/
    private PVector worldAnchorA = new PVector();
    private PVector worldAnchorB = new PVector();

    private PVector drawWorldAnchorA = new PVector();
    private PVector drawWorldAnchorB = new PVector();

    private PVector relativeVelocity = new PVector();

    private PVector velocityA = new PVector();
    private PVector velocityB = new PVector();

    private PVector dampingForce = new PVector();
    private PVector direction = new PVector();
    private PVector rodForce = new PVector();
    private PVector force = new PVector();
    private PVector rigidbodyOrientation = new PVector();

    private float displacement;
    private float dot;
    private float currentRigidbodyAngle;

/*-------------------------------------------------------------------------------------------------*/
//Reusable stuff


    public Rod(Rigidbody rigidbodyA, PVector localAnchorA, PVector anchorPoint) {

        this.rigidbodyA = rigidbodyA;

        this.anchorPoint.set(anchorPoint);
        this.localAnchorA.set(localAnchorA);

        this.isTwoBodyRod = false;

        if(rigidbodyA == null) {
            throw new NullPointerException("Rigidbody A is null");
        }
        
        this.length = PVector.sub(PhysEngMath.Transform(this.localAnchorA, this.rigidbodyA.getPosition(), this.rigidbodyA.getAngle()), 
                                  this.anchorPoint)
                                  .mag();
    }

    public Rod(Rigidbody rigidbodyA, Rigidbody rigidbodyB, PVector localAnchorA, PVector localAnchorB) {

        this.rigidbodyA = rigidbodyA;
        this.rigidbodyB = rigidbodyB;

        this.localAnchorA.set(localAnchorA);
        this.localAnchorB.set(localAnchorB);

        this.isTwoBodyRod = true;

        if(rigidbodyA == null) {
            throw new NullPointerException("Rigidbody A is null");
        } else if(rigidbodyB == null) {
            throw new NullPointerException("Rigidbody B is null");
        }

        this.length = PVector.sub(PhysEngMath.Transform(this.localAnchorB, this.rigidbodyB.getPosition(), this.rigidbodyB.getAngle()), 
                                  PhysEngMath.Transform(this.localAnchorA, this.rigidbodyA.getPosition(), this.rigidbodyA.getAngle()))
                                  .mag();
    }


@Override
public PVector getForce(Rigidbody rigidbody, PVector position) {

    this.force.set(0,0,0);

    if(isTwoBodyRod) {
        if(rigidbody == rigidbodyA) {
                this.worldAnchorA.set(PhysEngMath.Transform(this.localAnchorA, position, this.rigidbodyA.getAngle()));
                this.worldAnchorB.set(PhysEngMath.Transform(this.localAnchorB, this.rigidbodyB.getPosition(), this.rigidbodyB.getAngle()));

                this.velocityA.set(rigidbodyA.getVelocity());
                this.velocityB.set(rigidbodyB.getVelocity());

                this.direction.set(this.worldAnchorB.sub(this.worldAnchorA));
                
                this.displacement = direction.mag();
                this.direction.normalize();

                this.relativeVelocity.set(PVector.sub(this.velocityB, this.velocityA));

                this.dot = PVector.dot(relativeVelocity, this.direction);
                this.dampingForce.set(PVector.mult(this.direction, damping * dot));

                this.force.add(this.direction.mult(this.stiffness * (displacement - this.length)));
                this.force.add(this.dampingForce);
                
                return this.force;

            } else {
                this.worldAnchorA.set(PhysEngMath.Transform(this.localAnchorA, this.rigidbodyA.getPosition(), this.rigidbodyA.getAngle()));
                this.worldAnchorB.set(PhysEngMath.Transform(this.localAnchorB, position, this.rigidbodyB.getAngle()));

                this.velocityA.set(rigidbodyA.getVelocity());
                this.velocityB.set(rigidbodyB.getVelocity());


                this.direction.set(this.worldAnchorB.sub(this.worldAnchorA));
                this.displacement = direction.mag();
                this.direction.normalize();


                this.relativeVelocity.set(PVector.sub(this.velocityA, this.velocityB));
                this.dot = PVector.dot(relativeVelocity, this.direction);

                this.dampingForce.set(PVector.mult(direction, -damping * dot));

                this.force.add(this.dampingForce);
                this.force.add(this.direction.mult(this.stiffness * (displacement - this.length)));
                
                return this.force.mult(-1);

            } 

    } else {

        this.worldAnchorA.set(PhysEngMath.Transform(this.localAnchorA, position, this.rigidbodyA.getAngle()));
        this.worldAnchorB.set(this.anchorPoint);

        this.velocityA.set(rigidbodyA.getVelocity());
        this.velocityB.set(0,0);    

        this.direction.set(this.worldAnchorB.sub(this.worldAnchorA));
        this.displacement = direction.mag();
        this.direction.normalize();

        this.relativeVelocity.set(this.velocityB.sub(this.velocityA));
        this.dot = PVector.dot(relativeVelocity, this.direction);

        this.dampingForce.set(this.direction.copy().mult(-damping * dot));

        this.dampingForce.set(this.direction.copy().mult(-damping * PVector.dot(relativeVelocity, this.direction)));

        this.force.add(this.direction.mult(this.stiffness * (displacement - this.length)));
        this.force.add(this.dampingForce);
        
        return this.force;
                
    }
}



@Override
public void draw() {
    if(isTwoBodyRod){

        this.drawWorldAnchorA.set(PhysEngMath.Transform(this.localAnchorA, this.rigidbodyA.getPosition(), this.rigidbodyA.getAngle()));
        this.drawWorldAnchorB.set(PhysEngMath.Transform(this.localAnchorB, this.rigidbodyB.getPosition(), this.rigidbodyB.getAngle()));

        strokeWeight(0.15f);
        stroke(0);
        line(this.drawWorldAnchorA.x, this.drawWorldAnchorA.y, this.drawWorldAnchorB.x, this.drawWorldAnchorB.y);
        strokeWeight(0.1f);
        stroke(255);
        line(this.drawWorldAnchorA.x, this.drawWorldAnchorA.y, this.drawWorldAnchorB.x, this.drawWorldAnchorB.y);
    } else {

        this.drawWorldAnchorA.set(PhysEngMath.Transform(this.localAnchorA, this.rigidbodyA.getPosition(), this.rigidbodyA.getAngle()));

        strokeWeight(0.15f);
        stroke(0);
        line(this.drawWorldAnchorA.x, this.drawWorldAnchorA.y, this.anchorPoint.x, this.anchorPoint.y);
        strokeWeight(0.1f);
        stroke(255);
        line(this.drawWorldAnchorA.x, this.drawWorldAnchorA.y, this.anchorPoint.x, this.anchorPoint.y);

    }
}  



@Override
public PVector getApplicationPoint(Rigidbody rigidbody, PVector position) {
        if(rigidbody == rigidbodyA) {
            return PhysEngMath.Transform(localAnchorA, rigidbodyA.getPosition(), rigidbody.getAngle());
        } else {
            return PhysEngMath.Transform(localAnchorB, rigidbodyB.getPosition(), rigidbody.getAngle());
        }
}


/*
====================================================================================================
===================================GETTERS AND SETTERS==============================================
====================================================================================================
*/
public void setLength(float length) {
    this.length = length;
  }

public void setAnchorPoint(PVector anchorPoint) {
    this.anchorPoint.set(anchorPoint);
  }

public void setLocalAnchorA(PVector localAnchorA) {
    this.localAnchorA.set(localAnchorA);
  }

public void setLocalAnchorB(PVector localAnchorB) {
    this.localAnchorB.set(localAnchorB);
  }

public void setStiffness(float stiffness) {
    this.stiffness = stiffness;
  }

public void setDamping(float damping) {
    this.damping = damping;
  }

public void setTwoBodyRod(boolean isTwoBodyRod) {
    this.isTwoBodyRod = isTwoBodyRod;
  }

public void setIsJoint(boolean isJoint) {
    this.isJoint = isJoint;

    if(this.isJoint) {
        if(this.isTwoBodyRod){
            this.length = 0f;
            rigidbodyA.addBodyToCollisionExclusionList(rigidbodyB);
            rigidbodyB.addBodyToCollisionExclusionList(rigidbodyA);
        } else {
            this.length = 0f;
        }
    }
}   



public float getLength() {
    return length;
  }

public PVector getAnchorPoint() {
    return anchorPoint;
  }

public PVector getLocalAnchorA() {
    return localAnchorA;
  }

public PVector getLocalAnchorB() {
    return localAnchorB;
  }

public float getStiffness() {
    return stiffness;
  }

public float getDamping() {
    return damping;
  }

public boolean getTwoBodyRod() {
    return isTwoBodyRod;
  }

public boolean getIsJoint() {
    return this.isJoint;
}
@Override
public Rigidbody getRigidbodyA() {
    return rigidbodyA;
  }
@Override
public Rigidbody getRigidbodyB() {
    if(this.isTwoBodyRod) {
        return this.rigidbodyB;
    }
    return this.rigidbodyA;
  }



}



                /*
                if(!this.isHingeable) {
                    float rigidbodyAngle = rigidbodyB.getAngle();
                    this.rigidbodyOrientation.set(cos(rigidbodyAngle), sin(rigidbodyAngle));

                    float angleBetween = PVector.angleBetween(this.direction, this.rigidbodyOrientation);

                    if (this.direction.copy().cross(this.rigidbodyOrientation).z < 0) {
                        angleBetween = -angleBetween;
                    }

                    float angleDifference = angleBetween - this.initialAngleB;
                    //this.netTorque = -angleStiffness * angleDifference - angleDamping * rigidbody.getAngularVelocity();
                    //rigidbodyB.setAngle(rigidbodyB.getAngle()-angleDifference);
                    //force.add(0, 0, correctiveTorque);
                }
                */
  
public class Shape {


  private int opacity = 166;


  private PVector fill = new PVector();
  private PVector stroke = new PVector();

  public Shape() {
  }
  
  public void draw() {
    background(16, 18, 19);
    drawRigidbodies();
  /*---------------------------------Collision Point Debugging--------------------------------------*/
    if(DRAW_AABBS) {
      drawAABB();
    }
    
    if(DRAW_CONTACT_POINTS) {
      drawCollisionPoints();
    }
  /*-----------------------------------------------------------------------------------------------*/
    drawForces();
  }

/*
====================================================================================================
====================================== Drawing Methods =============================================
====================================================================================================
*/
  public void drawRigidbodies() {

    for(int body = 0; body < rigidbodyList.size(); body++) {

      Rigidbody rigidbody = rigidbodyList.get(body);
        if(rigidbody.getIsVisible()) {
          if (rigidbody.getShapeType() == ShapeType.CIRCLE) {
            drawCircle(rigidbody.getPosition(), rigidbody.getRadius(),
                      rigidbody.getAngle(), rigidbody.getStrokeWeight(), rigidbody.getFillColour(),
                       rigidbody.getStrokeColour(), false);
          }

          if (rigidbody.getShapeType() == ShapeType.BOX) {
            
              drawPolygon(rigidbody.getPosition(), rigidbody.GetTransformedVertices(),
                          rigidbody.getStrokeWeight(), rigidbody.getFillColour(),
                          rigidbody.getStrokeColour(), false);
          }
        }
      }
  }

  public void drawCircle(PVector position, float radius, float angle, float strokeWeight, PVector fillColour,
    PVector strokeColour, boolean inEditMode) {

    float diameter = radius * 2.0f;

    this.stroke.set(strokeColour);
    this.fill.set(fillColour);


    if(inEditMode) {
      fill(this.fill.x, this.fill.y, this.fill.z, this.opacity);
      stroke(this.stroke.x, this.stroke.y, this.stroke.z, this.opacity);
    } else {
      fill(this.fill.x, this.fill.y, this.fill.z);
      stroke(this.stroke.x, this.stroke.y, this.stroke.z);
    }

    strokeWeight(strokeWeight);
    ellipseMode(CENTER);
    ellipse(position.x, position.y,  diameter,  diameter);

    PVector va = new PVector();
    PVector vb = new PVector(radius, 0);
    va = PhysEngMath.Transform(va, position, angle);
    vb = PhysEngMath.Transform(vb, position, angle);
    line(va.x, va.y, vb.x, vb.y);
    }

  public void drawCircle(PVector position, float radius, float angle, float strokeWeight, PVector fillColour,
    PVector strokeColour, float opacity) {

    float diameter = radius * 2.0f;

    this.stroke.set(strokeColour);
    this.fill.set(fillColour);

    fill(this.fill.x, this.fill.y, this.fill.z, opacity);
    stroke(this.stroke.x, this.stroke.y, this.stroke.z, opacity);

    strokeWeight(strokeWeight);
    ellipseMode(CENTER);
    ellipse(position.x, position.y,  diameter,  diameter);

    PVector va = new PVector();
    PVector vb = new PVector(radius, 0);
    va = PhysEngMath.Transform(va, position, angle);
    vb = PhysEngMath.Transform(vb, position, angle);
    line(va.x, va.y, vb.x, vb.y);
  }
  

  public void drawBox(PVector position, float width, float height, float angle, float strokeWeight,
    PVector fillColour, PVector strokeColour, boolean inEditMode) {

    this.stroke.set(strokeColour);
    this.fill.set(fillColour);


    if(inEditMode) {
      fill(this.fill.x, this.fill.y, this.fill.z, this.opacity);
      stroke(this.stroke.x, this.stroke.y, this.stroke.z, this.opacity);
    } else {
      fill(this.fill.x, this.fill.y, this.fill.z);
      stroke(this.stroke.x, this.stroke.y, this.stroke.z);
    }
    strokeWeight(strokeWeight);
    rectMode(CENTER);
    pushMatrix();
    rect(position.x, position.y, width, height);
    popMatrix();
  }

  public void drawBox(PVector position, float width, float height, float angle, float strokeWeight,
    PVector fillColour, PVector strokeColour, int opacity) {

    this.stroke.set(strokeColour);
    this.fill.set(fillColour);


    fill(this.fill.x, this.fill.y, this.fill.z, opacity);
    stroke(this.stroke.x, this.stroke.y, this.stroke.z, opacity);

    strokeWeight(strokeWeight);
    rectMode(CENTER);

    pushMatrix();
    rotate(angle);
    rect(position.x, position.y, width, height);
    popMatrix();
  }

  
  public void drawPolygon(PVector position, PVector[] transformedVertices, float strokeWeight,
    PVector fillColour, PVector strokeColour, boolean inEditMode) {
    
    this.stroke.set(strokeColour);
    this.fill.set(fillColour);

    if(inEditMode) {
      fill(this.fill.x, this.fill.y, this.fill.z, this.opacity);
      stroke(this.stroke.x, this.stroke.y, this.stroke.z, this.opacity);
    } else {
      fill(this.fill.x, this.fill.y, this.fill.z);
      stroke(this.stroke.x, this.stroke.y, this.stroke.z);
    }

    strokeWeight(strokeWeight);

    beginShape();
    for (PVector transformedVertex : transformedVertices) {
      vertex(transformedVertex.x, transformedVertex.y);
    }
    endShape(CLOSE);
  }






  public void drawAABB() {
    for(Rigidbody rigidbody : rigidbodyList) {
        AABB aabb = rigidbody.GetAABB();
        rectMode(CORNERS);
        stroke(255, 0, 0);
        noFill();
        rect(aabb.getMin().x, aabb.getMin().y, aabb.getMax().x, aabb.getMax().y);
    }
  }

/*-----------------------------------------------------------------------------------------------*/
public void drawForces() {
    for(Rigidbody rigidbody : rigidbodyList) {
        for(ForceRegistry force : rigidbody.getForceRegistry()) {
            force.draw();
        }
    }
}
/*---------------------------------Collision Point Debugging--------------------------------------*/
  public void drawCollisionPoints() {
      for(PVector point : pointsOfContactList) {
        stroke(0, 0, 0);
        strokeWeight(0.1f);
        noFill();
        rectMode(CENTER);
        rect(point.x, point.y, 1, 1);
      }
        pointsOfContactList.clear();
    }

  
/*-----------------------------------------------------------------------------------------------*/

/*
public void drawGrid(){

  float majorGridSize = 120;
  float secondaryMajorGridSize = 60;
  float minorGridSize = 30;

  // Calculate the number of grid lines based on the screen size and grid size
  int majorNumVerticalLines = min(ceil(width / majorGridSize), 1000);
  int secondaryMajornumVerticalLines = min(ceil(width / secondaryMajorGridSize), 1000);
  int minorNumVerticalLines = min(ceil(width / minorGridSize), 1000);

  int majorNumHorizontalLines = min(ceil(height / majorGridSize), 1000);
  int secondaryMajornumHorizontalLines = min(ceil(height / secondaryMajorGridSize), 1000);
  int minorNumHorizontalLines = min(ceil(height / minorGridSize), 1000);

  float majorOffsetX = ((Camera.position.x-width/2) * Camera.zoom) % majorGridSize;
  float majorOffsetY = ((Camera.position.y-height/2) * Camera.zoom) % majorGridSize;

  float secondaryMajorOffsetX = ((Camera.position.x-width/2)* Camera.zoom) % secondaryMajorGridSize;
  float secondaryMajorOffsetY = ((Camera.position.y-height/2) * Camera.zoom) % secondaryMajorGridSize;

  float minorOffsetX = ((Camera.position.x-width/2) * Camera.zoom) % minorGridSize;
  float minorOffsetY = ((Camera.position.y-height/2) * Camera.zoom) % minorGridSize;

// Draw the major vertical gridlines
for (int i = 0; i <= majorNumVerticalLines; i++) {
    float x = i * majorGridSize + majorOffsetX;
    fill(#3f3f3f);
    rect(x, 0, 1, height);
}

// Draw the major horizontal grid lines
for (int i = 0; i <= majorNumHorizontalLines; i++) {
    float y = i * majorGridSize + majorOffsetY;
    fill(#3f3f3f);
    rect(0, y, width, 0.25);
}

// Draw the secondary major vertical gridlines
for (int i = 0; i <= secondaryMajornumVerticalLines; i++) {
    float x = i * secondaryMajorGridSize + secondaryMajorOffsetX;
    fill(#3f3f3f);
    rect(x, 0, 0.5, height);
}

// Draw the secondary major horizontal grid lines
for (int i = 0; i <= secondaryMajornumHorizontalLines; i++) {
    float y = i * secondaryMajorGridSize + secondaryMajorOffsetY;
    fill(#3f3f3f);
    rect(0, y, width, 0.25);
}

//Draw the minor vertical gridlines
for (int i = 0; i <= minorNumVerticalLines; i++) {
    float x = i * minorGridSize + minorOffsetX;
    fill(#3f3f3f);
    rect(x, 0, 0.25, height);
}

// Draw the minor horizontal grid lines
for (int i = 0; i <= minorNumHorizontalLines; i++) {
    float y = i * minorGridSize + minorOffsetY;
    fill(#3f3f3f);
    rect(0, y, width, 0.25);
}
         
}
*/


}

public enum ShapeType {
  CIRCLE,
  BOX,
  POLYGON,
  SOFTBODY
}
//ID 0: CIRCLE
//ID 1: BOX
//ID 2: POLYGON
//ID 3: SOFTBODY
public class Softbody {

    private PVector initialPosition;

    private float radius;
    private float rectWidth;
    private float rectHeight;

    private float stiffness = 1000;
    private float damping = 1f;

    private int numRowParticles;
    private int numColumnParticles;

    private float particleRadius = 0.5f;

    private ArrayList<Rigidbody> softbodyEntityList = new ArrayList<Rigidbody>();
    private ArrayList<Rigidbody> edgeParticles = new ArrayList<Rigidbody>();
    private Rigidbody[][] softBodyParticles;

    

    public Softbody(PVector initialPosition, float radius, float RectWidth, float RectHeight) {
        this.initialPosition = initialPosition;
        this.radius = radius;

        this.rectWidth = (int)round(RectWidth);
        this.rectHeight = (int)round(RectHeight);

        //Create a way to calculate this later
        this.numRowParticles = (int)round(this.rectWidth/this.particleRadius);
        this.numColumnParticles = (int)round(this.rectHeight/this.particleRadius);
        softBodyParticles = new Rigidbody[numRowParticles][numColumnParticles];

        softbodyList.add(this);
    }


    public void CreateBoxSoftbody() {
        float spacingX = 2f;
        float spacingY = 2f;

        float initialParticlePositionX = this.initialPosition.x - this.rectWidth/2;
        float initialParticlePositionY = this.initialPosition.y - this.rectHeight/2;

        for(int row = 0; row < numRowParticles; row++) {
            for(int column = 0; column < numColumnParticles; column++) {

                PVector currentParticlePosition = new PVector(initialParticlePositionX + row*spacingX, initialParticlePositionY + column*spacingY);

                Rigidbody currentParticle = RigidbodyGenerator.CreateCircleBody(particleRadius, 0.5f, 0.1f, false, true, 0.1f, new PVector(0,0,0), new PVector(255,255,255));
                currentParticle.setPosition(currentParticlePosition);

                softBodyParticles[row][column] = currentParticle;
                //currentParticle.setCollidability(false);
                currentParticle.addForceToForceRegistry(new Gravity(currentParticle));
                currentParticle.setIsVisible(false);
                AddBodyToBodyEntityList(currentParticle);
            }
        }


for(int row = 0; row < numRowParticles; row++) {
    for(int column = 0; column < numColumnParticles; column++) {

        Rigidbody currentParticle = softBodyParticles[row][column];

        // Link to particle below if it exists
        if(row < numRowParticles - 1) {
            Rigidbody particleToLinkTo = softBodyParticles[row+1][column];
            addSpringBetweenParticles(currentParticle, particleToLinkTo);
        }

        // Link to particle to the right if it exists
        if(column < numColumnParticles - 1) {
            Rigidbody particleToLinkTo = softBodyParticles[row][column+1];
            addSpringBetweenParticles(currentParticle, particleToLinkTo);
        }

        // Link to bottom-right diagonal if it exists
        if(row < numRowParticles - 1 && column < numColumnParticles - 1) {
            Rigidbody particleToLinkTo = softBodyParticles[row+1][column+1];
            addSpringBetweenParticles(currentParticle, particleToLinkTo);
        }

        // Link to top-right diagonal if it exists
        if(row > 0 && column < numColumnParticles - 1) {
            Rigidbody particleToLinkTo = softBodyParticles[row-1][column+1];
            addSpringBetweenParticles(currentParticle, particleToLinkTo);
        }
        
    }
}

    }

private void addSpringBetweenParticles(Rigidbody particleA, Rigidbody particleB) {
    Spring spring = new Spring(particleA, particleB, new PVector(), new PVector());
    
    spring.setSpringConstant(this.stiffness);
    spring.setDamping(this.damping);
    spring.drawSpring = false;

    particleA.addForceToForceRegistry(spring);
    particleB.addForceToForceRegistry(spring);
}

    public void updateSoftbody() {
      draw();
    }

    public void draw() {
        
        beginShape();
        for (int column = 0; column < numColumnParticles; column++) {
          PVector pos = softBodyParticles[0][column].getPosition();
          vertex(pos.x, pos.y);
        }
        // Right edge
        for (int row = 0; row < numRowParticles; row++) {
          PVector pos = softBodyParticles[row][numColumnParticles - 1].getPosition();
          vertex(pos.x, pos.y);
        }
        // Bottom edge
        for (int column = numColumnParticles - 1; column >= 0; column--) {
          PVector pos = softBodyParticles[numRowParticles - 1][column].getPosition();
          vertex(pos.x, pos.y);
        }
        // Left edge
        for (int row = numRowParticles - 1; row >= 0; row--) {
          PVector pos = softBodyParticles[row][0].getPosition();
          vertex(pos.x, pos.y);
        }
        endShape(CLOSE);

    }


/*

public void draw() {

    beginShape();
    PVector center = calculateCenter();
    // Top edge
    for (int column = 0; column < numColumnParticles; column++) {
        PVector pos = softBodyParticles[0][column].getPosition();
        PVector offset = pos.copy().sub(center).normalize().mult(particleRadius);
        vertex(pos.x + offset.x, pos.y + offset.y);
    }
    // Right edge
    for (int row = 0; row < numRowParticles; row++) {
        PVector pos = softBodyParticles[row][numColumnParticles - 1].getPosition();
        PVector offset = pos.copy().sub(center).normalize().mult(particleRadius);
        vertex(pos.x + offset.x, pos.y + offset.y);
    }
    // Bottom edge
    for (int column = numColumnParticles - 1; column >= 0; column--) {
        PVector pos = softBodyParticles[numRowParticles - 1][column].getPosition();
        PVector offset = pos.copy().sub(center).normalize().mult(particleRadius);
        vertex(pos.x + offset.x, pos.y + offset.y);
    }
    // Left edge
    for (int row = numRowParticles - 1; row >= 0; row--) {
        PVector pos = softBodyParticles[row][0].getPosition();
        PVector offset = pos.copy().sub(center).normalize().mult(radius);
        vertex(pos.x + offset.x, pos.y + offset.y);
    }

    endShape(CLOSE);
}

private PVector calculateCenter() {
    float totalX = 0;
    float totalY = 0;
    int count = 0;

    for (int row = 0; row < numRowParticles; row++) {
        for (int col = 0; col < numColumnParticles; col++) {
            PVector pos = softBodyParticles[row][col].getPosition();
            totalX += pos.x;
            totalY += pos.y;
            count++;
        }
    }

    if (count == 0) {
        return new PVector(0, 0); // or some default value in case there are no particles
    }

    float centerX = totalX / count;
    float centerY = totalY / count;

    return new PVector(centerX, centerY);
}
*/
}

public class Spring implements ForceRegistry {

    private Rigidbody rigidbodyA;
    private Rigidbody rigidbodyB;

    private PVector anchorPoint = new PVector();
    private PVector localAnchorA = new PVector();
    private PVector localAnchorB = new PVector();
    
    private boolean drawSpring = true;

    //Some default values
    private boolean lockTranslationToXAxis = false;
    private boolean lockTranslationToYAxis = false;
    
    private boolean isPerfectSpring = false;

    private float equilibriumLength = 1f; //Equilibrium length is a percentage of the total magnitude of the length
    private float springConstant = 50;
    private float damping = 0.5f;
    
    private float springLength;

    private boolean isTwoBodySpring;


    /*--------------- Reusable --------------- */
    private PVector worldAnchorA = new PVector();
    private PVector worldAnchorB = new PVector();

    private PVector velocityA = new PVector();
    private PVector velocityB = new PVector();

    private PVector direction = new PVector();


    public Spring () {
        this.rigidbodyA = null;
        this.rigidbodyB = null;
    }


    public Spring(Rigidbody rigidbody, PVector localAnchorA, PVector anchorPoint) {

        this.rigidbodyA = rigidbody;
        this.localAnchorA.set(localAnchorA);
        this.anchorPoint.set(anchorPoint);

        this.springLength = PhysEngMath.Transform(localAnchorA, rigidbodyA.getPosition(), rigidbodyA.getAngle()).sub(anchorPoint).mag();

        this.isTwoBodySpring = false;

    }

    public Spring(Rigidbody rigidbodyA, Rigidbody rigidbodyB, PVector localAnchorA, PVector localAnchorB) {
        
        this.rigidbodyA = rigidbodyA;
        this.rigidbodyB = rigidbodyB;
        
        this.localAnchorA.set(localAnchorA);
        this.localAnchorB.set(localAnchorB);
        
        this.springLength = PhysEngMath.Transform(localAnchorB, rigidbodyB.getPosition(), rigidbodyB.getAngle()).sub(PhysEngMath.Transform(localAnchorA, rigidbodyA.getPosition(), rigidbodyA.getAngle())).mag();

        this.isTwoBodySpring = true;

    }

    @Override
    public PVector getForce(Rigidbody rigidbody, PVector position) {
        float totalForceMagnitude = 0f;
        float displacement = 0f;

        if(isTwoBodySpring) {
            velocityA.set(rigidbodyA.getVelocity());
            velocityB.set(rigidbodyB.getVelocity());
    
            if(rigidbody == rigidbodyA) {
                worldAnchorA.set(PhysEngMath.Transform(this.localAnchorA, position, rigidbodyA.getAngle()));
                worldAnchorB.set(PhysEngMath.Transform(this.localAnchorB, rigidbodyB.getPosition(), rigidbodyB.getAngle()));

                if(lockTranslationToYAxis) rigidbodyA.setVelocity(velocityA.set(0, velocityA.y));
                else if(lockTranslationToXAxis) rigidbodyA.setVelocity(velocityA.set(velocityA.x, 0));

                this.direction.set(worldAnchorB.sub(worldAnchorA));
                displacement = direction.mag();

                if(!isPerfectSpring){                                                                                    
                    totalForceMagnitude = (displacement - this.springLength * this.equilibriumLength) * this.springConstant;
                    direction.normalize();
                    totalForceMagnitude += (direction.dot(velocityB.sub(velocityA)) * this.damping);
                } else {
                    totalForceMagnitude = (displacement - this.springLength * this.equilibriumLength) * this.springConstant;
                }
                return this.direction.mult(totalForceMagnitude);
    
            } else {
                worldAnchorA.set(PhysEngMath.Transform(this.localAnchorA, rigidbodyA.getPosition(), rigidbodyA.getAngle()));
                worldAnchorB.set(PhysEngMath.Transform(this.localAnchorB, position, rigidbodyB.getAngle()));
            
                this.direction.set(worldAnchorB.sub(worldAnchorA));
                displacement = direction.mag();
                direction.normalize();

                if(lockTranslationToYAxis) rigidbodyB.setVelocity(velocityB.set(0, velocityB.y));
                else if(lockTranslationToXAxis) rigidbodyB.setVelocity(velocityB.set(velocityB.x, 0));

                if(!isPerfectSpring){                                                                                    
                    totalForceMagnitude = (displacement - this.springLength * this.equilibriumLength) * this.springConstant;
                    totalForceMagnitude += (direction.dot(velocityB.sub(velocityA)) * this.damping);
                } else {
                    totalForceMagnitude = (displacement - this.springLength * this.equilibriumLength) * this.springConstant;
                }

                return this.direction.mult(-totalForceMagnitude);
            }
        } else {
            worldAnchorA.set(PhysEngMath.Transform(this.localAnchorA, position, rigidbodyA.getAngle()));
            worldAnchorB.set(anchorPoint);
    
            velocityA.set(rigidbodyA.getVelocity());
            velocityB.set(0,0);

            this.direction.set(worldAnchorB.sub(worldAnchorA));
            displacement = direction.mag();
            direction.normalize();

            if(lockTranslationToYAxis) rigidbodyA.setVelocity(velocityA.set(0, velocityA.y));
            else if(lockTranslationToXAxis) rigidbodyA.setVelocity(velocityA.set(velocityA.x, 0));
            
            if(!isPerfectSpring){                                                                                    
                totalForceMagnitude = (displacement - this.springLength * this.equilibriumLength) * this.springConstant;
                direction.normalize();
                totalForceMagnitude += (direction.dot(velocityB.sub(velocityA)) * this.damping);
            } else {
                totalForceMagnitude = (displacement- this.springLength * this.equilibriumLength) * this.springConstant;
            }

            return this.direction.mult(totalForceMagnitude);
        }
    
} 

  

//TODO: IMPLEMENT A WAY TO MAKE THE SPRING SCALE WITH ITS LENGTH, SO THAT VISUALLY A LARGE SPRING
//WILL HAVE THICKER LINES, AND MORE OFFSET, ETC
   /*
    @Override
    public void draw() {
        if(this.drawSpring) {
            PVector worldAnchorA;
            PVector worldAnchorB;
            PVector direction;
            float length;

            if(isTwoBodySpring) {
                worldAnchorA = PhysEngMath.Transform(localAnchorA, rigidbodyA.getPosition(), rigidbodyA.getAngle());
                worldAnchorB = PhysEngMath.Transform(localAnchorB, rigidbodyB.getPosition(), rigidbodyB.getAngle());
            } else {
                worldAnchorA = PhysEngMath.Transform(localAnchorA, rigidbodyA.getPosition(), rigidbodyA.getAngle());
                worldAnchorB = this.anchorPoint;
            }

            direction = PVector.sub(worldAnchorA, worldAnchorB);
            length = direction.mag();
            direction.normalize();

            fill(255);

            float segments = 5;
            float segmentLength = length / segments;

            // Set the offset to a constant value
            float offsetMagnitude = 0.5; // Adjust this value to change the size of the zigzags

            // Draw the rod
            strokeWeight(0.3);
            stroke(0); // Black
            line(worldAnchorA.x, worldAnchorA.y, worldAnchorB.x, worldAnchorB.y);
            stroke(255); // White
            strokeWeight(0.1);
            line(worldAnchorA.x, worldAnchorA.y, worldAnchorB.x, worldAnchorB.y);
            
            PVector segmentStart = new PVector();
            PVector segmentEnd = new PVector();
            PVector midPoint = new PVector();
            PVector midPoint1 = new PVector();
            PVector midPoint2 = new PVector();
            PVector directionSegmentLength = PVector.mult(direction, segmentLength);
            PVector offset1 = new PVector();
            PVector offset2 = new PVector();

            for(int i = 0; i < segments; i++) {

                segmentStart.set(PVector.add(worldAnchorB, PVector.mult(directionSegmentLength, i)));
                segmentEnd.set(PVector.add(worldAnchorB, PVector.mult(directionSegmentLength, i + 1)));

                // Calculate the midpoint of the segment
                midPoint.set(PVector.lerp(segmentStart, segmentEnd, 0.5f));

                if(i % 2 == 0) {
                    offset1.set(new PVector(-direction.y, direction.x).mult(offsetMagnitude));
                    offset2.set(new PVector(direction.y, -direction.x).mult(offsetMagnitude));
                } else {
                    offset1.set(new PVector(direction.y, -direction.x).mult(offsetMagnitude));
                    offset2.set(new PVector(-direction.y, direction.x).mult(offsetMagnitude));
                }

                // Add the offsets to the midpoint
                midPoint1.set(PVector.add(midPoint, offset1));
                midPoint2.set(PVector.add(midPoint, offset2));

                // Draw the lines
                strokeWeight(0.2);
                stroke(0);
                line(segmentStart.x, segmentStart.y, midPoint1.x, midPoint1.y);
                line(midPoint1.x, midPoint1.y, segmentEnd.x, segmentEnd.y);
                line(segmentStart.x, segmentStart.y, midPoint2.x, midPoint2.y);
                line(midPoint2.x, midPoint2.y, segmentEnd.x, segmentEnd.y);
                strokeWeight(0.1);
                stroke(255);
                line(segmentStart.x, segmentStart.y, midPoint1.x, midPoint1.y);
                line(midPoint1.x, midPoint1.y, segmentEnd.x, segmentEnd.y);
                line(segmentStart.x, segmentStart.y, midPoint2.x, midPoint2.y);
                line(midPoint2.x, midPoint2.y, segmentEnd.x, segmentEnd.y);
            }
        } else {
            return;
        }
    }
    */
public void draw() {
    if(this.drawSpring) {
        PVector worldAnchorA;
        PVector worldAnchorB;
        PVector direction;
        float length;

        if(isTwoBodySpring) {
            worldAnchorA = PhysEngMath.Transform(localAnchorA, rigidbodyA.getPosition(), rigidbodyA.getAngle());
            worldAnchorB = PhysEngMath.Transform(localAnchorB, rigidbodyB.getPosition(), rigidbodyB.getAngle());
        } else {
            worldAnchorA = PhysEngMath.Transform(localAnchorA, rigidbodyA.getPosition(), rigidbodyA.getAngle());
            worldAnchorB = this.anchorPoint;
        }

        direction = PVector.sub(worldAnchorA, worldAnchorB);
        length = direction.mag();
        direction.normalize();

        fill(255);

        float segments = 5;
        float segmentLength = length / segments;

        // Set the offset to a constant value
        float offsetMagnitude = 0.5f; // Adjust this value to change the size of the zigzags

        // Draw the rod
        strokeWeight(0.3f);
        stroke(0); // Black
        line(worldAnchorA.x, worldAnchorA.y, worldAnchorB.x, worldAnchorB.y);
        stroke(255); // White
        strokeWeight(0.1f);
        line(worldAnchorA.x, worldAnchorA.y, worldAnchorB.x, worldAnchorB.y);
        
        PVector segmentStart = new PVector();
        PVector segmentEnd = new PVector();
        PVector midPoint = new PVector();
        PVector offset = new PVector();
        PVector directionSegmentLength = PVector.mult(direction, segmentLength);

        for(int i = 0; i < segments; i++) {

            segmentStart.set(PVector.add(worldAnchorB, PVector.mult(directionSegmentLength, i)));
            segmentEnd.set(PVector.add(worldAnchorB, PVector.mult(directionSegmentLength, i + 1)));

            // Calculate the midpoint of the segment
            midPoint.set(PVector.lerp(segmentStart, segmentEnd, 0.5f));

            // Alternate the offset direction to give appearance of spring
            if(i % 2 == 0) {
                offset.set(new PVector(-direction.y, direction.x).mult(offsetMagnitude));
            } else {
                offset.set(new PVector(direction.y, -direction.x).mult(offsetMagnitude));
            }

            // Add the offset to the midpoint
            PVector midPointOffset = PVector.add(midPoint, offset);

            // Draw the lines
            strokeWeight(0.2f);
            stroke(0);
            line(segmentStart.x, segmentStart.y, midPointOffset.x, midPointOffset.y);
            line(midPointOffset.x, midPointOffset.y, segmentEnd.x, segmentEnd.y);
            strokeWeight(0.1f);
            stroke(255);
            line(segmentStart.x, segmentStart.y, midPointOffset.x, midPointOffset.y);
            line(midPointOffset.x, midPointOffset.y, segmentEnd.x, segmentEnd.y);
        }
    } else {
        return;
    }
}
    

    @Override
    public PVector getApplicationPoint(Rigidbody rigidbody, PVector position) {
            if(rigidbody == rigidbodyA) {
                return PhysEngMath.Transform(localAnchorA, position, rigidbodyA.getAngle());
            } else {
                return PhysEngMath.Transform(localAnchorB, position, rigidbodyB.getAngle());
            }
    }

/*
====================================================================================================
================================== Getters & Setters ===============================================
====================================================================================================
*/
    public void setRigidbodyA(Rigidbody rigidbody){
        this.rigidbodyA = rigidbody;
    }
    public void setSpringConstant(float springConstant) {
        this.springConstant = springConstant;
    }

    public void setSpringLength(float springLength) {
        this.springLength = springLength;
    }

    public void setEquilibriumLength(float equilibriumLength) {
        this.equilibriumLength = equilibriumLength;
    }

    public void setDamping(float damping) {
        this.damping = damping;
    }

    public void setLockTranslationToXAxis(boolean lockTranslationToXAxis) {
        this.lockTranslationToXAxis = lockTranslationToXAxis;
    }

    public void setLockTranslationToYAxis(boolean lockTranslationToYAxis) {
        this.lockTranslationToYAxis = lockTranslationToYAxis;
    }

    public void setPerfectSpring(boolean isPerfectSpring) {
        this.isPerfectSpring = isPerfectSpring;
    }
    public void setDrawSpring(boolean drawSpring) {
        this.drawSpring = drawSpring;
    }
    public void setAnchorPoint(PVector anchorPoint) {
        this.anchorPoint.set(anchorPoint);
    }

    public void setAnchorPoint(float x, float y) {
        this.anchorPoint.set(x, y);
    }

    public void setLocalAnchorA(PVector localAnchorA) {
        this.localAnchorA.set(localAnchorA);
    }

    public void setLocalAnchorA(float x, float y) {
        this.localAnchorA.set(x, y);
    }

    public void setLocalAnchorB(PVector localAnchorB) {
        this.localAnchorB.set(localAnchorB);
    }

    public void setLocalAnchorB(float x, float y) {
        this.localAnchorB.set(x, y);
    }

    public float getSpringConstant() {
        return this.springConstant;
    }

    public float getSpringLength() {
        return this.springLength;
    }

    public float getEquilibriumLength() {
        return this.equilibriumLength;
    }

    public float getDamping() {
        return this.damping;
    }

    public boolean getLockTranslationToXAxis() {
        return this.lockTranslationToXAxis;
    }

    public boolean getLockTranslationToYAxis() {
        return this.lockTranslationToYAxis;
    }

    public boolean getPerfectSpring() {
        return this.isPerfectSpring;
    }

    public PVector getAnchorPoint() {
        return this.anchorPoint;
    }

    public PVector getLocalAnchorA() {
        return this.localAnchorA;
    }

    public PVector getLocalAnchorB() {
        return this.localAnchorB;
    }

    public boolean getDrawSpring() {
        return this.drawSpring;
    }
    @Override
    public Rigidbody getRigidbodyA() {
        return this.rigidbodyA;
    }
    @Override
    public Rigidbody getRigidbodyB() {
        if(isTwoBodySpring) {
            return this.rigidbodyB;
        }
        return this.rigidbodyA;
    }

    public boolean getIsTwoBodySpring() {
        return this.isTwoBodySpring;
    }
}


public class UI_Button extends UI_Element {
    

    public UI_Window Button_ParentWindow;

    public String Button_Name;
    public float Button_Name_Position_X;
    public float Button_Name_Position_Y;

    public boolean Button_State;

    public PShape Button_Shape_Group = createShape(GROUP);

    public UI_Button (String Button_Name, UI_Window Button_ParentWindow, boolean Button_State) {
        this.Button_Name = Button_Name;
        this.Button_State = Button_State;

        this.Button_Shape_Group.setName(this.Button_Name + "Group");
        this.Button_ParentWindow = Button_ParentWindow;

        this.initializeButton();
    }

    public void initializeButton() {
        rectMode(CENTER);
        this.createElementBaseShape();
        this.createElementText();
    }




/*
======================================= Toggle Creation ============================================
*/  
    @Override
    public void createElementBaseShape() {
        rectMode(CENTER);
        int numElements = this.Button_ParentWindow.getWindowElementArrayListSize();

        float buttonShapeX;
        float buttonShapeY;
        float buttonShapeWidth;
        float buttonShapeHeight;

        if(numElements == 0) {
            buttonShapeX = 0;
            buttonShapeY = -this.Button_ParentWindow.getWindowFormContainerHeight() / 2 + this.Element_Container_Top_Padding_Y + this.Element_Height / 2;
            buttonShapeWidth = this.Element_Width;
            buttonShapeHeight = this.Element_Height;
            
        } else {
            buttonShapeX = 0;
            buttonShapeY = (this.Element_Height - this.Button_ParentWindow.getWindowFormContainerHeight()) /2 + (this.Element_Height + this.Element_Element_Padding_Y) * numElements + this.Element_Container_Top_Padding_Y;
            buttonShapeWidth = this.Element_Width;
            buttonShapeHeight = this.Element_Height;
        }

        PShape Button_Shape_Base = createShape(RECT, buttonShapeX, buttonShapeY, buttonShapeWidth, buttonShapeHeight, this.Element_Rounding);
            Button_Shape_Base.setName("Button_Shape_Base");
            Button_Shape_Base.setStrokeWeight(this.Element_Stroke_Weight);
            Button_Shape_Base.setFill(this.Element_Base_Unselected_Color);
            Button_Shape_Base.setStroke(this.Element_Base_Unselected_Stroke_Color);

        PShape Button_Shape_Listener = UI_Constants.createElementListener(Button_Shape_Base);
            Button_Shape_Listener.setName("Button_Shape_Listener");

        this.Button_Shape_Group.addChild(Button_Shape_Base);
        this.Button_Shape_Group.addChild(Button_Shape_Listener);
    }

    @Override 
    public void createElementText() {
        textFont(this.Element_Font);
        textSize(this.Element_Text_Size);
        textAlign(CENTER, CENTER);

        this.Button_Name_Position_X = this.Button_Shape_Group.getChild("Button_Shape_Base").getParam(0);
        this.Button_Name_Position_Y = this.Button_Shape_Group.getChild("Button_Shape_Base").getParam(1) - (textAscent() - textDescent()) * UI_Constants.GLOBAL_TEXT_ALIGN_FACTOR_Y;
    }

    

/*
======================================= Toggle Interaction =========================================
*/  
    @Override
    public boolean onMousePress() {
        float x = mouseX - this.Button_ParentWindow.getWindowPosition().x;
        float y = mouseY - this.Button_ParentWindow.getWindowPosition().y;
        return this.Button_Shape_Group.getChild("Button_Shape_Listener").contains(x, y);
    }

    @Override 
    public void onMouseRelease() {
        if(this.Button_State) {
            this.onDeselect();
        }
    }

    @Override
    public void onMouseDrag() {
        
    }
    

    @Override
    public void onSelect() {
        this.Button_State = true;
        this.Button_Shape_Group.getChild("Button_Shape_Base").setStroke(this.Element_Base_Selected_Stroke_Color);
        this.Button_Shape_Group.getChild("Button_Shape_Base").setFill(this.Element_Base_Selected_Color);
    }


    @Override
    public void onDeselect() {
        this.Button_State = false;
        this.Button_Shape_Group.getChild("Button_Shape_Base").setStroke(this.Element_Base_Unselected_Stroke_Color);
        this.Button_Shape_Group.getChild("Button_Shape_Base").setFill(this.Element_Base_Unselected_Color);
    }

/*
===================================== Toggle Draw ==================================================
*/

    @Override
    public void drawText() {
        fill(this.Element_Text_Color);
        textFont(this.Element_Font);
        textSize(this.Element_Text_Size);
        textAlign(CENTER, CENTER);

        text(this.Button_Name, this.Button_Name_Position_X, this.Button_Name_Position_Y);

    }


/*
======================================= Toggle Getters and Setters =================================
*/  
    @Override   
    public String getElementName() {
        return this.Button_Name;
    }

    @Override
    public PShape getShape() {
        return this.Button_Shape_Group;
    }

    @Override
    public boolean getState() {
        return this.Button_State;
    }
    @Override
    public String getGroupName() {
        return null;
    }

    @Override 
    public float getValue() {
        return 0;
    }

    @Override
    public void setValue(float value) {
        return;
    }

    @Override
    public void incrementValue(float amount) {

    }

    @Override
    public void setState(boolean state) {
        if(state) {
            this.onSelect();
        } else {
            this.onDeselect();
        }
    }

}   
public class UI_Constants {
/*---------------------------------------- Color -------------------------------------------------*/
    public final int BLUE_UNSELECTED = color(2, 60, 89);
    public final int BLUE_SELECTED = color(0, 123, 185);
    public final int GRAY_600 = color(22, 23, 23);
    public final int GRAY_500 = color(34, 35, 36);
    public final int GRAY_400 = color(44, 44, 47);
    public final int GRAY_300 = color(82, 82, 82);
    public final int GRAY_250 = color(107, 107, 107);
    public final int GRAY_200 = color(120, 120, 120);
    public final int GRAY_150 = color(158, 158, 158);
    public final int GRAY_100 = color(164, 164, 164);
    public final int GRAY_50 = color(176, 176, 176);
    public final int GRAY_25 = color(183, 183, 183);
    public final int GRAY_10 = color(196, 196, 196);
    public final int WHITE = color(255, 255, 255);
    public final int TRANSPARENT = color(0, 0, 0, 0);

/*---------------------------------------- Font -------------------------------------------------*/
    public final PFont INTER_BOLD = createFont(sketchPath() + "/data/fonts/Inter-Bold.ttf", 48);
    public final PFont INTER_MEDIUM = createFont(sketchPath() + "/data/fonts/Inter-Medium.ttf", 48);
    public final PFont INTER_REGULAR = createFont(sketchPath() + "/data/fonts/Inter-Regular.ttf", 48);

    public final PFont[] FONTS = {INTER_BOLD, INTER_MEDIUM, INTER_REGULAR};

/*------------------------------------------ Tab -------------------------------------------------*/
    public final float TAB_WIDTH = 355;
    public final float TAB_HEIGHT = 40; 

    public final float TAB_PADDING_Y = 12;
    public final float TAB_POSITION_X = displayWidth / 2;
    public final float TAB_POSITION_Y = TAB_PADDING_Y + TAB_HEIGHT / 2;

    public final int TAB_ROUNDING = 15;
    public final int TAB_FILL = GRAY_600;
    public final int TAB_STROKE = GRAY_400;

    public final int TAB_TEXT_SIZE = 16;
    public final String[] TAB_NAME = {"Settings", "Properties", "Creations", "Help"};
    public final PFont TAB_TEXT_FONT = INTER_BOLD;

    public final int TAB_TEXT_SELECTED_COLOR = WHITE;
    public final int TAB_TEXT_UNSELECTED_COLOR = GRAY_50;

    public final float TAB_STROKE_WEIGHT = 1.5f;


/*-------------------------------------- Tab Buttons ---------------------------------------------*/

    public final float TAB_BUTTON_WIDTH = 40;
    public final float TAB_BUTTON_HEIGHT = 40;

    public final float TAB_BUTTON_PADDING_X = 5;
    public final float TAB_BUTTON_POSITION_Y = TAB_POSITION_Y;

    public final float TAB_BUTTON_Q_POSITION_X = TAB_POSITION_X - TAB_WIDTH / 2 - TAB_BUTTON_WIDTH / 2 - TAB_BUTTON_PADDING_X;
    public final float TAB_BUTTON_E_POSITION_X = TAB_POSITION_X + TAB_WIDTH / 2 + TAB_BUTTON_WIDTH / 2 + TAB_BUTTON_PADDING_X;

    public final int TAB_BUTTON_ROUNDING = 15;

    public final int TAB_BUTTON_UNSELECTED_FILL = GRAY_600;
    public final int TAB_BUTTON_UNSELECTED_STROKE = GRAY_400;

    public final int TAB_BUTTON_SELECTED_FILL = GRAY_300;
    public final int TAB_BUTTON_SELECTED_STROKE = GRAY_400;

    public final float TAB_BUTTON_STROKE_WEIGHT = 1.5f;

    public final int TAB_BUTTON_TEXT_SIZE = 16;
    public final PFont TAB_BUTTON_TEXT_FONT = INTER_REGULAR;
    public final int TAB_BUTTON_TEXT_COLOR = GRAY_50;

/*-------------------------------------- Tab Selector ---------------------------------------------*/
    public final float TAB_SELECTOR_HEIGHT = 26;
    public final float TAB_SELECTOR_POSITION_Y = TAB_POSITION_Y;
    public final int TAB_SELECTOR_ROUNDING = 7;

    public final int TAB_SELECTOR_FILL = BLUE_SELECTED;
    public final boolean TAB_SELECTOR_STROKE = false;


/*-------------------------------------- HotBar ---------------------------------------------------*/
    public final int HOTBAR_SLOT_COUNT = 7;

    public final float HOTBAR_SLOT_WIDTH = 69;
    public final float HOTBAR_SLOT_HEIGHT = 69;

    public final float HOTBAR_CONTAINER_WIDTH = 567;
    public final float HOTBAR_CONTAINER_HEIGHT = 69;

    public final float HOTBAR_TOTAL_SLOT_WIDTH = HOTBAR_SLOT_WIDTH * HOTBAR_SLOT_COUNT;

    public final float HOTBAR_CONTAINER_POSITION_X = displayWidth / 2;
    public final float HOTBAR_CONTAINER_POSITION_Y;

    public final int HOTBAR_SLOT_ROUNDING = 10;

    public final int HOTBAR_SLOT_UNSELECTED_COLOR = GRAY_600;
    public final int HOTBAR_SLOT_UNSELECTED_STROKE = GRAY_400;

    public final int HOTBAR_SLOT_SELECTED_COLOR = BLUE_UNSELECTED;
    public final int HOTBAR_SLOT_SELECTED_STROKE = BLUE_SELECTED;

    public final float HOTBAR_STROKE_WEIGHT = 1.5f;

    public final int HOTBAR_TEXT_SIZE = 16;
    public final float HOTBAR_TEXT_PADDING_X = 6;
    public final float HOTBAR_TEXT_PADDING_Y = 6;
    public final PFont HOTBAR_TEXT_FONT = INTER_BOLD;

    public final int HOTBAR_LABEL_UNSELECTED_TEXT_COLOR = GRAY_50;
    public final int HOTBAR_LABEL_SELECTED_TEXT_COLOR = WHITE;

/*------------------------------------- Window ---------------------------------------------------*/

/*
======================================== Global Constants ==========================================
*/


    public final float GLOBAL_STROKE_WEIGHT = 1.5f;
    public final int GLOBAL_TEXT_ALIGN_FACTOR_Y;

/*
============================================= Text =================================================
*/  

/*
    //We can try switching to a different font for the tab text when its selected
    public final PFont TAB_UNSELECTED_LABEL_TEXT_FONT = FONT[2];
    public final int TAB_UNSELECTED_LABEL_TEXT_SIZE = 16;
    public final int TAB_UNSELECTED_LABEL_TEXT_COLOR = GRAY_50;

    public final PFont TAB_SELECTED_LABEL_TEXT_FONT = FONT[0];
    public final int TAB_SELECTED_LABEL_TEXT_SIZE = 16;
    public final int TAB_SELECTED_LABEL_TEXT_COLOR = WHITE;

    public final PFont TAB_BUTTON_UNSELECTED_LABEL_TEXT_FONT = FONT[2];
    public final int TAB_BUTTON_UNSELECTED_LABEL_TEXT_SIZE = 16;
    public final int TAB_BUTTON_UNSELECTED_LABEL_TEXT_COLOR = GRAY_50;

    public final PFont TAB_BUTTON_SELECTED_LABEL_TEXT_FONT = FONT[1];
    public final int TAB_BUTTON_SELECTED_LABEL_TEXT_SIZE = 16;
    public final int TAB_BUTTON_SELECTED_LABEL_TEXT_COLOR = WHITE;

    public final PFont HOTBAR_LABEL_UNSELECTED_TEXT_FONT = FONT[0];
    public final int HOTBAR_LABEL_UNSELECTED_TEXT_SIZE = 16;
    public final int HOTBAR_LABEL_UNSELECTED_TEXT_COLOR = GRAY_50;

    public final PFont HOTBAR_LABEL_SELECTED_TEXT_FONT = FONT[0];
    public final int HOTBAR_LABEL_SELECTED_TEXT_SIZE = 16;
    public final int HOTBAR_LABEL_SELECTED_TEXT_COLOR = WHITE;

    public final PFont WINDOW_TITLE_UNSELECTED_TEXT_FONT = FONT[0];
    public final int WINDOW_TITLE_UNSELECTED_TEXT_SIZE = 18;
    public final int WINDOW_TITLE_UNSELECTED_TEXT_COLOR = GRAY_50;

    public final PFont WINDOW_TITLE_SELECTED_TEXT_FONT = FONT[0];
    public final int WINDOW_TITLE_SELECTED_TEXT_SIZE = 18;
    public final int WINDOW_TITLE_SELECTED_TEXT_COLOR = WHITE;

    public final PFont ELEMENT_UNSELECTED_TEXT_FONT = FONT[2];
    public final int ELEMENT_UNSELECTED_TEXT_SIZE = 16;
    public final int ELEMENT_UNSELECTED_TEXT_COLOR = WHITE;

    public final PFont ELEMENT_SELECTED_TEXT_FONT = FONT[2];
    public final int ELEMENT_SELECTED_TEXT_SIZE = 16;
    public final int ELEMENT_SELECTED_TEXT_COLOR = WHITE;
*/


/*
======================================== Initialization ============================================
*/  

    public UI_Constants() {



    /*
    ======================================== Tab Initialization ====================================
    */
            if(System.getProperty("os.name").toLowerCase().contains("mac")) {
                GLOBAL_TEXT_ALIGN_FACTOR_Y = 1/6;
                HOTBAR_CONTAINER_POSITION_Y =  802;
            } else if(System.getProperty("os.name").toLowerCase().contains("windows")){
                GLOBAL_TEXT_ALIGN_FACTOR_Y = 1/8;
                HOTBAR_CONTAINER_POSITION_Y = 990;
            } else {
                GLOBAL_TEXT_ALIGN_FACTOR_Y = 1/8;
                HOTBAR_CONTAINER_POSITION_Y = 990;
            }

        
    /*
    ======================================== HotBar Initialization =============================
    */
    }


    public PShape createElementListener(PShape Element_Shape) {
        float[] Element_Params = Element_Shape.getParams();

        PShape Element_Listener = createShape();
        Element_Listener.beginShape();
            Element_Listener.vertex(Element_Params[0] - Element_Params[2] / 2, Element_Params[1] - Element_Params[3] / 2);
            Element_Listener.vertex(Element_Params[0] + Element_Params[2] / 2, Element_Params[1] - Element_Params[3] / 2);
            Element_Listener.vertex(Element_Params[0] + Element_Params[2] / 2, Element_Params[1] + Element_Params[3] / 2);
            Element_Listener.vertex(Element_Params[0] - Element_Params[2] / 2, Element_Params[1] + Element_Params[3] / 2);
        Element_Listener.endShape(CLOSE);
        Element_Listener.setFill(false);
        Element_Listener.setStroke(false);
        Element_Listener.setName("Toggle_Shape_Base_Listener");
        return Element_Listener;
    }
}
public class UI_CreationWindow extends UI_Window {

	private boolean isRecording = false;
	private boolean queueRecording = false;


	private boolean hasCompletedSave = false;

    private int currentPage = 1;



	public UI_CreationWindow() {
		super("Creations", 2, new PVector(338, 400), new PVector(338, 35), new PVector(338, 400 - 35), false);
        this.initializeCreationsWindow();
	}

	public void initializeCreationsWindow() {
        this.Window_Container.resetMatrix();
        float borderSizeX = 290;
        float borderSizeY = 240;
        float borderY = -this.Window_Form_Container_Size.y / 2 + 9 + borderSizeY / 2;

        PShape selectionBorder = createShape(RECT, 0, borderY, borderSizeX, borderSizeY, this.Window_Rounding);
            selectionBorder.setFill(false);
            selectionBorder.setStroke(UI_Constants.GRAY_300);
            selectionBorder.setStrokeWeight(UI_Constants.GLOBAL_STROKE_WEIGHT);
        this.Window_Container.addChild(selectionBorder);

        this.Window_Container.translate(this.Window_Position.x, this.Window_Position.y);
        this.Window_Container.scale(this.Window_Scale);
        this.updateFileSelection();
    }

    public void updateFileSelection() {

        //5 elements per page

        this.clearAllElements();

        String path = sketchPath() + "/data/LevelSaves/levels";
        File[] saveFiles = new File(path).listFiles();

        //Sorts files to be most recent modified ontop 
        Arrays.sort(saveFiles, Comparator.comparingLong(File::lastModified).reversed());

        int start = currentPage * 5;
        int end;

        if((currentPage + 1) * 5 > saveFiles.length) {
            end = saveFiles.length;
        } else {
            end = (currentPage + 1) * 5;
        }

        for(int i = start; i < end; i++) {
            this.addElement(new UI_FileButton(saveFiles[i].getName(), this, "FileGroup", false, saveFiles[i].getAbsolutePath()));
        }
    }   



    public void onFileSelected() {

    }

    public void onFileDeselected() {

    }




    @Override
    public void interactionDraw() {
        if(UI_Manager.getTabBar().getActiveTabID() == 2) {
            this.lockSelected();
        }
    }



    public void triggerLevelSnapshot() {
        this.queueRecording = true;
    }

	public void startLevelSnapshot() {
		//Would set the name to the current name in the textfield + snapshot
		if(this.queueRecording) {
            this.queueRecording = false;
            this.isRecording = true;
            beginRecord(SVG, sketchPath() + "/data/levelSaves/snapshots/snapshot1.svg");
		}
	}

	public void endLevelSnapshot() {
	   //Can add a check later to make sure that everything has saved correctly before doing this
	   if(this.isRecording) {
            endRecord();
			this.isRecording = false;
		}

	}



/*
=========================================== Level Loading & Saving =============================================
*/
	public void loadLevelState() {
		IS_PAUSED = true;
		JSONArray rigidbodyArray = loadJSONArray(sketchPath() + "data/levelSaves/test.json");
		ALL_FORCES_ARRAYLIST.clear();
		rigidbodyList.clear();

		for(int i = 0; i < rigidbodyArray.size()-1; i++) {
			JSONObject rigidbodyJSON = rigidbodyArray.getJSONObject(i);
			Rigidbody rigidbody = this.deserializeRigidbody(rigidbodyJSON);
			rigidbody.addForceToForceRegistry(new Gravity(rigidbody));
			rigidbodyList.add(rigidbody);

		}

		JSONArray forcesArray = rigidbodyArray.getJSONArray(rigidbodyArray.size() - 1);

		for(int i = 0; i < forcesArray.size(); i++) {
			Spring spring = null;
			Rod rod = null;
			Motor motor = null;
			Gravity gravity = null;

			JSONObject forceJSON = forcesArray.getJSONObject(i);

            System.out.println(forceJSON.getString("ForceType"));
			if(forceJSON.getString("ForceType").equals("Spring")){
				spring = this.deserializeSpring(forceJSON);
			} else if (forceJSON.getString("ForceType").equals("Rod")) {
				rod = this.deserializeRod(forceJSON);
			} else if (forceJSON.getString("ForceType").equals("Motor")) {
				motor = this.deserializeMotor(forceJSON);
			} else if(forceJSON.getString("ForceType").equals("Gravity")) {
				gravity = this.deserializeGravity(forceJSON);
			}

			if(spring != null) {
				if(spring.getIsTwoBodySpring()) {
					spring.getRigidbodyA().addForceToForceRegistry(spring);
					spring.getRigidbodyB().addForceToForceRegistry(spring);
					ALL_FORCES_ARRAYLIST.add(spring);
				} else {
					spring.getRigidbodyA().addForceToForceRegistry(spring);
					ALL_FORCES_ARRAYLIST.add(spring);
				}
			} else if(rod != null) {
				if(rod.getTwoBodyRod()) {
					rod.getRigidbodyA().addForceToForceRegistry(rod);
					rod.getRigidbodyB().addForceToForceRegistry(rod);

					if(rod.getIsJoint()) {
						rod.getRigidbodyA().addBodyToCollisionExclusionList(rod.getRigidbodyB());
						rod.getRigidbodyB().addBodyToCollisionExclusionList(rod.getRigidbodyA());
					}
					ALL_FORCES_ARRAYLIST.add(rod);
				} else {
					rod.getRigidbodyA().addForceToForceRegistry(rod);
					ALL_FORCES_ARRAYLIST.add(rod);
				}
			} else if(motor != null) {
				motor.getRigidbodyA().addForceToForceRegistry(motor);
				ALL_FORCES_ARRAYLIST.add(spring);

			} else if(gravity != null) {
				gravity.getRigidbodyA().addForceToForceRegistry(gravity);
				ALL_FORCES_ARRAYLIST.add(gravity);
			}
		}
		IS_PAUSED = false;
	}

	public void saveLevelState() {
		JSONArray rigidbodyArray = new JSONArray();

		for(Rigidbody body : rigidbodyList) {

			String ID = body.getID();

			/*---------------- Main Rigidbody JSON Object --------------*/
			JSONObject rigidbodyJSON = new JSONObject();
			/*----------------------------------------------------------*/

			JSONObject IDJSON = new JSONObject();
					IDJSON.setString("ID", ID);
				rigidbodyJSON.setJSONObject("RigidbodyID", IDJSON);

			JSONObject positionAndVelocityJSON = new JSONObject();
					positionAndVelocityJSON.setJSONObject("position", this.serialize2DPVector(body.getPosition()));
					positionAndVelocityJSON.setJSONObject("velocity", this.serialize2DPVector(body.getVelocity()));
				rigidbodyJSON.setJSONObject("positionAndVelocity", positionAndVelocityJSON);


			JSONObject angleAndAngularVelocityJSON = new JSONObject();
					angleAndAngularVelocityJSON.setFloat("angle", body.getAngle());
					angleAndAngularVelocityJSON.setFloat("angularVelocity", body.getAngularVelocity());
				rigidbodyJSON.setJSONObject("angleAndAngularVelocity", angleAndAngularVelocityJSON);

			JSONObject shapeTypeJSON = new JSONObject();
					shapeTypeJSON.setString("shapeType", body.getShapeType().name());
				rigidbodyJSON.setJSONObject("shapeType", shapeTypeJSON);

			JSONObject densityAndRestitutionJSON = new JSONObject();
					densityAndRestitutionJSON.setFloat("density", body.getDensity());
					densityAndRestitutionJSON.setFloat("restitution", body.getRestitution());
				rigidbodyJSON.setJSONObject("densityAndRestitution", densityAndRestitutionJSON);

			JSONObject geometryJSON = new JSONObject();
					JSONArray verticesArray = serializePVectorArray(body.getVertices());
					geometryJSON.setJSONArray("vertices", verticesArray);
					geometryJSON.setFloat("radius", body.getRadius());
					geometryJSON.setFloat("width", body.getWidth());
					geometryJSON.setFloat("height", body.getHeight());
				rigidbodyJSON.setJSONObject("geometry", geometryJSON);

		JSONObject frictionJSON = new JSONObject();
				frictionJSON.setFloat("coeffOfStaticFriction", body.getCoefficientOfStaticFriction());
				frictionJSON.setFloat("coeffOfKineticFriction", body.getCoefficientOfKineticFriction());
			rigidbodyJSON.setJSONObject("friction", frictionJSON);

		JSONObject staticityJSON = new JSONObject();
				staticityJSON.setBoolean("isStatic", body.getIsStatic());
				staticityJSON.setBoolean("isTranslationallyStatic", body.getIsTranslationallyStatic());
				staticityJSON.setBoolean("isRotationallyStatic", body.getIsRotationallyStatic());
			rigidbodyJSON.setJSONObject("staticity", staticityJSON);

		JSONObject drawingPropertiesJSON = new JSONObject();
				drawingPropertiesJSON.setFloat("strokeWeight", body.getStrokeWeight());
				drawingPropertiesJSON.setJSONObject("strokeColour", serialize3DPVector(body.getStrokeColour()));
				drawingPropertiesJSON.setJSONObject("fillColour", serialize3DPVector(body.getFillColour()));
			rigidbodyJSON.setJSONObject("drawingProperties", drawingPropertiesJSON);

		JSONObject visibilityAndCollidabilityJSON = new JSONObject();
				visibilityAndCollidabilityJSON.setBoolean("visibility", body.getIsVisible());
				visibilityAndCollidabilityJSON.setBoolean("collidability", body.getCollidability());
			rigidbodyJSON.setJSONObject("visibilityAndCollidability", visibilityAndCollidabilityJSON);


			rigidbodyArray.append(rigidbodyJSON);
		}

		rigidbodyArray.append(this.serializeForces());

		saveJSONArray(rigidbodyArray, sketchPath() + "data/levelSaves/test.json");
	}

	private JSONArray serializeForces() {
			JSONArray forcesArray = new JSONArray();

			for(int i = 0; i < ALL_FORCES_ARRAYLIST.size(); i++) {
				JSONObject forceJSON = new JSONObject();
				ForceRegistry force = ALL_FORCES_ARRAYLIST.get(i);

				if(force instanceof Spring) {
					forceJSON = serializeSpring((Spring)force);
				} else if(force instanceof Rod) {
					forceJSON = serializeRod((Rod)force);
				} else if(force instanceof Motor) {
					forceJSON = serializeMotor((Motor)force);
				} else if(force instanceof Gravity) {
					forceJSON = serializeGravity((Gravity)force);
				}
				forcesArray.append(forceJSON);
			}
			return forcesArray;
	}


	private Rigidbody deserializeRigidbody(JSONObject rigidbodyJSON) {
		Rigidbody rigidbody;
		ShapeType shapeType = this.deserializeShapeType(rigidbodyJSON.getJSONObject("shapeType"));

		if(shapeType == ShapeType.CIRCLE) {
			rigidbody = RigidbodyGenerator.CreateCircleBody(rigidbodyJSON.getJSONObject("geometry").getFloat("radius"),
															rigidbodyJSON.getJSONObject("densityAndRestitution").getFloat("density"),
															rigidbodyJSON.getJSONObject("densityAndRestitution").getFloat("restitution"),
															rigidbodyJSON.getJSONObject("staticity").getBoolean("isStatic"),
															rigidbodyJSON.getJSONObject("visibilityAndCollidability").getBoolean("collidability"),
															rigidbodyJSON.getJSONObject("drawingProperties").getFloat("strokeWeight"),
															this.deserialize3DPVector(rigidbodyJSON.getJSONObject("drawingProperties").getJSONObject("strokeColour")),
															this.deserialize3DPVector(rigidbodyJSON.getJSONObject("drawingProperties").getJSONObject("fillColour")));

		} else {
			rigidbody = RigidbodyGenerator.CreatePolygon(this.deserializePVectorArray(rigidbodyJSON.getJSONObject("geometry").getJSONArray("vertices")),
															rigidbodyJSON.getJSONObject("densityAndRestitution").getFloat("density"),
															rigidbodyJSON.getJSONObject("densityAndRestitution").getFloat("restitution"),
															rigidbodyJSON.getJSONObject("staticity").getBoolean("isStatic"),
															rigidbodyJSON.getJSONObject("staticity").getBoolean("isTranslationallyStatic"),
															rigidbodyJSON.getJSONObject("staticity").getBoolean("isRotationallyStatic"),
															rigidbodyJSON.getJSONObject("visibilityAndCollidability").getBoolean("collidability"),
															rigidbodyJSON.getJSONObject("drawingProperties").getFloat("strokeWeight"),
															this.deserialize3DPVector(rigidbodyJSON.getJSONObject("drawingProperties").getJSONObject("strokeColour")),
															this.deserialize3DPVector(rigidbodyJSON.getJSONObject("drawingProperties").getJSONObject("fillColour")));
		}

			rigidbody.setID(rigidbodyJSON.getJSONObject("RigidbodyID").getString("ID"));
			rigidbody.setIsStatic(rigidbodyJSON.getJSONObject("staticity").getBoolean("isStatic"));
			rigidbody.setIsTranslationallyStatic(rigidbodyJSON.getJSONObject("staticity").getBoolean("isTranslationallyStatic"));
			rigidbody.setIsRotationallyStatic(rigidbodyJSON.getJSONObject("staticity").getBoolean("isRotationallyStatic"));

			rigidbody.SetInitialPosition(this.deserialize2DPVector(rigidbodyJSON.getJSONObject("positionAndVelocity").getJSONObject("position")));
			rigidbody.setVelocity(this.deserialize2DPVector(rigidbodyJSON.getJSONObject("positionAndVelocity").getJSONObject("velocity")));
			rigidbody.setAngle(rigidbodyJSON.getJSONObject("angleAndAngularVelocity").getFloat("angle"));
			rigidbody.setAngularVelocity(rigidbodyJSON.getJSONObject("angleAndAngularVelocity").getFloat("angularVelocity"));


			return rigidbody;
	}

	private Spring deserializeSpring(JSONObject springJSON) {

		boolean isTwoBodySpring = springJSON.getBoolean("isTwoBodySpring");
		if(isTwoBodySpring) {
			Rigidbody rigidbodyA = this.getRigidbodyByID(springJSON.getString("rigidbodyAID"));
			Rigidbody rigidbodyB = this.getRigidbodyByID(springJSON.getString("rigidbodyBID"));


			PVector localAnchorA = this.deserialize2DPVector(springJSON.getJSONObject("localAnchorA"));
			PVector localAnchorB = this.deserialize2DPVector(springJSON.getJSONObject("localAnchorB"));

			Spring spring = new Spring(rigidbodyA, rigidbodyB, localAnchorA, localAnchorB);

			spring.setSpringConstant(springJSON.getFloat("springConstant"));
			spring.setEquilibriumLength(springJSON.getFloat("equilibriumLength"));
			spring.setDamping(springJSON.getFloat("damping"));
			spring.setDrawSpring(springJSON.getBoolean("drawSpring"));
			spring.setLockTranslationToXAxis(springJSON.getBoolean("lockTranslationToXAxis"));
			spring.setLockTranslationToYAxis(springJSON.getBoolean("lockTranslationToYAxis"));
			spring.setPerfectSpring(springJSON.getBoolean("isPerfectSpring"));
			spring.setSpringLength(springJSON.getFloat("springLength"));

			return spring;
		} else {
			Rigidbody rigidbodyA = this.getRigidbodyByID(springJSON.getString("rigidbodyAID"));
			PVector localAnchorA = this.deserialize2DPVector(springJSON.getJSONObject("localAnchorA"));
			PVector anchorPoint = this.deserialize2DPVector(springJSON.getJSONObject("anchorPoint"));

			Spring spring = new Spring(rigidbodyA, localAnchorA, anchorPoint);
			spring.setSpringConstant(springJSON.getFloat("springConstant"));
			spring.setEquilibriumLength(springJSON.getFloat("equilibriumLength"));
			spring.setDamping(springJSON.getFloat("damping"));
			spring.setDrawSpring(springJSON.getBoolean("drawSpring"));
			spring.setLockTranslationToXAxis(springJSON.getBoolean("lockTranslationToXAxis"));
			spring.setLockTranslationToYAxis(springJSON.getBoolean("lockTranslationToYAxis"));
			spring.setPerfectSpring(springJSON.getBoolean("isPerfectSpring"));
			spring.setSpringLength(springJSON.getFloat("springLength"));

			return spring;
		}
	}

	private Rod deserializeRod(JSONObject rodJSON) {
			boolean isTwoBodyRod = rodJSON.getBoolean("isTwoBodyRod");
			if(isTwoBodyRod) {
					Rigidbody rigidbodyA = this.getRigidbodyByID(rodJSON.getString("rigidbodyAID"));
					Rigidbody rigidbodyB = this.getRigidbodyByID(rodJSON.getString("rigidbodyBID"));

					PVector localAnchorA = this.deserialize2DPVector(rodJSON.getJSONObject("localAnchorA"));
					PVector localAnchorB = this.deserialize2DPVector(rodJSON.getJSONObject("localAnchorB"));

					Rod rod = new Rod(rigidbodyA, rigidbodyB, localAnchorA, localAnchorB);
					System.out.println(rodJSON.getFloat("length"));
					rod.setLength(rodJSON.getFloat("length"));
					rod.setDamping(rodJSON.getFloat("damping"));
					rod.setIsJoint(rodJSON.getBoolean("isJoint"));

					return rod;
			} else {
					Rigidbody rigidbodyA = this.getRigidbodyByID(rodJSON.getString("rigidbodyAID"));
					PVector localAnchorA = this.deserialize2DPVector(rodJSON.getJSONObject("localAnchorA"));
					PVector anchorPoint = this.deserialize2DPVector(rodJSON.getJSONObject("anchorPoint"));

					Rod rod = new Rod(rigidbodyA, localAnchorA, anchorPoint);
					rod.setLength(rodJSON.getFloat("length"));
					rod.setDamping(rodJSON.getFloat("damping"));
					rod.setIsJoint(rodJSON.getBoolean("isJoint"));
					return rod;
			}
	}

	private Motor deserializeMotor(JSONObject motorJSON) {
			Rigidbody rigidbody = this.getRigidbodyByID(motorJSON.getString("rigidbodyID"));

			Motor motor = new Motor(rigidbody, motorJSON.getFloat("targetAngularVelocity"));
			motor.setLocalAnchor(this.deserialize2DPVector(motorJSON.getJSONObject("localAnchor")));
			motor.setDrawMotor(motorJSON.getBoolean("drawMotor"));
			motor.setDrawMotorForce(motorJSON.getBoolean("drawMotorForce"));
			return motor;

		}

	private Gravity deserializeGravity(JSONObject gravityJSON) {
			Rigidbody rigidbody = this.getRigidbodyByID(gravityJSON.getString("rigidbodyID"));
			return new Gravity(rigidbody);
	}


	private JSONObject serializeSpring(Spring spring) {
			JSONObject springJSON = new JSONObject();

			springJSON.setString("rigidbodyAID", spring.getRigidbodyA().getID());

			if(spring.getIsTwoBodySpring()) {
					springJSON.setString("rigidbodyBID", spring.getRigidbodyB().getID());
			}

			springJSON.setString("ForceType", "Spring");
			springJSON.setFloat("springConstant", spring.getSpringConstant());
			springJSON.setFloat("equilibriumLength", spring.getEquilibriumLength());
			springJSON.setFloat("damping", spring.getDamping());

			springJSON.setJSONObject("localAnchorA", serialize2DPVector(spring.getLocalAnchorA()));
			springJSON.setJSONObject("localAnchorB", serialize2DPVector(spring.getLocalAnchorB()));
			springJSON.setJSONObject("anchorPoint", serialize2DPVector(spring.getAnchorPoint()));

			springJSON.setBoolean("drawSpring", spring.getDrawSpring());
			springJSON.setBoolean("lockTranslationToXAxis", spring.getLockTranslationToXAxis());
			springJSON.setBoolean("lockTranslationToYAxis", spring.getLockTranslationToYAxis());

			springJSON.setBoolean("isPerfectSpring", spring.getPerfectSpring());
			springJSON.setBoolean("isTwoBodySpring", spring.getIsTwoBodySpring());
			springJSON.setFloat("springLength", spring.getSpringLength());

			return springJSON;
	}

	private JSONObject serializeRod(Rod rod) {
			JSONObject rodJSON = new JSONObject();

			rodJSON.setString("rigidbodyAID", rod.getRigidbodyA().getID());
			if(rod.getTwoBodyRod()) {
					rodJSON.setString("rigidbodyBID", rod.getRigidbodyB().getID());
			}
			rodJSON.setString("ForceType", "Rod");
			rodJSON.setFloat("length", rod.getLength());
			rodJSON.setFloat("damping", rod.getDamping());

			rodJSON.setJSONObject("localAnchorA", serialize2DPVector(rod.getLocalAnchorA()));
			rodJSON.setJSONObject("localAnchorB", serialize2DPVector(rod.getLocalAnchorB()));
			rodJSON.setJSONObject("anchorPoint", serialize2DPVector(rod.getAnchorPoint()));

			rodJSON.setBoolean("isTwoBodyRod", rod.getTwoBodyRod());
			rodJSON.setBoolean("isJoint", rod.getIsJoint());

			return rodJSON;
	}

	private JSONObject serializeMotor(Motor motor) {
			JSONObject motorJSON = new JSONObject();

			motorJSON.setString("ForceType", "Motor");
			motorJSON.setString("rigidbodyID", motor.getRigidbodyA().getID());
			motorJSON.setJSONObject("localAnchor", serialize2DPVector(motor.getLocalAnchor()));
			motorJSON.setFloat("targetAngularVelocity", motor.getTargetAngularVelocity());
			motorJSON.setBoolean("drawMotorForce", motor.getDrawMotorForce());
			motorJSON.setBoolean("drawMotor", motor.getDrawMotor());
			
			return motorJSON;
	}

	private JSONObject serializeGravity(Gravity gravity) {
			JSONObject gravityJSON = new JSONObject();

			gravityJSON.setString("ForceType", "Gravity");
			gravityJSON.setString("rigidbodyID", gravity.getRigidbodyA().getID());
			return gravityJSON;
	}


	private ShapeType deserializeShapeType(JSONObject shapeTypeJSON) {
			return ShapeType.valueOf(shapeTypeJSON.getString("shapeType"));
	}

	private JSONObject serialize2DPVector(PVector vector) {
			JSONObject vectorJSON = new JSONObject();

			vectorJSON.setFloat("x", vector.x);
			vectorJSON.setFloat("y", vector.y);
			return vectorJSON;
	}

	private PVector deserialize2DPVector(JSONObject vectorJSON) {
			return new PVector(vectorJSON.getFloat("x"), vectorJSON.getFloat("y"));
	}

	private JSONObject serialize3DPVector(PVector vector) {
			JSONObject vectorJSON = new JSONObject();

			vectorJSON.setFloat("x", vector.x);
			vectorJSON.setFloat("y", vector.y);
			vectorJSON.setFloat("z", vector.z);
			return vectorJSON;
	}

	private PVector deserialize3DPVector(JSONObject vectorJSON) {
			return new PVector(vectorJSON.getFloat("x"), vectorJSON.getFloat("y"), vectorJSON.getFloat("z"));
	}


	private JSONArray serializePVectorArray(PVector[] vectors) {
			JSONArray vectorArray = new JSONArray();
			if(vectors == null || vectors.length == 0) {
				return vectorArray;
			}
			for(PVector vector : vectors) {
				vectorArray.append(this.serialize2DPVector(vector));
			}
			return vectorArray;
	}

	private PVector[] deserializePVectorArray(JSONArray vectorArrayJSON) {
			PVector[] vectorArray = new PVector[vectorArrayJSON.size()];

			for(int i = 0; i < vectorArrayJSON.size(); i++) {
				vectorArray[i] = this.deserialize2DPVector(vectorArrayJSON.getJSONObject(i));
			}
			return vectorArray;
	}


	private Rigidbody getRigidbodyByID(String id) {
			for(Rigidbody body : rigidbodyList) {
					if(body.getID().equals(id)) {
						return body;
					}
			}
		return null;
	}
/*
=================================================================================================
*/
    


    @Override
    public void onWindowSelect() {
        this.deselectAllWindows();
        this.isActiveWindow = true;
        this.Window_Visibility = true;
        UI_Manager.bringToFront(this);
        this.Window_Container.getChild("Window_Container_Stroke").setStroke(UI_Constants.BLUE_SELECTED);
        this.Window_Container.getChild("Window_Text_Container").setFill(UI_Constants.BLUE_UNSELECTED);
    }


    public void lockSelected() {
        this.isActiveWindow = true;
        this.Window_Visibility = true;
        UI_Manager.getHotBar().setActiveSlotID(-1);
        //this.updateFileSelection();
        this.Window_Container.getChild("Window_Container_Stroke").setStroke(UI_Constants.BLUE_SELECTED);
        this.Window_Container.getChild("Window_Text_Container").setFill(UI_Constants.BLUE_UNSELECTED);
    }

    public void open() {
        this.deselectAllWindows();
        this.isActiveWindow = true;
        this.Window_Visibility = true;
        UI_Manager.bringToFront(this);
        this.Window_Container.getChild("Window_Container_Stroke").setStroke(UI_Constants.BLUE_SELECTED);
        this.Window_Container.getChild("Window_Text_Container").setFill(UI_Constants.BLUE_UNSELECTED);
        this.initializeCreationsWindow();
    }







	@Override
	public void onKeyPress(int keyCode) {
		switch(keyCode) {
			case KeyEvent.VK_Z:
				this.saveLevelState();
			case KeyEvent.VK_X:
				this.loadLevelState();
		}

	}
}
public abstract class UI_Element {

    /*--------------------------------- Padding --------------------------------------------------*/

    /* Represents the padding of the element shape from the edge of the window */
    public int Element_Container_Padding_X = 10;

    /* Represents the padding of the topmost element shape from the top of the window */
    public int Element_Container_Top_Padding_Y = 19;

    /* Represents the padding of a shape from a previous shapes edge element */
    public int Element_Element_Padding_Y = 13;

    /* Represents the padding of the text from either the edge of a shape, or the edge of a subelement */
    public int Element_Text_Padding_X = 10;

    /* Represents the padding of a tickbox in a toggle from the edge of the shape */
    public int Element_Tickbox_Padding_X = 5;

    /*------------------------------- Dimensions -------------------------------------------------*/

    /* This is for regular toggles and sliders, there will be different dimensions for other elements */
    public int Element_Width = 265;
    public int Element_Height = 31;

    public int Element_Tickbox_Width = 23;
    public int Element_Tickbox_Height = 23;

    public int Element_Rounding = 3;

    /*------------------------------- Position ---------------------------------------------------*/
    /*
      Each window element will have the same x position as the window it lies in due to centering,
      so only the y position must be changed.
    */

    /*------------------------------- Text -------------------------------------------------------*/
    public String Element_Text = "Default Text";
    public String Element_Value_Text = "Default Value Text";

    public PFont Element_Font = UI_Constants.INTER_REGULAR;
    public int Element_Text_Size = 16;
    public int Element_Text_Color = UI_Constants.WHITE;

    /*------------------------------- Colour -----------------------------------------------------*/
    public int Element_Base_Unselected_Color = UI_Constants.GRAY_500;
    public int Element_Base_Unselected_Stroke_Color = UI_Constants.GRAY_400;

    public int Element_Base_Selected_Color = UI_Constants.GRAY_300;
    public int Element_Base_Selected_Stroke_Color = UI_Constants.GRAY_500;

    public float Element_Stroke_Weight = 1.5f;


    public abstract void createElementBaseShape();
    public abstract void createElementText();
    
    public abstract boolean onMousePress();
    public abstract void onMouseRelease();
    public abstract void onMouseDrag();

    public abstract void onSelect();
    public abstract void onDeselect();

    public abstract boolean getState();
    public abstract void setState(boolean state);
    public abstract float getValue();
    public abstract void setValue(float value);
    public abstract void incrementValue(float amount);
    public abstract void drawText();
    public abstract String getElementName();
    public abstract String getGroupName();
    public abstract PShape getShape();
}
public class UI_FileButton extends UI_Element {
    

    public UI_Window FileButton_ParentWindow;

    public String FileButton_Name;
    public float FileButton_Name_Position_X;
    public float FileButton_Name_Position_Y;

    public String FileButton_Group;
    public boolean FileButton_State;
    public String FilePath;

    public PShape FileButton_Shape_Group = createShape(GROUP);


    public UI_FileButton (String FileButton_Name, UI_Window FileButton_ParentWindow, String FileButton_Group, boolean FileButton_State, String FilePath) {
        this.FileButton_Name = FileButton_Name;
        this.FileButton_State = FileButton_State;
        this.FileButton_Group = FileButton_Group;
        this.FilePath = FilePath;


        this.FileButton_Shape_Group.setName(this.FileButton_Name + "Group");
        this.FileButton_ParentWindow = FileButton_ParentWindow;

        this.initializeFileButton();
    }

    public void initializeFileButton() {
        rectMode(CENTER);
        this.createElementBaseShape();
        this.createElementText();
    }




/*
======================================= Toggle Creation ============================================
*/  
    @Override
    public void createElementBaseShape() {

        this.Element_Height = 34;
        this.Element_Width = 272;

        rectMode(CENTER);
        int numElements = this.FileButton_ParentWindow.getWindowElementArrayListSize();

        float fileButtonShapeX;
        float fileButtonShapeY;
        float fileButtonShapeWidth;
        float fileButtonShapeHeight;

        if(numElements == 0) {
            fileButtonShapeX = 0;
            fileButtonShapeY = -this.FileButton_ParentWindow.getWindowFormContainerHeight() / 2 + this.Element_Container_Top_Padding_Y + this.Element_Height / 2;
            fileButtonShapeWidth = this.Element_Width;
            fileButtonShapeHeight = this.Element_Height;
            
        } else {
            fileButtonShapeX = 0;
            fileButtonShapeY = (this.Element_Height - this.FileButton_ParentWindow.getWindowFormContainerHeight()) /2 + (this.Element_Height + this.Element_Element_Padding_Y) * numElements + this.Element_Container_Top_Padding_Y;
            fileButtonShapeWidth = this.Element_Width;
            fileButtonShapeHeight = this.Element_Height;
        }

        PShape FileButton_Shape_Base = createShape(RECT, fileButtonShapeX, fileButtonShapeY, fileButtonShapeWidth, fileButtonShapeHeight, this.Element_Rounding);
            FileButton_Shape_Base.setName("FileButton_Shape_Base");
            FileButton_Shape_Base.setStrokeWeight(this.Element_Stroke_Weight);
            FileButton_Shape_Base.setFill(this.Element_Base_Unselected_Color);
            FileButton_Shape_Base.setStroke(this.Element_Base_Unselected_Stroke_Color);

        PShape FileButton_Shape_Base_Listener = UI_Constants.createElementListener(FileButton_Shape_Base);
            FileButton_Shape_Base_Listener.setName("FileButton_Shape_Base_Listener");

        this.FileButton_Shape_Group.addChild(FileButton_Shape_Base);
        this.FileButton_Shape_Group.addChild(FileButton_Shape_Base_Listener);
    }

    @Override 
    public void createElementText() {
        textFont(this.Element_Font);
        textSize(this.Element_Text_Size);
        textAlign(CENTER, CENTER);

        this.FileButton_Name_Position_X = this.FileButton_Shape_Group.getChild("FileButton_Shape_Base").getParam(0);
        this.FileButton_Name_Position_Y = this.FileButton_Shape_Group.getChild("FileButton_Shape_Base").getParam(1) - (textAscent() - textDescent()) * UI_Constants.GLOBAL_TEXT_ALIGN_FACTOR_Y;
    }

    

/*
======================================= Toggle Interaction =========================================
*/  
    @Override
    public boolean onMousePress() {
        float x = mouseX - this.FileButton_ParentWindow.getWindowPosition().x;
        float y = mouseY - this.FileButton_ParentWindow.getWindowPosition().y;

        return this.FileButton_Shape_Group.getChild("FileButton_Shape_Base_Listener").contains(x, y);
    }

    @Override 
    public void onMouseRelease() {

    }

    @Override
    public void onMouseDrag() {
        
    }
    

    @Override
    public void onSelect() {
        this.FileButton_State = true;
        this.FileButton_Shape_Group.getChild("FileButton_Shape_Base").setStroke(this.Element_Base_Selected_Stroke_Color);
        this.FileButton_Shape_Group.getChild("FileButton_Shape_Base").setFill(this.Element_Base_Selected_Color);
    }


    @Override
    public void onDeselect() {
        this.FileButton_State = false;
        this.FileButton_Shape_Group.getChild("FileButton_Shape_Base").setStroke(this.Element_Base_Unselected_Stroke_Color);
        this.FileButton_Shape_Group.getChild("FileButton_Shape_Base").setFill(this.Element_Base_Unselected_Color);
    }

/*
===================================== Toggle Draw ==================================================
*/

    @Override
    public void drawText() {
        fill(this.Element_Text_Color);
        textFont(this.Element_Font);
        textSize(this.Element_Text_Size);
        textAlign(CENTER, CENTER);

        text(this.FileButton_Name, this.FileButton_Name_Position_X, this.FileButton_Name_Position_Y);

    }


/*
======================================= Toggle Getters and Setters =================================
*/  
    @Override   
    public String getElementName() {
        return this.FileButton_Name;
    }

    @Override
    public PShape getShape() {
        return this.FileButton_Shape_Group;
    }

    @Override
    public boolean getState() {
        return this.FileButton_State;
    }
    @Override
    public String getGroupName() {
        return this.FileButton_Group;
    }

    @Override 
    public float getValue() {
        return 0;
    }

    @Override
    public void setValue(float value) {
        return;
    }

    @Override
    public void incrementValue(float amount) {

    }

    @Override
    public void setState(boolean state) {
        if(state) {
            this.onSelect();
        } else {
            this.onDeselect();
        }
    }

}   
public class UI_HotBar {


    private PShape HOT_SHAPE;
    private float[] TEXT_POSITION_X;
    private float[] TEXT_POSITION_Y;

    private float[] SLOT_POSITION;

    private float SCALE_FACTOR = width/1512f;

    private int activeSlotID;


    /*
    ======================================== Forces ================================================
    */

    public UI_HotBar() {
        this.initializeHotbar();
    }

    public void draw() {
        this.drawHotbar();
    }


/*
======================================== Initialization ============================================
*/
    public void initializeHotbar() {
        rectMode(CENTER);

        this.SLOT_POSITION = new float[UI_Constants.HOTBAR_SLOT_COUNT];
        this.TEXT_POSITION_X = new float[UI_Constants.HOTBAR_SLOT_COUNT];
        this.TEXT_POSITION_Y = new float[UI_Constants.HOTBAR_SLOT_COUNT];


        this.HOT_SHAPE = createShape(GROUP);
            this.HOT_SHAPE.setName("HOTBAR");
    

        float totalPadding = UI_Constants.HOTBAR_CONTAINER_WIDTH - UI_Constants.HOTBAR_TOTAL_SLOT_WIDTH;

        float padding = totalPadding / (UI_Constants.HOTBAR_SLOT_COUNT + 1);

        float startX = UI_Constants.HOTBAR_CONTAINER_POSITION_X - UI_Constants.HOTBAR_CONTAINER_WIDTH/ 2;

        for(int i = 0; i < UI_Constants.HOTBAR_SLOT_COUNT; i++) {
            float xPos = startX + i * (padding + UI_Constants.HOTBAR_SLOT_WIDTH) + UI_Constants.HOTBAR_SLOT_WIDTH / 2;
            float yPos = UI_Constants.HOTBAR_CONTAINER_POSITION_Y;

            SLOT_POSITION[i] = xPos;

            PShape SLOT_GROUP = createShape(GROUP);

            PShape SLOT = createShape(RECT, xPos, yPos, UI_Constants.HOTBAR_SLOT_WIDTH, 
                                                        UI_Constants.HOTBAR_SLOT_HEIGHT, 
                                                        UI_Constants.HOTBAR_SLOT_ROUNDING);

                if(i == this.activeSlotID) {
                    SLOT.setFill(UI_Constants.HOTBAR_SLOT_SELECTED_COLOR);
                    SLOT.setStroke(UI_Constants.HOTBAR_SLOT_SELECTED_STROKE);
                } else {
                    SLOT.setFill(UI_Constants.HOTBAR_SLOT_UNSELECTED_COLOR);
                    SLOT.setStroke(UI_Constants.HOTBAR_SLOT_UNSELECTED_STROKE);
                }

                SLOT.setStrokeWeight(UI_Constants.HOTBAR_STROKE_WEIGHT);

                PShape SLOT_ICON_SELECTED = loadShape(sketchPath() + "/data/icons/HotbarSlot" + (i + 1) + "Selected.svg");
                    SLOT_ICON_SELECTED.setName("SLOT_ICON_SELECTED");
                    SLOT_ICON_SELECTED.translate(xPos, yPos);

                PShape SLOT_ICON = loadShape(sketchPath() + "/data/icons/HotbarSlot" + (i + 1) + ".svg");
                    SLOT_ICON.setName("SLOT_ICON");
                    SLOT_ICON.translate(xPos, yPos);

                SLOT_GROUP.addChild(SLOT);
                SLOT_GROUP.addChild(SLOT_ICON);
                SLOT_GROUP.addChild(SLOT_ICON_SELECTED);

            this.HOT_SHAPE.addChild(SLOT_GROUP);
        }

        this.HOT_SHAPE.translate(UI_Constants.HOTBAR_CONTAINER_POSITION_X, UI_Constants.HOTBAR_CONTAINER_POSITION_Y);
        this.HOT_SHAPE.scale(SCALE_FACTOR); 
        this.HOT_SHAPE.translate(-UI_Constants.HOTBAR_CONTAINER_POSITION_X, -UI_Constants.HOTBAR_CONTAINER_POSITION_Y);
        this.initializeText();
    }


    public void initializeText() {
        textFont(UI_Constants.HOTBAR_TEXT_FONT);
        textSize(UI_Constants.HOTBAR_TEXT_SIZE);
        textAlign(CENTER, CENTER);

        for(int i = 0; i < UI_Constants.HOTBAR_SLOT_COUNT; i++) {
            float textEdgePadding = UI_Constants.HOTBAR_SLOT_WIDTH / 2 - textWidth(String.valueOf(i + 1)) / 2 - UI_Constants.HOTBAR_TEXT_PADDING_X;
            float textXPos = this.SLOT_POSITION[i] + textEdgePadding;
            float textYPos = UI_Constants.HOTBAR_CONTAINER_POSITION_Y + textEdgePadding - (textAscent() - textDescent()) * UI_Constants.GLOBAL_TEXT_ALIGN_FACTOR_Y;
            
            this.TEXT_POSITION_X[i] = textXPos;
            this.TEXT_POSITION_Y[i] = textYPos;
        }
    }




/*
====================================== Element Updates =============================================
*/

    public void onSlotChange(int slotID) {
        int previousSlotID = this.activeSlotID;

        if(previousSlotID != -1) {
            this.HOT_SHAPE.getChild(this.activeSlotID).getChild(0).setFill(UI_Constants.HOTBAR_SLOT_UNSELECTED_COLOR);
            this.HOT_SHAPE.getChild(this.activeSlotID).getChild(0).setStroke(UI_Constants.HOTBAR_SLOT_UNSELECTED_STROKE);
            this.HOT_SHAPE.getChild(this.activeSlotID).getChild(1).setVisible(true);
            this.HOT_SHAPE.getChild(this.activeSlotID).getChild(2).setVisible(false);
        }

        if(slotID == -1) {
            this.activeSlotID = -1;
            return;
        } 

        this.activeSlotID = slotID;
    
        this.HOT_SHAPE.getChild(slotID).getChild(0).setFill(UI_Constants.HOTBAR_SLOT_SELECTED_COLOR);
        this.HOT_SHAPE.getChild(slotID).getChild(0).setStroke(UI_Constants.HOTBAR_SLOT_SELECTED_STROKE);
        this.HOT_SHAPE.getChild(slotID).getChild(1).setVisible(false);
        this.HOT_SHAPE.getChild(slotID).getChild(2).setVisible(true);


    
        boolean resetMouseObject = 
                            ((previousSlotID == 4 || previousSlotID == 5 || previousSlotID == 6) && (this.activeSlotID != 4 && this.activeSlotID != 5 && this.activeSlotID != 6))
                            ||
                            ((previousSlotID == 2 || previousSlotID == 3) && (this.activeSlotID != 2 && this.activeSlotID != 3))
                            ;

        if(resetMouseObject) {
            Mouse.getMouseObjectResults().clear();
            UI_PropertiesForceWindow window = UI_Manager.getPropertiesForceWindow();
            if(window.MOUSE_SPRING_ADDED) {
                window.removeMouseSpring();
            }
        }
    

        UI_Window window;
        switch(this.activeSlotID) {
            case 0:
                UI_Manager.closeAllWindows();
                break;
            case 1:
                UI_Manager.closeAllWindows();
                break;
            case 2:
                if(previousSlotID == -1) {
                    UI_Manager.closeAllWindows();
                }

                window = UI_Manager.getPropertiesRigidbodyWindow();
                window.onSlotChange(previousSlotID);
                UI_Manager.bringToFront(window);
                //UI_Manager.repositionWindow(window);
                window.onWindowSelect();
                break;
            case 3:
                if(previousSlotID == -1) {
                    UI_Manager.closeAllWindows();
                }
                window = UI_Manager.getPropertiesRigidbodyWindow();
                window.onSlotChange(previousSlotID);
                UI_Manager.bringToFront(window);
                //UI_Manager.repositionWindow(window);
                window.onWindowSelect();
                break;
            case 4:
                if(previousSlotID == -1) {
                    UI_Manager.closeAllWindows();
                }
                window = UI_Manager.getPropertiesForceWindow();
    
                window.onSlotChange(previousSlotID);
                UI_Manager.bringToFront(window);
                //UI_Manager.repositionWindow(window);
                window.onWindowSelect();
                break;
            case 5:
                if(previousSlotID == -1) {
                    UI_Manager.closeAllWindows();
                }
                window = UI_Manager.getPropertiesForceWindow();
    
                window.onSlotChange(previousSlotID);
                UI_Manager.bringToFront(window);
                //UI_Manager.repositionWindow(window);
                window.onWindowSelect();
                break;
            case 6:
                if(previousSlotID == -1) {
                    UI_Manager.closeAllWindows();
                }
                window = UI_Manager.getPropertiesForceWindow();
                window.onSlotChange(previousSlotID);
                UI_Manager.bringToFront(window);
                //UI_Manager.repositionWindow(window);
                window.onWindowSelect();
                break;
        }
        
    
        if(previousSlotID == 1) {
            UI_Manager.getPropertiesEditorWindow().onWindowClose();
        }
    }

/*
=========================================== Drawing ================================================
*/

    public void drawHotbar() {
        shape(this.HOT_SHAPE);
        this.drawHotbarText();

    }

    public void drawHotbarText() {
        pushMatrix();
        translate(UI_Constants.HOTBAR_CONTAINER_POSITION_X, UI_Constants.HOTBAR_CONTAINER_POSITION_Y);
        scale(SCALE_FACTOR); 
        translate(-UI_Constants.HOTBAR_CONTAINER_POSITION_X, -UI_Constants.HOTBAR_CONTAINER_POSITION_Y);

        textFont(UI_Constants.HOTBAR_TEXT_FONT);
        textAlign(CENTER, CENTER);
        textSize(UI_Constants.HOTBAR_TEXT_SIZE);

        for(int i = 0; i < UI_Constants.HOTBAR_SLOT_COUNT; i++) {
            if(this.activeSlotID == i) {
                fill(UI_Constants.HOTBAR_LABEL_SELECTED_TEXT_COLOR);
            } else {
                fill(UI_Constants.HOTBAR_LABEL_UNSELECTED_TEXT_COLOR);
            }
            text(i + 1, this.TEXT_POSITION_X[i], this.TEXT_POSITION_Y[i]);
        }
        popMatrix();
    }

    


/*
====================================== Getters & Setters ===========================================
*/  
    
    public void setActiveSlotID(int slotID) {
        this.onSlotChange(slotID);
    }
    public PShape getHotbarShape() {
        return this.HOT_SHAPE;
    }

    public float[] getSlotPosition() {
        return this.SLOT_POSITION;
    }

    public float[] getTextPositionX() {
        return this.TEXT_POSITION_X;
    }

    public float[] getTextPositionY() {
        return this.TEXT_POSITION_Y;
    }

    public int getActiveSlotID() {
        return this.activeSlotID;
    }

}
public class UI_Manager {
    
    private UI_TabBar TAB_BAR;
    private UI_HotBar HOT_BAR;

    private UI_PropertiesRigidbodyWindow propertiesRigidbodyWindow;
    private UI_PropertiesForceWindow propertiesForceWindow;
    private UI_PropertiesEditorWindow propertiesEditorWindow;
    private UI_CreationWindow creationWindow;

    private ArrayList<UI_Window> WINDOWS;

    public boolean dragging = false;

    public boolean hasWindowBeenInteractedWith = false;
    public float timeWindowBeenInteractedWith;

    public boolean isMouseOverWindow = false;
    public boolean wasMousePressedOverWindow = false;

    public void init() {
        UI_Constants = new UI_Constants();
        this.TAB_BAR = new UI_TabBar();
        this.HOT_BAR = new UI_HotBar();
        this.WINDOWS = new ArrayList<UI_Window>();

        this.propertiesRigidbodyWindow = new UI_PropertiesRigidbodyWindow();
        this.propertiesForceWindow = new UI_PropertiesForceWindow();
        this.propertiesEditorWindow = new UI_PropertiesEditorWindow();
        this.creationWindow = new UI_CreationWindow();

        this.WINDOWS.add((UI_Window)this.propertiesRigidbodyWindow);
        this.WINDOWS.add((UI_Window)this.propertiesForceWindow);
        this.WINDOWS.add((UI_Window)this.propertiesEditorWindow);
        this.WINDOWS.add((UI_Window)this.creationWindow);

        for(UI_Window window : WINDOWS) {
            window.setWindowVisibility(false);
        }
    }



    public void onSceneDrawStart() {
        this.creationWindow.startLevelSnapshot();
    }

    public void draw() {
        if(hasWindowBeenInteractedWith) {
            if(millis() - timeWindowBeenInteractedWith > 100) {
                this.hasWindowBeenInteractedWith = false;
                this.timeWindowBeenInteractedWith = 0;
            }
        }   

        this.TAB_BAR.draw();
        this.HOT_BAR.draw();

        for(UI_Window window : this.WINDOWS) {
                window.draw();
        }

        for(UI_Window window : this.WINDOWS) {
            if(window.isMouseOverWindow) {
                this.isMouseOverWindow = true;
                return;
            } else {
                this.isMouseOverWindow = false;
            }

            if(window.wasMousePressedOverWindow) {
                this.wasMousePressedOverWindow = true;
                return;
            } else {
                this.wasMousePressedOverWindow = false;
            }
        }
    }

    public void interactionDraw() {
        for(UI_Window window : this.WINDOWS) {
            window.interactionDraw();
        }
    }


    public void onSceneDrawEnd() {
        this.creationWindow.endLevelSnapshot();
    }


/*
======================================= Mouse Interaction =======================================
*/
    public void onMousePress() {
        
        boolean windowVisibilityChange = false;
        boolean isVisibilityChangeActiveWindow = false;
        UI_Window activeWindow = this.getActiveWindow();

        for(int i = this.WINDOWS.size() - 1; i >= 0; i--) {
            this.WINDOWS.get(i).interactionMousePress();

            boolean isWindowVisibleBefore = this.WINDOWS.get(i).Window_Visibility;
            boolean isWindowVisibleAfter;

            if(this.WINDOWS.get(i).onMousePress()) {
                isWindowVisibleAfter = this.WINDOWS.get(i).Window_Visibility;

                if(activeWindow != null) {
                    if(isWindowVisibleBefore != isWindowVisibleAfter) {
                        if(this.WINDOWS.get(i) == activeWindow) {
                            isVisibilityChangeActiveWindow = true;
                        }
                    windowVisibilityChange = true;
                    }
                }
                
                this.timeWindowBeenInteractedWith = millis();
                this.hasWindowBeenInteractedWith = true;

                if(!windowVisibilityChange) {
                    return;
                }
            } 
        }

        if(windowVisibilityChange && !isVisibilityChangeActiveWindow && activeWindow != null) {
            activeWindow.onWindowSelectHotbarCaller();
        }
    }

    public void onMouseDrag() {
        for(int i = this.WINDOWS.size() - 1; i >= 0; i--) {

            this.WINDOWS.get(i).interactionMouseDrag();
            
            if(this.WINDOWS.get(i).onMouseDrag()) {
                this.timeWindowBeenInteractedWith = millis();
                this.hasWindowBeenInteractedWith = true;
                return;
            }
        }
    }

    public void onMouseRelease() {
        ArrayList<UI_Window> windowsCopy = new ArrayList<>(this.WINDOWS);
        for(UI_Window window : windowsCopy) {
            window.onMouseRelease();
            window.interactionMouseRelease();
        }
    }

    public void onMouseClick() {
        ArrayList<UI_Window> windowsCopy = new ArrayList<>(this.WINDOWS);
        for(UI_Window window : windowsCopy) {
            window.interactionMouseClick();
        }
    }
/*
================================================================================================
*/
    public void bringToFront(UI_Window window) {
        this.WINDOWS.add(this.WINDOWS.remove(this.WINDOWS.indexOf(window)));
    }



    public void onKeyPress(int keyCode) {
        UI_Window window = getActiveWindow();

        if(window != null) {
            window.onKeyPress(keyCode);
        }
    }
    

    public void repositionWindow(UI_Window window) {
        for(UI_Window win : UI_Manager.WINDOWS) {
            if(window == win) {
                continue;
            }

            if(win.getWindowPosition().x < displayWidth / 2) {
                window.setWindowPosition(new PVector(displayWidth * (3/4), displayHeight/3));
            } else {
                window.setWindowPosition(new PVector(displayWidth * (1/4), displayHeight/3));
            }
        }
    }


    public void closeAllWindows() {
        for(UI_Window window : this.WINDOWS) {
            window.onWindowClose();
        }
    }

/*
====================================== Getters and Setters =========================================
*/

    
    public UI_Window getActiveWindow() {
        for(UI_Window window : this.WINDOWS) {
            if(window.isActiveWindow) {
                return window;
            }
        }
        return null;
    }
    public UI_HotBar getHotBar() {
        return this.HOT_BAR;
    }
    public UI_TabBar getTabBar() {
        return this.TAB_BAR;
    }
    public UI_Window getWindow(int id) {
        return this.WINDOWS.get(id);
    }

    // public UI_Window getWindowByName(String name) {
    //     for(UI_Window window : this.WINDOWS) {
    //         if(window.getWindowName().equals(name)) {
    //             return window;
    //         }
    //     }
    //     throw new IllegalArgumentException("No window with name: " + name);
    // }


    public UI_PropertiesRigidbodyWindow getPropertiesRigidbodyWindow() {
        return this.propertiesRigidbodyWindow;
    }

    public UI_PropertiesForceWindow getPropertiesForceWindow() {
        return this.propertiesForceWindow;
    }

    public UI_PropertiesEditorWindow getPropertiesEditorWindow() {
        return this.propertiesEditorWindow;
    }

    public UI_CreationWindow getCreationWindow() {
        return this.creationWindow;
    }

    public ArrayList<UI_Window> getWindows() {
        return this.WINDOWS;
    }

    public boolean getIsOverWindows() {
        return this.isMouseOverWindow;
    }

    public boolean getIsOverOrPressedWindows() {
        return this.isMouseOverWindow || this.wasMousePressedOverWindow;
    }

    public boolean getIsPressedOverWindow() {
        return this.wasMousePressedOverWindow;
    }

    public int getActiveTabID() {
        return this.TAB_BAR.getActiveTabID();
    }
    public void setActiveTabID(int id) {
        this.TAB_BAR.setActiveTabID(id);
    }
}
public class UI_PropertiesEditorWindow extends UI_Window {


    private String OS = System.getProperty("os.name").toLowerCase();
    private boolean mac = false;

    private Rigidbody rigidbodyToEdit = null;

    private ArrayList<Rigidbody> selectedRigidbodies = new ArrayList<Rigidbody>();

    private ArrayList<Rigidbody> rigidbodiesToCopy = new ArrayList<Rigidbody>();


    private float mouseDownTime;
    private boolean inEditMode = false;

    private boolean inDragSelectMode = false;
    private boolean isSelectionBeingDragged = false;
    private AABB dragBox = null;
    private PVector initialDragPosition = new PVector();


    private boolean inCopySelectMode = false;
    private PVector initialCopyMousePosition = new PVector();

    private int vertexIndexToDrag = -1;
    private boolean circleVertexToDrag = false;





    private float prvDnsty;
    private float prvRsttn;
    private boolean prvStatic;
    private boolean prvFixRot;
    private boolean prvFixPos;
    private float prvAngle;



    public UI_PropertiesEditorWindow() {
        super("Properties Editor (rigidbody)", 2);
        if(OS.contains("mac")) {
            this.mac = true;
        }
        this.initialize();
    }

/*
========================================= UI Elements  =============================================
*/
    public void initialize() {
    }


    public void onEditorActive() {
        if(this.rigidbodyToEdit == null) {
            throw new IllegalArgumentException("Rigidbody to edit is null");
        }

        IS_PAUSED = true;
        IS_PAUSED_LOCK = true;

        this.clearAllElements();
        this.Window_Visibility = true;
        this.onWindowSelect();

        this.initializeEditor();
    }

    public void initializeEditor() {
        this.clearAllElements();
        this.addElement(new UI_Slider("Density", (UI_Window)this, MIN_BODY_DENSITY, MAX_BODY_DENSITY, this.rigidbodyToEdit.getDensity()));
        this.addElement(new UI_Slider("Restitution", (UI_Window)this, 0, 1, this.rigidbodyToEdit.getRestitution()));
        this.addElement(new UI_Toggle("Static", (UI_Window)this, "Staticity", this.rigidbodyToEdit.getIsStatic()));
        this.addElement(new UI_Toggle("Fixed Rotation", (UI_Window)this, "Staticity", this.rigidbodyToEdit.getIsRotationallyStatic()));
        this.addElement(new UI_Toggle("Fixed Position", (UI_Window)this, "Staticity", this.rigidbodyToEdit.getIsTranslationallyStatic()));
        this.addElement(new UI_Slider("Angle", (UI_Window)this, -360, 360, this.rigidbodyToEdit.getAngle()));


        this.prvDnsty = this.rigidbodyToEdit.getDensity();
        this.prvRsttn = this.rigidbodyToEdit.getRestitution();
        this.prvStatic = this.rigidbodyToEdit.getIsStatic();
        this.prvFixRot = this.rigidbodyToEdit.getIsRotationallyStatic();
        this.prvFixPos = this.rigidbodyToEdit.getIsTranslationallyStatic();
        this.prvAngle = this.rigidbodyToEdit.getAngle();
    }



/*
========================================= Drawing ========================================
*/ 
    @Override
    public void interactionDraw() {

        if(this.inEditMode) {
            this.elementChangeListener();
            this.selectLock();
        }

        if(UI_Manager.getIsOverOrPressedWindows()) {
            return;
        }

        if(UI_Manager.HOT_BAR.getActiveSlotID() != 1) {
            return;
        }

        if(this.inEditMode) {
            this.onWindowSelect();
            this.drawVertices();
            return;
        }

        if(this.inDragSelectMode) {
            this.drawDragSelect();
            return;
        }

        if(this.dragBox != null && this.dragBox.calculateArea() > 0.1f) {
            this.dragBox.drawAABB();
            return;
        }

        if(this.inCopySelectMode) {
            this.drawCopiedRigidbodies();
            this.updateCopiedRigidbodyPosition();
        }
    }


    public void drawVertices() {
        ShapeType shapeType = this.rigidbodyToEdit.getShapeType();

        if(shapeType == ShapeType.BOX || shapeType == ShapeType.POLYGON) {
            this.drawPolygonVertices();
        } else if(shapeType == ShapeType.CIRCLE) {
            this.drawCircleVertex();
        }
    }


    public void drawPolygonVertices() {
        PVector[] currentVertices = this.rigidbodyToEdit.GetTransformedVertices();
            for(PVector vertex : currentVertices) {
                pushMatrix();
                translate(vertex.x, vertex.y);
                fill(0, 255, 0);
                noStroke();
                ellipse(0, 0, 0.25f, 0.25f);
                popMatrix();
            }

    }

    public void drawCircleVertex() {
        PVector vertex = new PVector(this.rigidbodyToEdit.getRadius(), 0);
        vertex = PhysEngMath.Transform(vertex, this.rigidbodyToEdit.getAngle());
        PVector position = this.rigidbodyToEdit.getPosition();

        pushMatrix();
        translate(position.x, position.y);
        fill(0, 255, 0);
        noStroke();
        ellipse(vertex.x, vertex.y, 0.25f, 0.25f);
        popMatrix();
    }


    public void drawDragSelect() {
        PVector start = Mouse.getMouseDownCoordinates();
        PVector end = Mouse.getMouseCoordinates();
        rectMode(CORNERS);
        noFill();
        stroke(255);
        dash.rect(start.x, start.y, end.x, end.y);
    }

    public void drawCopiedRigidbodies() {
        if(this.inCopySelectMode) {
            for(Rigidbody rigidbody: this.rigidbodiesToCopy) {
                ShapeType shapeType = rigidbody.getShapeType();
                if(shapeType == ShapeType.BOX || shapeType == ShapeType.POLYGON) {
                    this.drawPolygon(rigidbody);
                } else if(shapeType == ShapeType.CIRCLE) {
                    this.drawCircle(rigidbody);
                }
            }
        }
    }


    public void drawPolygon(Rigidbody rigidbody) {
        PVector[] vertices = rigidbody.getVertices();
        fill(255, 255, 255, 166);
        stroke(0, 0, 0, 166);
        pushMatrix();
        translate(rigidbody.getPosition().x, rigidbody.getPosition().y);
        rotate(rigidbody.getAngle());
        beginShape();
        for(PVector vertex : vertices) {
            vertex(vertex.x, vertex.y);
        }
        endShape(CLOSE);
        popMatrix();
    }


    public void drawCircle(Rigidbody rigidbody) {
        fill(255, 255, 255, 166);
        stroke(0, 0, 0, 166);
        PVector position = rigidbody.getPosition();
        float radius = rigidbody.getRadius();

        pushMatrix();
        translate(position.x, position.y);
        ellipse(0, 0, radius * 2, radius * 2);
        popMatrix();
    }

/*
========================================= Vertex Methods ========================================
*/

    public int selectVertex(float radius) {
        PVector[] rigidbodyVertices = this.rigidbodyToEdit.GetTransformedVertices();

        for(int i = 0; i < rigidbodyVertices.length; i++) {
            if(PVector.sub(Camera.screenToWorld(), rigidbodyVertices[i]).magSq() < radius) {
                return i;
            }
        }
        return -1;
    }

    public boolean selectCircleVertex(float radius) {
        PVector vertex = PhysEngMath.Transform(new PVector(this.rigidbodyToEdit.getRadius(), 0), this.rigidbodyToEdit.getPosition(), this.rigidbodyToEdit.getAngle());
        if(PVector.sub(Camera.screenToWorld(), vertex).magSq() < radius) {
            return true;
        } else {
            return false;
        }
    }


    public boolean moveVertex() {
        ShapeType shapeType = rigidbodyToEdit.getShapeType();
        
        if(shapeType == ShapeType.BOX || shapeType == ShapeType.POLYGON) {
           return this.movePolygonVertex();
        } else if(shapeType == ShapeType.CIRCLE) {
            return this.moveCircleVertex();
        } else {
            throw new IllegalArgumentException("Unknown ShapeType");
        }
    }

    public boolean movePolygonVertex() {
        if(this.vertexIndexToDrag == -1) {
                return false;
        }

        PVector vertex = Camera.screenToWorld();
        PVector[] rigidbodyCoreVertices = this.rigidbodyToEdit.getVertices();

        PVector[] vertexList = Arrays.copyOf(rigidbodyCoreVertices, rigidbodyCoreVertices.length);

        vertexList[this.vertexIndexToDrag] = PhysEngMath.ReverseTransform(vertex, this.rigidbodyToEdit.getPosition().copy().mult(-1), -this.rigidbodyToEdit.getAngle());

        if(this.checkConvexity(vertexList)) {
            this.rigidbodyToEdit.updatePolygon(vertexList);
            return true;
        } else { 
            return true;
        }

    }

    public boolean moveCircleVertex() {
        if(!this.circleVertexToDrag){
            return false;
        }
        PVector newVertex = Camera.screenToWorld();

        PVector newRadiusVector = PVector.sub(this.rigidbodyToEdit.getPosition(), newVertex);

        this.rigidbodyToEdit.updateCircle(newRadiusVector.mag());
        return true;
    }



    public boolean addVertexOnClick() {

        if(!this.inEditMode) {
            return false;
        }

        ShapeType rigidbodyShapeType = this.rigidbodyToEdit.getShapeType();

        if(rigidbodyShapeType == ShapeType.CIRCLE) {
            return false;
        }

        PVector vertex = PhysEngMath.ReverseTransform(Camera.screenToWorld(), this.rigidbodyToEdit.getPosition().copy().mult(-1), -this.rigidbodyToEdit.getAngle());
        PVector[] rigidbodyVertices = this.rigidbodyToEdit.getVertices();
        PVector[] newRigidbodyVertices = new PVector[rigidbodyVertices.length + 1];

        for(int i = 0; i < rigidbodyVertices.length; i++) {
            newRigidbodyVertices[i] = rigidbodyVertices[i];
        }

        newRigidbodyVertices[newRigidbodyVertices.length - 1] = vertex;

        if(this.checkConvexity(PhysEngMath.OrderVerticesClockwise(newRigidbodyVertices))) {
            this.rigidbodyToEdit.updatePolygon(newRigidbodyVertices);
            return true;
        }
        return false;
    } 


    public void deleteVertex(int index) {
        ArrayList<PVector> vertexList = new ArrayList<PVector>(Arrays.asList(this.rigidbodyToEdit.getVertices()));
        vertexList.remove(index);
        this.rigidbodyToEdit.updatePolygon(vertexList.toArray(new PVector[vertexList.size()]));
    }



    public void dragSelect() {
        this.inDragSelectMode = false;
        this.dragBox = new AABB(Mouse.getMouseDownCoordinates(), Mouse.getMouseCoordinates(), true);
        if(this.dragBox.calculateArea() < 0.1f) {
            this.dragBox = null;
            IS_PAUSED = false;
            IS_PAUSED_LOCK = false;

            Rigidbody newRigidbody = Mouse.getRigidbodyUnderMouse();

            if(!this.inEditMode && newRigidbody!= null) {
                this.enterEditMode(newRigidbody);
                return;
            } 

            if(this.inEditMode && newRigidbody != this.rigidbodyToEdit && newRigidbody != null) {
                this.editModeSwitchRigidbody(newRigidbody);
                return;
            } 

            return;
        }

        for(Rigidbody rigidbody : rigidbodyList) {
            if(Collisions.IntersectAABB(dragBox,rigidbody.GetAABB())) {
                rigidbody.setStrokeColour(255, 0, 0);
                this.selectedRigidbodies.add(rigidbody);
            }
        }

        if(this.selectedRigidbodies.size() == 0) {
            this.dragBox = null;
            IS_PAUSED = false;
            IS_PAUSED_LOCK = false;
            return;
        } else {
            this.dragBox.recalculateMaxAndMin(this.selectedRigidbodies);
        }
    }




    public boolean dragMove() {
        if(Collisions.IntersectAABBWithPoint(this.dragBox, Camera.screenToWorld())) {
            if(!isSelectionBeingDragged) {
                this.initialDragPosition.set(Camera.screenToWorld());
                this.isSelectionBeingDragged = true;
            } else {
                PVector mouseDragDifference = PVector.sub(Camera.screenToWorld(), this.initialDragPosition);
                this.dragBox.shiftAABB(mouseDragDifference);
                for(Rigidbody rigidbody : this.selectedRigidbodies) {
                    rigidbody.addPosition(mouseDragDifference);
                }
                this.initialDragPosition.set(Camera.screenToWorld());
            }
            return true;
        } else {
            return false;
        }
    }


    public boolean checkConvexity(PVector[] Vertices) {
        if(Vertices.length < 4) {
            return true;
        }

        boolean isPositive = false;

        for(int i = 0; i < Vertices.length; i++) {
            PVector current = Vertices[i];
            PVector next = Vertices[(i + 1) % Vertices.length];
            PVector nextNext = Vertices[(i + 2) % Vertices.length];

            PVector edge1 = PVector.sub(next, current);
            PVector edge2 = PVector.sub(nextNext, next);

            float cross = edge1.cross(edge2).z;

            if(i == 0) {
                isPositive = cross > 0;
            } else if((cross > 0) != isPositive) {
                return false;
            }
        }

        return true;
    }



    public boolean selectShapeVertex() {
        if(this.inEditMode) {
            ShapeType shapeType = this.rigidbodyToEdit.getShapeType();
            if(shapeType == ShapeType.BOX || shapeType == ShapeType.POLYGON) {
                this.vertexIndexToDrag = this.selectVertex(VERTEX_SNAP_RADIUS);
                return true;
            } else if(shapeType == ShapeType.CIRCLE) {
                this.circleVertexToDrag = this.selectCircleVertex(VERTEX_SNAP_RADIUS);
                return true;
            }

            return false;
        }

        return false;
    }



    public void elementChangeListener() {
        for(UI_Element element : this.Window_Elements) {
            switch(element.getElementName()) {
                case "Density":
                    if(!PhysEngMath.Equals(this.prvDnsty, element.getValue())) {
                        this.rigidbodyToEdit.setDensity(element.getValue());
                    }
                    break;
                case "Restitution":
                    if(!PhysEngMath.Equals(this.prvRsttn, element.getValue())) {
                        this.rigidbodyToEdit.setRestitution(element.getValue());
                    }
                    break;
                case "Static":
                    if(this.prvStatic != element.getState()) {
                        this.rigidbodyToEdit.setIsStatic(element.getState());
                    }
                    break;
                case "Fixed Rotation":
                    if(this.prvFixRot != element.getState()) {
                        this.rigidbodyToEdit.setIsRotationallyStatic(element.getState());
                    }
                    break;
                case "Fixed Position":
                    if(this.prvFixPos != element.getState()) {
                        this.rigidbodyToEdit.setIsTranslationallyStatic(element.getState());
                    }
                    break;
                case "Angle":
                    if(!PhysEngMath.Equals(this.prvAngle, element.getValue())) {
                        this.rigidbodyToEdit.setAngle(radians(element.getValue()));
                    }
                    break;
            }
        }
    }

/*
========================================= Mouse Interaction =======================================
*/  

    @Override
    public void interactionMousePress() {
        this.mouseDownTime = millis();
        /*----------------- Checks ----------------*/
        if(UI_Manager.hasWindowBeenInteractedWith) {
            return;
        }
        if(UI_Manager.getIsOverOrPressedWindows()) {
            return;
        }
        if(UI_Manager.HOT_BAR.getActiveSlotID() != 1) {
            return;
        } 
        /*----------------------------------------*/

        if(this.selectShapeVertex()) {
            return;
        }

    }
    @Override
    public void interactionMouseRelease() {
        this.mouseDownTime = -1;
        /*----------------- Resets ----------------*/
        this.vertexIndexToDrag = -1;
        this.circleVertexToDrag = false;

        this.isSelectionBeingDragged = false;
        /*----------------------------------------*/

        //Drag select makes inDragSelectMode false
        if(this.inDragSelectMode) {
            this.dragSelect();
        }
    }


    @Override
    public void interactionMouseDrag() {
        /*----------------- Checks ----------------*/
        if(UI_Manager.hasWindowBeenInteractedWith) {
            return;
        }
        if(UI_Manager.getIsOverOrPressedWindows()) {
            return;
        }
        if(UI_Manager.HOT_BAR.getActiveSlotID() != 1) {
            return;
        }  
        /*----------------------------------------*/

        if(this.inEditMode) {
            if(!this.moveVertex()) {
                this.enterDragSelect();
            }
        } else if(!this.inEditMode && this.selectedRigidbodies.size() == 0) {
            this.enterDragSelect();

        } else if(!this.inEditMode && this.selectedRigidbodies.size() != 0) {
            if(!this.dragMove()) {
                this.enterDragSelect();
            }
        }     
    }

    @Override
    public void interactionMouseClick() {
        /*----------------- Checks ----------------*/
        if(UI_Manager.hasWindowBeenInteractedWith) {
            return;
        }
        if(UI_Manager.getIsOverOrPressedWindows()) {
            return;
        }
        if(UI_Manager.HOT_BAR.getActiveSlotID() != 1) {
            return;
        } 
        if(!this.mac) {
            if(millis() - this.mouseDownTime > 300) {
                return;
            }
        }
        /*----------------------------------------*/

        if(this.enterEditModeOnClick()) {
            return;
        }

        if(this.addVertexOnClick()) {
            return;
        }

        if(this.selectedRigidbodiesOnClick()) {
            return;
        }

        if(this.copiedRigidbodiesOnClick()) {
            return;
        }
    }




    public boolean enterEditModeOnClick() {
        Rigidbody newRigidbody = Mouse.getRigidbodyUnderMouse();

        if(!this.inEditMode && newRigidbody!= null) {
            this.enterEditMode(newRigidbody);
            return true;
        } 

        if(this.inEditMode && newRigidbody != this.rigidbodyToEdit && newRigidbody != null) {
            this.editModeSwitchRigidbody(newRigidbody);
            return true;
        } 

        return false;
    }


    public void enterEditMode(Rigidbody newRigidbody) {
        VERTEX_SNAP_RADIUS = 0.5f;
        this.rigidbodyToEdit = newRigidbody;
        this.inEditMode = true;
        this.inDragSelectMode = false;
        this.dragBox = null;
        this.vertexIndexToDrag = -1;
        this.clearSelectedRigidbodies();
        this.onEditorActive();
    }

    public void editModeSwitchRigidbody(Rigidbody newRigidbody) {
        this.rigidbodyToEdit = newRigidbody;
        this.clearSelectedRigidbodies();
        this.onEditorActive();
    }


    public boolean selectedRigidbodiesOnClick() {
        if(this.selectedRigidbodies.size() != 0 && !this.inCopySelectMode) {
            IS_PAUSED_LOCK = false;
            IS_PAUSED = false;
            this.clearSelectedRigidbodies();
            this.dragBox = null;
            return true;
        }
        return false;
    }



    public void updateCopiedRigidbodyPosition() {
        if(this.inCopySelectMode) {
            for(Rigidbody rigidbody : this.rigidbodiesToCopy) {
                rigidbody.addPosition(PVector.sub(Camera.screenToWorld(), this.initialCopyMousePosition));
            }
            this.initialCopyMousePosition.set(Camera.screenToWorld());
        }
    }

    public void updateCopiedPosRelToAABBCenterToMouse() {

        if(this.dragBox == null) {
            throw new RuntimeException("DragBox is null");
        }

        PVector AABBCenter = this.dragBox.calculateCenter();
        PVector difference = PVector.sub(Camera.screenToWorld(), AABBCenter);

        for(Rigidbody rigidbody : this.rigidbodiesToCopy) {
            rigidbody.addPosition(difference);
        }
    }

    public void selectedRigidbodiesOnCopy() {

        if(this.selectedRigidbodies.size() != 0 && this.dragBox != null) {
            for(Rigidbody rigidbody : this.selectedRigidbodies) {
                Rigidbody copiedRigidbody = new Rigidbody();
                copiedRigidbody.copy(rigidbody);
                this.rigidbodiesToCopy.add(copiedRigidbody);
            }

            this.updateCopiedPosRelToAABBCenterToMouse();

            this.inCopySelectMode = true;
            this.inDragSelectMode = false;
            this.inEditMode = false;
            this.vertexIndexToDrag = -1;
            this.clearSelectedRigidbodies();
            this.dragBox = null;
            this.initialCopyMousePosition.set(Camera.screenToWorld());
        }
    }

    public boolean copiedRigidbodiesOnClick() {
        if(this.inCopySelectMode) {
            this.inCopySelectMode = false;
            this.onWindowClose();
            return true;
        } 
        return false;
    }

    public void copiedRigidbodiesOnPaste() {
        ArrayList<Rigidbody> newCopyList = new ArrayList<Rigidbody>();

        for(Rigidbody rigidbody : this.rigidbodiesToCopy) {
            Rigidbody newRigidbody = new Rigidbody();
            newRigidbody.copy(rigidbody);
            newCopyList.add(newRigidbody);
            AddBodyToBodyEntityList(rigidbody);
        }

        this.clearCopiedRigidbodies();

        this.inCopySelectMode = true;
        this.rigidbodiesToCopy = newCopyList;
        this.initialCopyMousePosition.set(Camera.screenToWorld());
    }

    public void enterDragSelect() {
        this.inDragSelectMode = true;
        this.inEditMode = false;
        this.vertexIndexToDrag = -1;
        this.clearSelectedRigidbodies();
        this.dragBox = null;
        IS_PAUSED = true;
        IS_PAUSED_LOCK = true;
    }



    public void clearSelectedRigidbodies() {
        for(Rigidbody rigidbody : this.selectedRigidbodies) {
            rigidbody.setStrokeColour(0, 0, 0);
        }
        this.selectedRigidbodies.clear();
    }

    public void clearCopiedRigidbodies() {
        for(Rigidbody rigidbody : this.rigidbodiesToCopy) {
            rigidbody.setStrokeColour(0, 0, 0);
        }
        this.rigidbodiesToCopy.clear();
    }

/*
======================================== Window Interaction ========================================
*/

    @Override
    public void onWindowClose() {
        this.Window_Visibility = false;
        this.isMouseOverWindow = false;
        this.isMouseOverWindowTextContainer = false;
        this.isMouseOverWindowFormContainer = false;
        this.wasMousePressedOverWindow = false;
        this.isActiveWindow = false;

        this.dragBox = null;
        this.inEditMode = false;
        this.inDragSelectMode = false;
        this.vertexIndexToDrag = -1;
        this.circleVertexToDrag = false;

        this.rigidbodyToEdit = null;

        this.clearCopiedRigidbodies();
        this.clearSelectedRigidbodies();
        Mouse.getMouseObjectResults().clear();
        IS_PAUSED = false;
        IS_PAUSED_LOCK = false;
        VERTEX_SNAP_RADIUS = 0.25f;
    }

    public void onWindowCloseNoPause() {
        this.Window_Visibility = false;
        this.isMouseOverWindow = false;
        this.isMouseOverWindowTextContainer = false;
        this.isMouseOverWindowFormContainer = false;
        this.wasMousePressedOverWindow = false;
        this.isActiveWindow = false;

        this.dragBox = null;
        this.inEditMode = false;
        this.inDragSelectMode = false;
        this.vertexIndexToDrag = -1;
        this.circleVertexToDrag = false;

        this.rigidbodiesToCopy.clear();

        this.clearSelectedRigidbodies();
        VERTEX_SNAP_RADIUS = 0.25f;
        this.rigidbodyToEdit = null;
    }


    @Override
    public void onWindowSelect() {
        this.deselectAllWindows();
        this.isActiveWindow = true;
        UI_Manager.bringToFront(this);
        this.Window_Container.getChild("Window_Container_Stroke").setStroke(UI_Constants.BLUE_SELECTED);
        this.Window_Container.getChild("Window_Text_Container").setFill(UI_Constants.BLUE_UNSELECTED);
    }


    public void selectLock() {
        this.isActiveWindow = true;
        this.Window_Container.getChild("Window_Container_Stroke").setStroke(UI_Constants.BLUE_SELECTED);
        this.Window_Container.getChild("Window_Text_Container").setFill(UI_Constants.BLUE_UNSELECTED);
    }

    
/*
========================================= Key Press ========================================
*/



    @Override
    public void onKeyPress(int keyCode) {
        int activeSlotID = UI_Manager.HOT_BAR.getActiveSlotID();
        boolean shiftDown = KeyHandler.isKeyDown(KeyEvent.VK_SHIFT);

        switch(keyCode) {
            case KeyEvent.VK_DELETE:
                if(this.rigidbodyToEdit == null) {
                    break;
                }

                int index = this.selectVertex(VERTEX_SNAP_RADIUS);
                if(index != -1) {
                    this.deleteVertex(index);
                }
                break;
            case KeyEvent.VK_ENTER:
                this.onWindowClose();
                break;
            case KeyEvent.VK_C: 
                if(KeyHandler.isKeyDown(KeyEvent.VK_CONTROL)) {
                    this.selectedRigidbodiesOnCopy();
                }
                break;
            case KeyEvent.VK_V:
                if(KeyHandler.isKeyDown(KeyEvent.VK_CONTROL)) {
                    this.copiedRigidbodiesOnPaste();
                }
                break;
        }
    }

    /*
    ========================================= Getters & Setters ========================================
    */

    public boolean getInEditMode() {
        return this.inEditMode;
    }

    public ArrayList<Rigidbody> getSelectedRigidbodies() {
        return this.selectedRigidbodies;
    }
}

public class UI_PropertiesForceWindow extends UI_Window {



    private boolean hasInit = false;


    private boolean MOUSE_SPRING_ADDED;
    private Spring mouseSpring = new Spring();
/*
======================================= Element Values =============================================
*/  
    private float prvSprngConst = 100;
    private float prvEqlbrmLng = 1;
    private float prvDamping = 0.5f;
    private boolean prvLockYTrnsltn = false;
    private boolean prvLockXTrnsltn = false;
    private boolean prvPrfctSprng = false;

    private boolean prvJoint = false;

    private boolean prvDrawMotor = true;
    private float prvMotorSpeed = 0;

    public UI_PropertiesForceWindow() {
        super("Properties (forces)", 1);
        initialize();
    }

/*
======================================= UI ELEMENTS ================================================
*/

    public void initialize() {

    }

    @Override
    public void onSlotChange(int previousSlotID) {
        this.onWindowSelect();
        
        if(!hasInit) {
            switch(UI_Manager.HOT_BAR.getActiveSlotID()) {
                case 4:
                    this.onSpringActive();
                    this.hasInit = true;
                    break;
                case 5:
                    this.onRodActive();
                    this.hasInit = true;
                    break;
                case 6:
                    this.onMotorActive();
                    this.hasInit = true;
                    break;
            }

            this.Window_Visibility = true;

            return;
        }

        this.Window_Visibility = true;

        switch(UI_Manager.HOT_BAR.getActiveSlotID()) {
            case 4:
                this.onSpringActive();
                break;
            case 5:
                this.onRodActive();
                break;
            case 6:
                this.onMotorActive();
                break;
        }
    }

    public void onSpringActive() {
        this.savePrevElementStates();
        this.clearAllElements();
        this.HotBarSlotRepresentation = "Spring";
        this.addElement(new UI_Slider("Spring Constant", (UI_Window)this, 0, 300, prvSprngConst));
        this.addElement(new UI_Slider("Equilibrium Length", (UI_Window)this, 0, 10, prvEqlbrmLng));
        this.addElement(new UI_Slider("Damping", (UI_Window)this, 0, 1, prvDamping));
        this.addElement(new UI_Toggle("Lock Y Translation", (UI_Window)this, "Translation", prvLockYTrnsltn));
        this.addElement(new UI_Toggle("Lock X Translation", (UI_Window)this, "Translation", prvLockXTrnsltn));
        this.addElement(new UI_Toggle("Perfect Spring", (UI_Window)this, prvPrfctSprng));
    }

    public void onRodActive() {
        this.savePrevElementStates();
        this.clearAllElements();
        this.HotBarSlotRepresentation = "Rod";
        this.addElement(new UI_Toggle("Joint", (UI_Window)this, prvJoint));
    }

    public void onMotorActive() {
        this.savePrevElementStates();
        this.clearAllElements();
        this.HotBarSlotRepresentation = "Motor";
        this.addElement(new UI_Toggle("Draw Motor", (UI_Window)this, prvDrawMotor));
        this.addElement(new UI_Slider("Motor Speed", (UI_Window)this, -20, 20, prvMotorSpeed));
    }

    public void savePrevElementStates() {
        if(!this.hasInit) {
            return;
        }

        switch (this.HotBarSlotRepresentation) {
            case "Spring":
                this.prvSprngConst = this.getElementByName("Spring Constant").getValue();
                this.prvEqlbrmLng = this.getElementByName("Equilibrium Length").getValue();
                this.prvDamping = this.getElementByName("Damping").getValue();
                this.prvLockYTrnsltn = this.getElementByName("Lock Y Translation").getState();
                this.prvLockXTrnsltn = this.getElementByName("Lock X Translation").getState();
                this.prvPrfctSprng = this.getElementByName("Perfect Spring").getState();
                break;
            case "Rod":
                this.prvJoint = this.getElementByName("Joint").getState();
                break;
            case "Motor":
                this.prvDrawMotor = this.getElementByName("Draw Motor").getState();
                this.prvMotorSpeed = this.getElementByName("Motor Speed").getValue();
                break;
        }
    }
/*
========================================= Force Drawing ============================================
*/
    @Override
    public void interactionDraw() {
        if(UI_Manager.getIsOverOrPressedWindows()) {
            return;
        }
        this.drawForces();
    }







    public void drawForces() {

        /*---------------------------------- Checks --------------------------------------*/
        int activeSlotID = UI_Manager.HOT_BAR.getActiveSlotID();
        if(activeSlotID != 4 && activeSlotID != 5 && activeSlotID != 6) {
            return;
        }
        
        ArrayList<MouseObjectResult> mouseObjectResults = Mouse.getMouseObjectResults();
        if(mouseObjectResults.size() == 0 || mouseObjectResults.size() > 1) {
            return;
        } else if(mouseObjectResults.size() == 1 && UI_Manager.getIsPressedOverWindow()) {
            mouseObjectResults.clear();
            return;
        }
        /*--------------------------------------------------------------------------------*/


        PVector worldAnchorA;
        PVector worldAnchorB;
        Rigidbody rigidbodyToDrawFrom;


        
        rigidbodyToDrawFrom = mouseObjectResults.get(0).getSelectedRigidbody();
        
        if(rigidbodyToDrawFrom != null) {
            worldAnchorA = PhysEngMath.Transform(mouseObjectResults.get(0).getTransformedLocalCoordinate(), rigidbodyToDrawFrom.getPosition(), rigidbodyToDrawFrom.getAngle());
            worldAnchorB = Mouse.getMouseCoordinates();
        } else {
            worldAnchorA = mouseObjectResults.get(0).getWorldCoordinate();
            worldAnchorB = Mouse.getMouseCoordinates();
        }

        switch(activeSlotID) {
            case 4:
                this.drawSpring(worldAnchorA, worldAnchorB, rigidbodyToDrawFrom);
                break;
            case 5:
                this.drawRod(worldAnchorA, worldAnchorB, rigidbodyToDrawFrom);
                break;
            case 6:
                this.drawMotor(worldAnchorA, worldAnchorB, rigidbodyToDrawFrom);
                break;
        }
    }   


    public void drawSpring(PVector worldAnchorA, PVector worldAnchorB, Rigidbody rigidbodyToDrawFrom) {
        PVector direction = PVector.sub(worldAnchorA, worldAnchorB);
        float length = direction.mag();
        direction.normalize();
    
        float segments = 5;
        float segmentLength = length / segments;
        float offsetMagnitude = 0.5f; // Adjust this value to change the size of the zigzags
    
        // Draw the rod
        strokeWeight(0.3f);
        stroke(0, 0, 0, 166); // Black
        line(worldAnchorA.x, worldAnchorA.y, worldAnchorB.x, worldAnchorB.y);
        stroke(255, 255, 255, 166); // White
        strokeWeight(0.1f);
        line(worldAnchorA.x, worldAnchorA.y, worldAnchorB.x, worldAnchorB.y);
    
        for(int i = 0; i < segments; i++) {
            PVector segmentStart = PVector.add(worldAnchorB, PVector.mult(direction, segmentLength * i));
            PVector segmentEnd = PVector.add(worldAnchorB, PVector.mult(direction, segmentLength * (i + 1)));
    
            // Calculate the midpoint of the segment
            PVector midPoint = PVector.lerp(segmentStart, segmentEnd, 0.5f);
    
            // Alternate the offset direction to give appearance of spring
            PVector offset;
            if(i % 2 == 0) {
                offset = PVector.mult(new PVector(-direction.y, direction.x), offsetMagnitude);
            } else {
                offset = PVector.mult(new PVector(direction.y, -direction.x), offsetMagnitude);
            }
    
            // Add the offset to the midpoint
            PVector midPointOffset = PVector.add(midPoint, offset);
    
            // Draw the lines
            strokeWeight(0.2f);
            stroke(0, 0, 0, 166);
            line(segmentStart.x, segmentStart.y, midPointOffset.x, midPointOffset.y);
            line(midPointOffset.x, midPointOffset.y, segmentEnd.x, segmentEnd.y);
            strokeWeight(0.1f);
            stroke(255, 255, 255, 166);
            line(segmentStart.x, segmentStart.y, midPointOffset.x, midPointOffset.y);
            line(midPointOffset.x, midPointOffset.y, segmentEnd.x, segmentEnd.y);
        }
    }


    public void drawRod(PVector worldAnchorA, PVector worldAnchorB, Rigidbody rigidbodyToDrawFrom) {
        strokeWeight(0.15f);
        stroke(0, 0, 0, 166);
        line(worldAnchorA.x, worldAnchorA.y, worldAnchorB.x, worldAnchorB.y);
        strokeWeight(0.1f);
        stroke(255, 255, 255, 166);
        line(worldAnchorA.x, worldAnchorA.y, worldAnchorB.x, worldAnchorB.y);
    }



    public void drawMotor(PVector worldAnchorA, PVector worldAnchorB, Rigidbody rigidbodyToDrawFrom) {
        if(rigidbodyToDrawFrom == null) {
                return;
        }

        PVector position = rigidbodyToDrawFrom.getPosition();
        boolean isClockwise = this.getElementByName("Motor Speed").getValue() > 0;

        float size = rigidbodyToDrawFrom.getRadius() * 0.5f;
        float arrowSize = size * 0.15f;
        float startAngle = 0;
        float endAngle = 3 * PI/2;
            
        pushMatrix();
        translate(position.x, position.y);
        rotate(rigidbodyToDrawFrom.getAngle() + PI/6);

        noFill();
        strokeWeight(0.1f);
        stroke(255, 0, 0, 166);
        arc(0, 0, size, size, startAngle, endAngle);

        // Calculate the start and end of the arc
        float startX =  size * cos(startAngle)/2;
        float startY = size * sin(startAngle)/2;
        float endX = size * cos(endAngle)/2;
        float endY = size * sin(endAngle)/2;
            
        if(isClockwise) {
            strokeWeight(0.1f);
            stroke(255, 0, 0, 166);
            triangle(endX, endY-arrowSize, endX, endY+arrowSize, endX+arrowSize*2, endY);
        } else {
            strokeWeight(0.1f);
            stroke(255, 0, 0, 166);
            triangle(startX-arrowSize, startY, startX + arrowSize, startY, startX, startY - 2 * arrowSize);
        }
        popMatrix();

    }


/*
========================================= Force Creation ==============================================
*/  
    @Override
    public void interactionMousePress() {
        if(UI_Manager.hasWindowBeenInteractedWith) {
            return;
        }

        if(UI_Manager.getIsOverOrPressedWindows()){
            return;
        }

        this.addMouseSpring();
    }

    @Override
    public void interactionMouseDrag() {
        if(this.MOUSE_SPRING_ADDED) {
            PVector mouseCoordinates = Mouse.getMouseCoordinates();
            mouseSpring.setAnchorPoint(mouseCoordinates);
        }
    }
    @Override
    public void interactionMouseRelease() {
        if(UI_Manager.getIsOverOrPressedWindows()) {
            return;
        }

        if(UI_Manager.hasWindowBeenInteractedWith) {
            Mouse.getMouseObjectResults().clear();
            return;
        }

        if(this.MOUSE_SPRING_ADDED) {
            this.removeMouseSpring();
            Mouse.clearMouseObjectResults();
            return;
        } 

        this.createForces();
        return;
    }







    public void createForces() {
        /*---------------------------------- Checks --------------------------------------*/
        int activeSlotID = UI_Manager.HOT_BAR.getActiveSlotID();
        if(activeSlotID != 4 && activeSlotID != 5 && activeSlotID != 6 && !Mouse.getIsMouseDownLeft()) {
            return;
        }

        ArrayList<MouseObjectResult> mouseObjectResults = Mouse.getMouseObjectResults();
        if(mouseObjectResults.size() == 0 || mouseObjectResults.size() == 1){
            return;
        }
        /*--------------------------------------------------------------------------------*/

        PVector mouseCoordinates = Mouse.getMouseCoordinates();

        Rigidbody rigidbody1 = mouseObjectResults.get(0).getSelectedRigidbody();
        Rigidbody rigidbody2 = mouseObjectResults.get(1).getSelectedRigidbody();
        PVector anchor1 = mouseObjectResults.get(0).getTransformedLocalCoordinate();
        PVector anchor2 = mouseObjectResults.get(1).getTransformedLocalCoordinate();

        Rigidbody[] rigidbodyArray = new Rigidbody[0];
        PVector[] anchorArray = new PVector[0];

        if(rigidbody1 != null && rigidbody2 == null) {
            rigidbodyArray = new Rigidbody[]{rigidbody1};
            anchorArray = new PVector[]{anchor1, anchor2};
        } else if(rigidbody1 == null && rigidbody2 != null){
            rigidbodyArray = new Rigidbody[]{rigidbody2};
            anchorArray = new PVector[]{anchor2, anchor1};
        } else if(rigidbody1 != null && rigidbody2 != null) {
            rigidbodyArray = new Rigidbody[]{rigidbody1, rigidbody2};
            anchorArray = new PVector[]{anchor1, anchor2};
        } else if(rigidbody1 == null && rigidbody2 == null) {
            return;
        }

        mouseObjectResults.clear();

        switch(activeSlotID) {
            case 4:
                this.createSpring(rigidbodyArray, anchorArray);
                break;
            case 5:
                this.createRod(rigidbodyArray, anchorArray);
                break;
            case 6:
                this.createMotor(rigidbodyArray, anchorArray);
                break;
        }
    }

    public void createSpring(Rigidbody[] rigidbodyArray, PVector[] anchorArray) {
        Spring spring;

        if(rigidbodyArray.length == 1) {
            spring = new Spring(rigidbodyArray[0], anchorArray[0], anchorArray[1]);
            ALL_FORCES_ARRAYLIST.add(spring);
            rigidbodyArray[0].addForceToForceRegistry(spring);

        } else if(rigidbodyArray.length == 2) {
            spring = new Spring(rigidbodyArray[0], rigidbodyArray[1], anchorArray[0], anchorArray[1]);
            ALL_FORCES_ARRAYLIST.add(spring);
            rigidbodyArray[0].addForceToForceRegistry(spring);
            rigidbodyArray[1].addForceToForceRegistry(spring);
        } else {
            throw new IllegalArgumentException("RigidbodyArray is 0");
        }

        spring.setSpringConstant(this.getElementByName("Spring Constant").getValue());
        spring.setEquilibriumLength(this.getElementByName("Equilibrium Length").getValue());
        spring.setDamping(this.getElementByName("Damping").getValue());
        spring.setLockTranslationToXAxis(this.getElementByName("Lock Y Translation").getState());
        spring.setLockTranslationToYAxis(this.getElementByName("Lock X Translation").getState());
        spring.setPerfectSpring(this.getElementByName("Perfect Spring").getState());
    }


    public void createRod(Rigidbody[] rigidbodyArray, PVector[] anchorArray) {
        Rod rod;

        if(rigidbodyArray.length == 1) {
            rod = new Rod(rigidbodyArray[0], anchorArray[0], anchorArray[1]);
            ALL_FORCES_ARRAYLIST.add(rod);
            rigidbodyArray[0].addForceToForceRegistry(rod);
        } else if(rigidbodyArray.length == 2) {
            rod = new Rod(rigidbodyArray[0], rigidbodyArray[1], anchorArray[0], anchorArray[1]);
            ALL_FORCES_ARRAYLIST.add(rod);
            rigidbodyArray[0].addForceToForceRegistry(rod);
            rigidbodyArray[1].addForceToForceRegistry(rod);
        } else {
            throw new IllegalArgumentException("RigidbodyArray is 0");
        }
        rod.setIsJoint(this.getElementByName("Joint").getState());
    }


    public void createMotor(Rigidbody[] rigidbodyArray, PVector[] anchorArray) {
        Motor motor = new Motor(rigidbodyArray[0], this.getElementByName("Motor Speed").getValue());

            ///motor.setDrawMotor(this.TOGGLE_STATES[7]);
            motor.setDrawMotorForce(this.getElementByName("Draw Motor").getState());
            Iterator<ForceRegistry> iterator = rigidbodyArray[0].getForceRegistry().iterator();

            while (iterator.hasNext()) {
                ForceRegistry force = iterator.next();
                if (force instanceof Motor) {
                    iterator.remove();
                    ALL_FORCES_ARRAYLIST.remove(force);
                }
            }

            ALL_FORCES_ARRAYLIST.add(motor);
            rigidbodyArray[0].addForceToForceRegistry(motor);
    }

/*
========================================= Mouse Spring ==============================================
*/
    public void addMouseSpring() {
        if(KeyHandler.isKeyDown(KeyEvent.VK_SHIFT) && !this.MOUSE_SPRING_ADDED) {
            Rigidbody rigidbody = Mouse.getCurrentRigidbodyUnderMouse();

            if(rigidbody != null){
                PVector mouseCoordinates = Mouse.getMouseCoordinates();
                PVector localAnchorA = PhysEngMath.Transform(PhysEngMath.SnapController(Mouse, rigidbody, mouseCoordinates), -rigidbody.getAngle());

                mouseSpring.setRigidbodyA(rigidbody);
                mouseSpring.setLocalAnchorA(localAnchorA);
                mouseSpring.setAnchorPoint(mouseCoordinates);
                mouseSpring.setSpringConstant(200);
                mouseSpring.setDamping(0.8f); 
                mouseSpring.setEquilibriumLength(0.2f);  
                rigidbody.addForceToForceRegistry(mouseSpring);
                this.MOUSE_SPRING_ADDED = true;
                UI_Manager.getPropertiesRigidbodyWindow().setMouseSpringAdded(true);
                
            } 
        }
    }

    public void removeMouseSpring() {
        if(mouseSpring.getRigidbodyA() != null && this.MOUSE_SPRING_ADDED) {
            mouseSpring.getRigidbodyA().removeForceFromForceRegistry(mouseSpring);
            mouseSpring.setRigidbodyA(null);
            this.MOUSE_SPRING_ADDED = false;
            UI_Manager.getPropertiesRigidbodyWindow().setMouseSpringAdded(false);
        }
    }


/*
======================================= Key Interaction ========================================
*/
        
    /* Assumes input is a keyCode that has definitely been pressed */
    @Override
    public void onKeyPress(int keyCode) {
        int activeSlotID = UI_Manager.HOT_BAR.getActiveSlotID();
        boolean shiftDown = KeyHandler.isKeyDown(KeyEvent.VK_SHIFT);

        switch(keyCode) {
            case KeyEvent.VK_A:
                if(activeSlotID == 4) {
                    if(shiftDown) {
                        this.getElementByName("Spring Constant").incrementValue(-10f);
                    } else {
                        this.getElementByName("Spring Constant").incrementValue(-5f);
                    }
                } else if(activeSlotID == 6) {
                    if(shiftDown) {
                        this.getElementByName("Motor Speed").incrementValue(-2f);
                    } else {
                        this.getElementByName("Motor Speed").incrementValue(-1f);
                    }
                }
                break;
            case KeyEvent.VK_D:
                if(activeSlotID == 4) {
                    if(shiftDown) {
                        this.getElementByName("Spring Constant").incrementValue(10f);
                    } else {
                        this.getElementByName("Spring Constant").incrementValue(5f);
                    }
                } else if(activeSlotID == 6) {
                    if(shiftDown) {
                        this.getElementByName("Motor Speed").incrementValue(2f);
                    } else {
                        this.getElementByName("Motor Speed").incrementValue(1f);
                    }
                }
                break;
            case KeyEvent.VK_W:
                if(activeSlotID == 4) {
                    if(shiftDown) {
                        this.getElementByName("Equilibrium Length").incrementValue(1f);
                    } else {
                        this.getElementByName("Equilibrium Length").incrementValue(0.5f);
                    }
                }
                break;
            case KeyEvent.VK_S:
                if(activeSlotID == 4) {
                    if(shiftDown) {
                        this.getElementByName("Equilibrium Length").incrementValue(-1f);
                    } else {
                        this.getElementByName("Equilibrium Length").incrementValue(-0.5f);
                    }
                }
                break;
        }

    }


}
public class UI_PropertiesRigidbodyWindow extends UI_Window {

    private boolean wasMouseSpringAdded = false;
    private boolean hasInit = false;

    private float prvBdyDnsty = 1;
    private float prvBdyRsttn = 0.5f;
    private float prvBdyRds = 1;
    private float prvBdyWdth = 2;
    private float prvBdyHght = 2;
    private float prvBdyAngl = 0;

    private boolean prvSttc = false;
    private boolean prvFxRttn = false;
    private boolean prvFxPstn = false;



    public UI_PropertiesRigidbodyWindow() {
        super("Properties (rigidbody)", 0);
        this.initialize();
    }

/*
========================================= UI Elements  =============================================
*/
    public void initialize() {

    }

    @Override
    public void onSlotChange(int previousSlotID) { 
        this.onWindowSelect();

        if(!hasInit) {
            switch(UI_Manager.HOT_BAR.getActiveSlotID()) {
                case 2:
                    this.onCircleActive();
                    this.hasInit = true;
                    break;
                case 3:
                    this.onRectangleActive();
                    this.hasInit = true;
                    break;
            }
        }

            switch(UI_Manager.HOT_BAR.getActiveSlotID()) {
                case 2:
                    this.onCircleActive();
                    break;
                case 3:
                    this.onRectangleActive();
                    break;
            }
        this.Window_Visibility = true;
        
    }

    public void onCircleActive() {
        this.savePrevElementStates();
        this.clearAllElements();
        this.HotBarSlotRepresentation = "Circle";
        this.addElement(new UI_Slider("Density", (UI_Window)this, MIN_BODY_DENSITY, MAX_BODY_DENSITY, prvBdyDnsty));
        this.addElement(new UI_Slider("Restitution", (UI_Window)this, 0, 1, prvBdyRsttn));
        this.addElement(new UI_Slider("Radius", (UI_Window)this, MIN_BODY_RADIUS, MAX_BODY_RADIUS, prvBdyRds));
        this.addElement(new UI_Toggle("Static", (UI_Window)this, "Staticity", prvSttc));
        this.addElement(new UI_Toggle("Fixed Rotation", (UI_Window)this, "Staticity", prvFxRttn));
        this.addElement(new UI_Toggle("Fixed Position", (UI_Window)this, "Staticity", prvFxPstn));
        this.addElement(new UI_Slider("Angle", (UI_Window)this, -360, 360, prvBdyAngl));
    } 

    public void onRectangleActive() {
        this.savePrevElementStates();
        this.clearAllElements();
        this.HotBarSlotRepresentation = "Rectangle";
        this.addElement(new UI_Slider("Density", (UI_Window)this, MIN_BODY_DENSITY, MAX_BODY_DENSITY, prvBdyDnsty));
        this.addElement(new UI_Slider("Restitution", (UI_Window)this, 0, 1, prvBdyRsttn));
        this.addElement(new UI_Slider("Width", (UI_Window)this, MIN_BODY_WIDTH, MAX_BODY_WIDTH, prvBdyWdth));
        this.addElement(new UI_Slider("Height", (UI_Window)this, MIN_BODY_HEIGHT, MAX_BODY_HEIGHT, prvBdyHght));
        this.addElement(new UI_Toggle("Static", (UI_Window)this, "Staticity", prvSttc));
        this.addElement(new UI_Toggle("Fixed Rotation", (UI_Window)this, "Staticity", prvFxRttn));
        this.addElement(new UI_Toggle("Fixed Position", (UI_Window)this, "Staticity", prvFxPstn));
        this.addElement(new UI_Slider("Angle", (UI_Window)this, -360, 360, prvBdyAngl));
    }

    public void savePrevElementStates() {
        if(!this.hasInit) {
            return;
        }

        switch (this.HotBarSlotRepresentation) {
            case "Circle":
                this.prvBdyRds = this.getElementByName("Radius").getValue();
                this.prvBdyDnsty = this.getElementByName("Density").getValue();
                this.prvBdyRsttn = this.getElementByName("Restitution").getValue();
                this.prvSttc = this.getElementByName("Static").getState();
                this.prvFxRttn = this.getElementByName("Fixed Rotation").getState();
                this.prvFxPstn = this.getElementByName("Fixed Position").getState();
                this.prvBdyAngl = this.getElementByName("Angle").getValue();
                break;
            case "Rectangle":
                this.prvBdyWdth = this.getElementByName("Width").getValue();
                this.prvBdyHght = this.getElementByName("Height").getValue();
                this.prvBdyDnsty = this.getElementByName("Density").getValue();
                this.prvBdyRsttn = this.getElementByName("Restitution").getValue();
                this.prvSttc = this.getElementByName("Static").getState();
                this.prvFxRttn = this.getElementByName("Fixed Rotation").getState();
                this.prvFxPstn = this.getElementByName("Fixed Position").getState();
                this.prvBdyAngl = this.getElementByName("Angle").getValue();
                break;
        }
    }
/*
========================================= Rigidbody Drawing ========================================
*/ 
    @Override
    public void interactionDraw() {
        if(UI_Manager.getIsOverOrPressedWindows()) {
            return;
        }
        
        int activeSlotID = UI_Manager.HOT_BAR.getActiveSlotID();

        if(activeSlotID == 2 || activeSlotID == 3) {
            
            if(mouseButton == LEFT) {
                this.drawVelocityLine();
            }

            this.drawRigidbody(activeSlotID);
            return;
        }
    }





    public void drawRigidbody(int activeSlotID) {

        float angle = radians(this.getElementByName("Angle").getValue());
        PVector position = new PVector();
            if(Mouse.getIsMouseDownLeft() == true && !this.wasMouseSpringAdded) {
                position.set(PhysEngMath.MouseVelocityCalculationAndClamp(Mouse.getMouseDownCoordinates(), 
                                                                          Mouse.getMouseCoordinates(), 
                                                                          MIN_MOUSE_VELOCITY_MAG, 
                                                                          MAX_MOUSE_VELOCITY_MAG));
                position.add(Mouse.getMouseDownCoordinates());
            } else {
                position.set(Mouse.getMouseCoordinates());
            }


        if(activeSlotID == 2) {
            this.drawCircle(position, angle);
        } else if(activeSlotID == 3) {
            this.drawRectangle(position, angle);
        }
    }

    public void drawCircle(PVector position, float angle) {
        pushMatrix();
        translate(position.x, position.y);
        rotate(angle);
            float radius = this.getElementByName("Radius").getValue();
            float diameter = radius * 2.0f;

            fill(255, 255, 255, 166);
            stroke(0, 0, 0, 166);
            strokeWeight(0.1f);
            ellipseMode(CENTER);
            ellipse(0, 0, diameter,  diameter);

            PVector va = new PVector();
            PVector vb = new  PVector(radius, 0);
            va = PhysEngMath.Transform(va, new PVector(), angle);
            vb = PhysEngMath.Transform(vb, new PVector(), angle);

            line(va.x, va.y, vb.x, vb.y);
        popMatrix();
    }

    public void drawRectangle(PVector position, float angle) {
        pushMatrix();
        translate(position.x, position.y);
        rotate(angle);
            fill(255, 255, 255, 166);
            stroke(0, 0, 0, 166);
            strokeWeight(0.1f);
            rectMode(CENTER);
            rect(0, 0, this.getElementByName("Width").getValue(), this.getElementByName("Height").getValue());
        popMatrix();
    }


/*
========================================= Rigidbody Creation =======================================
*/
    @Override
    public void interactionMouseRelease() {
        if(UI_Manager.hasWindowBeenInteractedWith) {
            return;
        }

        if(UI_Manager.getIsOverOrPressedWindows()) {
            return;
        }


        int activeSlotID = UI_Manager.HOT_BAR.getActiveSlotID();
        if(activeSlotID == 2 || activeSlotID == 3) {
            if(!this.wasMouseSpringAdded) {
                this.createRigidbody(activeSlotID);
                return;
            }
        }
        this.wasMouseSpringAdded = false;
    }







    public void createRigidbody(int activeSlotID) {
        /*--------------------------------- Checks ---------------------------------*/
        if(Mouse.getRigidbodyUnderMouse() != null) {
            return;
        }
        /*---------------------------------------------------------------------------*/


        if(activeSlotID == 2) { 
            this.createCircle();
        } else if(activeSlotID == 3) {
            this.createRectangle();
        }


    }

    public void createCircle() {
        Rigidbody rigidbody = RigidbodyGenerator.CreateCircleBody(this.getElementByName("Radius").getValue(),
                                                                  this.getElementByName("Density").getValue(),
                                                                  this.getElementByName("Restitution").getValue(),
                                                                  this.getElementByName("Static").getState(),
                                                                  true,
                                                                  0.1f,
                                                                  new PVector(0, 0, 0),
                                                                  new PVector(255, 255, 255));

            if(!UI_Manager.getIsOverOrPressedWindows() && !this.wasMouseSpringAdded || !this.getElementByName("Fixed Position").getState()) {
                PVector velocity = PhysEngMath.MouseVelocityCalculationAndClamp(Mouse.getMouseDownCoordinates(), 
                                                                                Mouse.getMouseCoordinates(), 
                                                                                MIN_MOUSE_VELOCITY_MAG, 
                                                                                MAX_MOUSE_VELOCITY_MAG);
                rigidbody.SetInitialPosition(PVector.add(Mouse.getMouseDownCoordinates(), velocity));
                rigidbody.setVelocity(PhysEngMath.SquareVelocity(velocity).mult(-1));
            } else {
                rigidbody.SetInitialPosition(Mouse.getMouseCoordinates());
            }

            rigidbody.setIsTranslationallyStatic(this.getElementByName("Fixed Position").getState());
            rigidbody.setIsRotationallyStatic(this.getElementByName("Fixed Rotation").getState());
            rigidbody.setCollidability(true);
            rigidbody.RotateTo(radians(this.getElementByName("Angle").getValue()));
            rigidbody.addForceToForceRegistry(new Gravity(rigidbody));

            AddBodyToBodyEntityList(rigidbody);
            this.wasMouseSpringAdded = false;
            return;
    }


    public void createRectangle() {
        Rigidbody rigidbody = RigidbodyGenerator.CreateBoxBody(this.getElementByName("Width").getValue(),
                                                              this.getElementByName("Height").getValue(),
                                                              this.getElementByName("Density").getValue(),
                                                              this.getElementByName("Restitution").getValue(),
                                                              this.getElementByName("Static").getState(),
                                                              true,
                                                              0.1f,
                                                              new PVector(0, 0, 0),
                                                              new PVector(255, 255, 255));
        if(!UI_Manager.getIsOverOrPressedWindows() && !this.wasMouseSpringAdded && !this.getElementByName("Fixed Position").getState()){
            PVector velocity = PhysEngMath.MouseVelocityCalculationAndClamp(Mouse.getMouseDownCoordinates(), 
                                                                            Mouse.getMouseCoordinates(), 
                                                                            MIN_MOUSE_VELOCITY_MAG, 
                                                                            MAX_MOUSE_VELOCITY_MAG);
            rigidbody.SetInitialPosition(PVector.add(Mouse.getMouseDownCoordinates(), velocity));
            rigidbody.setVelocity(PhysEngMath.SquareVelocity(velocity).mult(-1));
        } else {
            rigidbody.SetInitialPosition(Mouse.getMouseCoordinates());
        }
        
        rigidbody.setIsTranslationallyStatic(this.getElementByName("Fixed Position").getState());
        rigidbody.setIsRotationallyStatic(this.getElementByName("Fixed Rotation").getState());
        rigidbody.setCollidability(true);
        rigidbody.RotateTo(radians(this.getElementByName("Angle").getValue()));
        rigidbody.addForceToForceRegistry(new Gravity(rigidbody));

        AddBodyToBodyEntityList(rigidbody);
        this.wasMouseSpringAdded = false;
        return;
    }


    
/*
========================================= Rigidbody Drawing ========================================
*/
    public void drawVelocityLine() {

        if(mouseButton != LEFT) {
            return;
        }

        if(this.wasMouseSpringAdded) {
            return;
        }

        PVector mouseDownCoordinates = Mouse.getMouseDownCoordinates();
        PVector clamped = PhysEngMath.MouseVelocityCalculationAndClamp(mouseDownCoordinates, Mouse.getMouseCoordinates(), 
                                                                        MIN_MOUSE_VELOCITY_MAG, MAX_MOUSE_VELOCITY_MAG);
        PVector endPoint = PVector.add(mouseDownCoordinates, clamped);

        if(PVector.sub(mouseDownCoordinates, endPoint).magSq() > 0.1f){
            stroke(lerpColor(color(0, 255, 0), color(255, 0, 0), sq(map(clamped.mag(), MIN_MOUSE_VELOCITY_MAG, MAX_MOUSE_VELOCITY_MAG, 0, 1))));
            line(mouseDownCoordinates.x, mouseDownCoordinates.y, endPoint.x, endPoint.y);
        }
    }



    @Override
    public void onKeyPress(int keyCode) {
        int activeSlotID = UI_Manager.HOT_BAR.getActiveSlotID();
        boolean shiftDown = KeyHandler.isKeyDown(KeyEvent.VK_SHIFT);

        switch(keyCode) {
            case KeyEvent.VK_A:
                if(activeSlotID == 2) {
                    if(shiftDown) {
                        this.getElementByName("Radius").incrementValue(-1f);
                    } else {
                        this.getElementByName("Radius").incrementValue(-0.25f);
                    }
                } else if(activeSlotID == 3) {
                    if(shiftDown) {
                        this.getElementByName("Width").incrementValue(-5f);
                    } else {
                        this.getElementByName("Width").incrementValue(-1f);
                    }
                }
                break;
            case KeyEvent.VK_D:
                if(activeSlotID == 2) {
                    if(shiftDown) {
                        this.getElementByName("Radius").incrementValue(1f);
                    } else {
                        this.getElementByName("Radius").incrementValue(0.25f);
                    }
                } else if(activeSlotID == 3) {
                    if(shiftDown) {
                        this.getElementByName("Width").incrementValue(5f);
                    } else {
                        this.getElementByName("Width").incrementValue(1f);
                    }
                }
                break;
            case KeyEvent.VK_W:
                if(activeSlotID == 2) {
                    if(shiftDown) {
                        this.getElementByName("Radius").incrementValue(1f);
                    } else {
                        this.getElementByName("Radius").incrementValue(0.25f);
                    }
                } else if(activeSlotID == 3) {
                    if(shiftDown) {
                        this.getElementByName("Height").incrementValue(5f);
                    } else {
                        this.getElementByName("Height").incrementValue(1f);
                    }
                }
                break;

            case KeyEvent.VK_S:
                if(activeSlotID == 2) {
                    if(shiftDown) {
                        this.getElementByName("Radius").incrementValue(-1f);
                    } else {
                        this.getElementByName("Radius").incrementValue(-0.25f);
                    }
                } else if(activeSlotID == 3) {
                    if(shiftDown) {
                        this.getElementByName("Height").incrementValue(-5f);
                    } else {
                        this.getElementByName("Height").incrementValue(-1f);
                    }
                }
                break;
        }

    }

    public void setMouseSpringAdded(boolean wasMouseSpringAdded) {
        this.wasMouseSpringAdded = wasMouseSpringAdded;
    }
}
public class UI_Slider extends UI_Element {

    public UI_Window Slider_ParentWindow;

    public String Slider_Name;
    public float Slider_Name_Position_X;
    public float Slider_Name_Position_Y;
    public float Slider_Value_Position_X;
    public float Slider_Value_Position_Y;

    public float Slider_Min_Value;
    public float Slider_Max_Value;
    public float Slider_Current_Value;

    public String Slider_GroupName = null;

    public boolean mouseOverSliderOnMouseDown = false;
    public PShape Slider_Shape_Group = createShape(GROUP);


    public UI_Slider(String Slider_Name, UI_Window Slider_ParentWindow, float Slider_Min_Value, float Slider_Max_Value, float Slider_Current_Value) {
        this.Slider_Name = Slider_Name;
        
        this.Slider_Shape_Group.setName(Slider_Name + "Group");
        this.Slider_ParentWindow = Slider_ParentWindow;

        this.Slider_Min_Value = Slider_Min_Value;
        this.Slider_Max_Value = Slider_Max_Value;
        this.Slider_Current_Value = Slider_Current_Value;

        this.initializeSlider();
    }


    public UI_Slider(String Slider_Name, UI_Window Slider_ParentWindow, String Slider_GroupName, float Slider_Min_Value, float Slider_Max_Value, float Slider_Current_Value) {
        
        this.Slider_Name = Slider_Name;
        this.Slider_ParentWindow = Slider_ParentWindow;
        this.Slider_GroupName = Slider_GroupName;

        this.Slider_Min_Value = Slider_Min_Value;
        this.Slider_Max_Value = Slider_Max_Value;
        this.Slider_Current_Value = Slider_Current_Value;

        this.initializeSlider();
    }


    public void initializeSlider() {
        rectMode(CENTER);
        this.createElementBaseShape();
        this.createElementText();
    }




/*
======================================= Slider Creation ============================================
*/  
    @Override
    public void createElementBaseShape() {
        rectMode(CENTER);
        int numElements = this.Slider_ParentWindow.getWindowElementArrayListSize();

        float sliderShapeX;
        float sliderShapeY;
        float sliderShapeWidth;
        float sliderShapeHeight;


        if(numElements == 0) {
            sliderShapeX = 0;
            sliderShapeY = -this.Slider_ParentWindow.getWindowFormContainerHeight() / 2 + this.Element_Container_Top_Padding_Y + this.Element_Height / 2;
            sliderShapeWidth = this.Element_Width;
            sliderShapeHeight = this.Element_Height;

        } else {
            sliderShapeX = 0;
            sliderShapeY = (this.Element_Height - this.Slider_ParentWindow.getWindowFormContainerHeight()) /2 + (this.Element_Height + this.Element_Element_Padding_Y) * numElements + this.Element_Container_Top_Padding_Y;
            sliderShapeWidth = this.Element_Width;
            sliderShapeHeight = this.Element_Height;
        }

        PShape Slider_Shape_Base = createShape(RECT, sliderShapeX, sliderShapeY, sliderShapeWidth, sliderShapeHeight, this.Element_Rounding);
            Slider_Shape_Base.setName("Slider_Shape_Base");
            Slider_Shape_Base.setStrokeWeight(this.Element_Stroke_Weight);
            Slider_Shape_Base.setFill(this.Element_Base_Unselected_Color);
            Slider_Shape_Base.setStroke(this.Element_Base_Unselected_Stroke_Color);

        PShape Slider_Shape_Base_Listener = UI_Constants.createElementListener(Slider_Shape_Base);
            Slider_Shape_Base_Listener.setName("Slider_Shape_Base_Listener");

        this.Slider_Shape_Group.addChild(Slider_Shape_Base);
        this.Slider_Shape_Group.addChild(Slider_Shape_Base_Listener);

        this.initializeSliderShape();
    }

    @Override 
    public void createElementText() {
        textFont(this.Element_Font);
        textSize(this.Element_Text_Size);
        textAlign(CENTER, CENTER);
        float[] sliderShapeParams = this.Slider_Shape_Group.getChild("Slider_Shape_Base").getParams();

        this.Slider_Name_Position_X = sliderShapeParams[0] - sliderShapeParams[2] / 2 + textWidth(this.Slider_Name) / 2 + 10;
        this.Slider_Name_Position_Y = sliderShapeParams[1] - (textAscent() - textDescent()) * UI_Constants.GLOBAL_TEXT_ALIGN_FACTOR_Y;

        this.Slider_Value_Position_X = sliderShapeParams[0] + sliderShapeParams[2] / 2 - textWidth(nf(this.Slider_Current_Value, 0, 2)) / 2 - 10;
        this.Slider_Value_Position_Y = sliderShapeParams[1] - (textAscent() - textDescent()) * UI_Constants.GLOBAL_TEXT_ALIGN_FACTOR_Y;



    }

    

/*
======================================= Slider Interaction =========================================
*/  
    @Override
    public boolean onMousePress() {
        float x = mouseX - this.Slider_ParentWindow.getWindowPosition().x;
        float y = mouseY - this.Slider_ParentWindow.getWindowPosition().y;
        return this.Slider_Shape_Group.getChild("Slider_Shape_Base_Listener").contains(x, y);
    }

    @Override
    public void onMouseDrag() {
        if(this.mouseOverSliderOnMouseDown) {
            float x = mouseX - this.Slider_ParentWindow.getWindowPosition().x;
            float[] baseShapeParams = this.Slider_Shape_Group.getChild("Slider_Shape_Base").getParams();
            this.Slider_Current_Value = map(x, baseShapeParams[0] - baseShapeParams[2] / 2, baseShapeParams[0] + baseShapeParams[2] / 2, this.Slider_Min_Value, this.Slider_Max_Value);
            this.Slider_Current_Value = constrain(this.Slider_Current_Value, this.Slider_Min_Value, this.Slider_Max_Value);
            this.updateSliderShape();
        }
    }

    @Override 
    public void onMouseRelease() {
        this.mouseOverSliderOnMouseDown = false;
    }
    

    @Override
    public void onSelect() {
        this.mouseOverSliderOnMouseDown = true;
    }

    @Override
    public void onDeselect() {
        this.mouseOverSliderOnMouseDown = false;
    }

/*
==================================== Slider Methods ================================================
*/
    public void initializeSliderShape() {
        rectMode(CORNER);
        float[] sliderShapeParams = this.Slider_Shape_Group.getChild("Slider_Shape_Base").getParams();
        float sliderShapeX = sliderShapeParams[0] - sliderShapeParams[2] / 2;
        float sliderShapeY = sliderShapeParams[1] - sliderShapeParams[3] / 2;
        float sliderShapeHeight = sliderShapeParams[3];

        float sliderShapeWidth = map(this.Slider_Current_Value, this.Slider_Min_Value, this.Slider_Max_Value, 0, sliderShapeParams[2]);

        PShape Slider_Shape = createShape(RECT, sliderShapeX, sliderShapeY, sliderShapeWidth, sliderShapeHeight, this.Element_Rounding);
            Slider_Shape.setName("Slider_Value_Shape");
            Slider_Shape.setStrokeWeight(this.Element_Stroke_Weight);
            Slider_Shape.setFill(this.Element_Base_Selected_Color);
            Slider_Shape.setStroke(this.Element_Base_Selected_Stroke_Color);
        
        this.Slider_Shape_Group.addChild(Slider_Shape);
    }

    public void updateSliderShape() {
        this.Slider_Shape_Group.removeChild(this.Slider_Shape_Group.getChildIndex(this.Slider_Shape_Group.getChild("Slider_Value_Shape")));

        rectMode(CORNER);
        float[] sliderShapeParams = this.Slider_Shape_Group.getChild("Slider_Shape_Base").getParams();
        float sliderShapeX = sliderShapeParams[0] - sliderShapeParams[2] / 2;
        float sliderShapeY = sliderShapeParams[1] - sliderShapeParams[3] / 2;
        float sliderShapeHeight = sliderShapeParams[3];

        float sliderShapeWidth = map(this.Slider_Current_Value, this.Slider_Min_Value, this.Slider_Max_Value, 0, sliderShapeParams[2]);

        PShape Slider_Shape = createShape(RECT, sliderShapeX, sliderShapeY, sliderShapeWidth, sliderShapeHeight, this.Element_Rounding);
            Slider_Shape.setName("Slider_Value_Shape");
            Slider_Shape.setStrokeWeight(this.Element_Stroke_Weight);
            Slider_Shape.setFill(this.Element_Base_Selected_Color);
            Slider_Shape.setStroke(this.Element_Base_Selected_Stroke_Color);
        
        this.Slider_Shape_Group.addChild(Slider_Shape);
    }

/*
===================================== Slider Draw ==================================================
*/

    @Override
    public void drawText() {
        fill(this.Element_Text_Color);
        textFont(this.Element_Font);
        textSize(this.Element_Text_Size);
        textAlign(CENTER, CENTER);
        text(this.Slider_Name, this.Slider_Name_Position_X, this.Slider_Name_Position_Y);
        text(nf(this.Slider_Current_Value, 0, 2), this.Slider_Value_Position_X, this.Slider_Value_Position_Y);

    }


/*
======================================= Toggle Getters and Setters =================================
*/  
    @Override   
    public String getElementName() {
        return this.Slider_Name;
    }
    @Override
    public String getGroupName() {
        return this.Slider_GroupName;
    }

    @Override
    public PShape getShape() {
        return this.Slider_Shape_Group;
    }

    @Override
    public float getValue() {
        return this.Slider_Current_Value;
    }

    @Override
    public boolean getState() {
        return false;
    }

    @Override
    public void setValue(float value) {
        this.Slider_Current_Value = constrain(value, this.Slider_Min_Value, this.Slider_Max_Value);
        this.updateSliderShape();
    }

    @Override
    public void incrementValue(float amount) {
        this.Slider_Current_Value = constrain(this.Slider_Current_Value + amount, this.Slider_Min_Value, this.Slider_Max_Value);
        this.updateSliderShape();
    }

    @Override
    public void setState(boolean state) {
        return;
    }

}   
public class UI_TabBar {


    private PShape TAB_SHAPE;
    private PShape[] TAB_SELECTOR;
    private float[] TEXT_POSITION;
    private float TEXT_POSITION_Y;
    private float BUTTON_TEXT_POSITION_Y;
    private float SCALE_FACTOR = width/1512f;
    private int activeTabID = 0;



    public UI_TabBar() {
        textFont(UI_Constants.TAB_TEXT_FONT);
        textAlign(CENTER, CENTER);
        textSize(UI_Constants.TAB_TEXT_SIZE);
        this.TEXT_POSITION_Y = UI_Constants.TAB_POSITION_Y - (textAscent() - textDescent()) * UI_Constants.GLOBAL_TEXT_ALIGN_FACTOR_Y;

        textFont(UI_Constants.TAB_BUTTON_TEXT_FONT);
        textAlign(CENTER, CENTER);
        textSize(UI_Constants.TAB_BUTTON_TEXT_SIZE);
        this.BUTTON_TEXT_POSITION_Y = UI_Constants.TAB_POSITION_Y - (textAscent() - textDescent()) * UI_Constants.GLOBAL_TEXT_ALIGN_FACTOR_Y;
        this.initializeTabBar();
    }

    public void draw() {
        this.drawTabGraphics();
    }


/*
=========================================== Initialization =========================================
*/
    public void initializeTabBar() {   

        rectMode(CENTER);

        this.TEXT_POSITION = new float[UI_Constants.TAB_NAME.length];
        this.TAB_SELECTOR = new PShape[UI_Constants.TAB_NAME.length];


        PShape TAB_SHAPE = createShape(RECT, UI_Constants.TAB_POSITION_X, 
                                             UI_Constants.TAB_POSITION_Y,
                                             UI_Constants.TAB_WIDTH, 
                                             UI_Constants.TAB_HEIGHT, 
                                             UI_Constants.TAB_ROUNDING);
            TAB_SHAPE.setName("TAB_SHAPE");
            TAB_SHAPE.setFill(UI_Constants.TAB_FILL);
            TAB_SHAPE.setStroke(UI_Constants.TAB_STROKE);
            TAB_SHAPE.setStrokeWeight(1.5f);


        PShape Q = createShape(RECT, UI_Constants.TAB_BUTTON_Q_POSITION_X,
                                     UI_Constants.TAB_POSITION_Y,
                                     UI_Constants.TAB_BUTTON_WIDTH,
                                     UI_Constants.TAB_BUTTON_HEIGHT,
                                     UI_Constants.TAB_BUTTON_ROUNDING);
            Q.setName("Q_Button");
            Q.setFill(UI_Constants.TAB_BUTTON_UNSELECTED_FILL);
            Q.setStroke(UI_Constants.TAB_BUTTON_UNSELECTED_STROKE);
            Q.setStrokeWeight(UI_Constants.TAB_BUTTON_STROKE_WEIGHT);


        PShape E = createShape(RECT, UI_Constants.TAB_BUTTON_E_POSITION_X,
                                     UI_Constants.TAB_POSITION_Y,
                                     UI_Constants.TAB_BUTTON_WIDTH,
                                     UI_Constants.TAB_BUTTON_HEIGHT,
                                     UI_Constants.TAB_BUTTON_ROUNDING);
            E.setName("E_Button");
            E.setFill(UI_Constants.TAB_BUTTON_UNSELECTED_FILL);
            E.setStroke(UI_Constants.TAB_BUTTON_UNSELECTED_STROKE);
            E.setStrokeWeight(UI_Constants.TAB_BUTTON_STROKE_WEIGHT);


        PShape TAB_SELECTOR_GROUP = createShape(GROUP);
            TAB_SELECTOR_GROUP.setName("TAB_SELECTOR_GROUP");



        this.TAB_SHAPE = createShape(GROUP);
            this.TAB_SHAPE.addChild(TAB_SHAPE);
            this.TAB_SHAPE.addChild(Q);
            this.TAB_SHAPE.addChild(E);
            this.TAB_SHAPE.addChild(TAB_SELECTOR_GROUP);

        this.TAB_SHAPE.translate(UI_Constants.TAB_POSITION_X, UI_Constants.TAB_POSITION_Y - UI_Constants.TAB_PADDING_Y);
        this.TAB_SHAPE.scale(SCALE_FACTOR);
        this.TAB_SHAPE.translate(-UI_Constants.TAB_POSITION_X, -UI_Constants.TAB_POSITION_Y + UI_Constants.TAB_PADDING_Y);
        this.initializeTextAndTabSelector();
    }


    public void initializeTextAndTabSelector() {
        textFont(UI_Constants.TAB_TEXT_FONT);
        textAlign(CENTER, CENTER);
        textSize(UI_Constants.TAB_TEXT_SIZE);

        float totalTextWidth = 0;
        for(String text: UI_Constants.TAB_NAME) {
            totalTextWidth += textWidth(text);
        
        }

        float padding = (UI_Constants.TAB_WIDTH - totalTextWidth) / (UI_Constants.TAB_NAME.length + 1);
        float x = padding + UI_Constants.TAB_POSITION_X - UI_Constants.TAB_WIDTH / 2;

        for(int i = 0; i < UI_Constants.TAB_NAME.length; i++) {
            String text = UI_Constants.TAB_NAME[i];

            float textPositionX = x + textWidth(text) / 2;
            float tabSelectorWidthPadding = padding;

            PShape TabSelectorShape = createShape(RECT, textPositionX, UI_Constants.TAB_POSITION_Y, 
                                                        textWidth(text) + tabSelectorWidthPadding, UI_Constants.TAB_SELECTOR_HEIGHT,
                                                        UI_Constants.TAB_SELECTOR_ROUNDING);

            TabSelectorShape.setFill(UI_Constants.TAB_SELECTOR_FILL);
            TabSelectorShape.setStroke(UI_Constants.TAB_SELECTOR_STROKE);


            this.TAB_SELECTOR[i] = TabSelectorShape;
            this.TEXT_POSITION[i] = (textPositionX);

            x += textWidth(text) + padding;
        }

        this.initializeTabSelector();
    }


    public void initializeTabSelector() {
        PShape TAB_SELECTOR_GROUP = this.TAB_SHAPE.getChild("TAB_SELECTOR_GROUP");
        TAB_SELECTOR_GROUP.addChild(this.TAB_SELECTOR[this.activeTabID]);
    }
/*
====================================== Element Updates =============================================
*/

    public void handleActiveTabIDChangesFromKeyPress(int newActiveTabID) {
        this.activeTabID = (newActiveTabID < 0) ? UI_Constants.TAB_NAME.length - 1 : (newActiveTabID >= UI_Constants.TAB_NAME.length) ? 0 : newActiveTabID;
        this.updateWindows();
        this.updateTabSelector();
    }
    public void onQPressed() {
        PShape Q_Shape = this.TAB_SHAPE.getChild("Q_Button");
        Q_Shape.setFill(UI_Constants.TAB_BUTTON_SELECTED_FILL);
        this.handleActiveTabIDChangesFromKeyPress(this.activeTabID - 1);
    }

    public void onQReleased() {
        PShape Q_Shape = this.TAB_SHAPE.getChild("Q_Button");
        Q_Shape.setFill(UI_Constants.TAB_BUTTON_UNSELECTED_FILL);
    }

    public void onEPressed() {
        PShape E_Shape = this.TAB_SHAPE.getChild("E_Button");
        E_Shape.setFill(UI_Constants.TAB_BUTTON_SELECTED_FILL);
        this.handleActiveTabIDChangesFromKeyPress(this.activeTabID + 1);
    }

    public void onEReleased() {
        PShape E_Shape = this.TAB_SHAPE.getChild("E_Button");
        E_Shape.setFill(UI_Constants.TAB_BUTTON_UNSELECTED_FILL);
    }

    
    public void updateTabSelector() {
        this.TAB_SHAPE.getChild("TAB_SELECTOR_GROUP").removeChild(0);
        this.TAB_SHAPE.getChild("TAB_SELECTOR_GROUP").addChild(this.TAB_SELECTOR[this.activeTabID]);
    }


    public void updateWindows() {
        switch(this.activeTabID) {
            case 0:
                UI_Manager.closeAllWindows();
                break;
            case 1:
                UI_Manager.closeAllWindows();
                UI_Manager.getHotBar().onSlotChange(UI_Manager.getHotBar().getActiveSlotID());
                break;
            case 2:
                UI_Manager.closeAllWindows();
                UI_Manager.getCreationWindow().open();
                break;
            case 3:
                UI_Manager.closeAllWindows();
                break;
        }

    }



/*
=========================================== Drawing ================================================
*/
    public void drawTabText() {
        pushMatrix();
        translate(UI_Constants.TAB_POSITION_X, UI_Constants.TAB_POSITION_Y - UI_Constants.TAB_PADDING_Y);
        scale(SCALE_FACTOR);
        translate(-UI_Constants.TAB_POSITION_X, -UI_Constants.TAB_POSITION_Y + UI_Constants.TAB_PADDING_Y);

        fill(UI_Constants.TAB_BUTTON_TEXT_COLOR);
        textFont(UI_Constants.TAB_BUTTON_TEXT_FONT);
        textAlign(CENTER, CENTER);
        textSize(UI_Constants.TAB_BUTTON_TEXT_SIZE);
        text("Q", UI_Constants.TAB_BUTTON_Q_POSITION_X, this.BUTTON_TEXT_POSITION_Y);
        text("E", UI_Constants.TAB_BUTTON_E_POSITION_X, this.BUTTON_TEXT_POSITION_Y);


        textFont(UI_Constants.TAB_TEXT_FONT);
        textAlign(CENTER, CENTER);
        textSize(UI_Constants.TAB_TEXT_SIZE);

        for(int i = 0; i < UI_Constants.TAB_NAME.length; i++) {
            if(i == this.activeTabID) {
                fill(UI_Constants.TAB_TEXT_SELECTED_COLOR);
            } else {
                fill(UI_Constants.TAB_TEXT_UNSELECTED_COLOR);
            }

            text(UI_Constants.TAB_NAME[i], this.TEXT_POSITION[i], this.TEXT_POSITION_Y);
        }
        popMatrix();
    }

    public void drawTabGraphics() {
        shape(this.TAB_SHAPE, 0, 0);
        this.drawTabText();
    }

/*
=========================================== Getters and Setters ====================================
*/
    public PShape getTabShape() {
        return this.TAB_SHAPE;
    }

    public int getActiveTabID() {
        return this.activeTabID;
    }

    public void setActiveTabID(int id) {
        this.activeTabID = id;
        updateTabSelector();
    }
}

public class UI_Toggle extends UI_Element {
    

    public UI_Window Toggle_ParentWindow;

    public String Toggle_Name;
    public float Toggle_Name_Position_X;
    public float Toggle_Name_Position_Y;

    public String Toggle_GroupName = null;
    public boolean Toggle_State;

    public PShape Toggle_Shape_Group = createShape(GROUP);


    public UI_Toggle(String Toggle_Name, UI_Window Toggle_ParentWindow, boolean Toggle_State) {
        this.Toggle_Name = Toggle_Name;
        this.Toggle_Shape_Group.setName(this.Toggle_Name + "Group");
        this.Toggle_ParentWindow = Toggle_ParentWindow;

        this.Toggle_State = Toggle_State;

        this.initializeToggle();
    }


    public UI_Toggle(String Toggle_Name, UI_Window Toggle_ParentWindow, String Toggle_GroupName, boolean Toggle_State) {

        this.Toggle_Shape_Group.setName(this.Toggle_Name + "Group");
        
        this.Toggle_Name = Toggle_Name;
        this.Toggle_ParentWindow = Toggle_ParentWindow;
        this.Toggle_GroupName = Toggle_GroupName;

        this.Toggle_State = Toggle_State;

        this.initializeToggle();
    }


    public void initializeToggle() {
        rectMode(CENTER);
        this.createElementBaseShape();
        this.createElementText();
    }




/*
======================================= Toggle Creation ============================================
*/  
    @Override
    public void createElementBaseShape() {
        rectMode(CENTER);
        int numElements = this.Toggle_ParentWindow.getWindowElementArrayListSize();

        float toggleShapeX;
        float toggleShapeY;
        float toggleShapeWidth;
        float toggleShapeHeight;

        float toggleTickboxX;
        float toggleTickboxY;
        float toggleTickboxWidth;
        float toggleTickboxHeight;

        if(numElements == 0) {
            toggleShapeX = 0;
            toggleShapeY = -this.Toggle_ParentWindow.getWindowFormContainerHeight() / 2 + this.Element_Container_Top_Padding_Y + this.Element_Height / 2;
            toggleShapeWidth = this.Element_Width;
            toggleShapeHeight = this.Element_Height;

            toggleTickboxX = toggleShapeX - toggleShapeWidth / 2 + this.Element_Tickbox_Padding_X + this.Element_Tickbox_Width / 2;
            toggleTickboxY = toggleShapeY;
            toggleTickboxWidth = this.Element_Tickbox_Width;
            toggleTickboxHeight = this.Element_Tickbox_Height;
            
        } else {
            toggleShapeX = 0;
            toggleShapeY = (this.Element_Height - this.Toggle_ParentWindow.getWindowFormContainerHeight()) /2 + (this.Element_Height + this.Element_Element_Padding_Y) * numElements + this.Element_Container_Top_Padding_Y;
            toggleShapeWidth = this.Element_Width;
            toggleShapeHeight = this.Element_Height;

            toggleTickboxX = toggleShapeX - toggleShapeWidth / 2 + this.Element_Tickbox_Padding_X + this.Element_Tickbox_Width / 2;
            toggleTickboxY = toggleShapeY;
            toggleTickboxWidth = this.Element_Tickbox_Width;
            toggleTickboxHeight = this.Element_Tickbox_Height;

        }

        PShape Toggle_Shape_Base = createShape(RECT, toggleShapeX, toggleShapeY, toggleShapeWidth, toggleShapeHeight, this.Element_Rounding);
            Toggle_Shape_Base.setName("Toggle_Shape_Base");
            Toggle_Shape_Base.setStrokeWeight(this.Element_Stroke_Weight);
            Toggle_Shape_Base.setFill(this.Element_Base_Unselected_Color);
            Toggle_Shape_Base.setStroke(this.Element_Base_Unselected_Stroke_Color);

        PShape Toggle_TickBox = createShape(RECT, toggleTickboxX, toggleTickboxY, toggleTickboxWidth, toggleTickboxHeight, this.Element_Rounding);
            Toggle_TickBox.setName("Toggle_Shape_TickBox");
            Toggle_TickBox.setStrokeWeight(this.Element_Stroke_Weight);
            Toggle_TickBox.setFill(UI_Constants.GRAY_600);
            Toggle_TickBox.setStroke(UI_Constants.GRAY_600);

        PShape Toggle_TickMark = createShape();
            Toggle_TickMark.beginShape();
                Toggle_TickMark.vertex(toggleTickboxX + 8, toggleTickboxY - 5);
                Toggle_TickMark.vertex(toggleTickboxX - 2, toggleTickboxY + 5);
                Toggle_TickMark.vertex(toggleTickboxX - 7, toggleTickboxY);
            Toggle_TickMark.endShape();

            Toggle_TickMark.setName("Toggle_Shape_TickMark");
            Toggle_TickMark.setFill(false);
            Toggle_TickMark.setStroke(UI_Constants.GRAY_150);

            Toggle_TickMark.setStrokeWeight(2);

        PShape Toggle_Shape_Base_Listener = UI_Constants.createElementListener(Toggle_Shape_Base);


        this.Toggle_Shape_Group.addChild(Toggle_Shape_Base);
        this.Toggle_Shape_Group.addChild(Toggle_TickBox);
        this.Toggle_Shape_Group.addChild(Toggle_Shape_Base_Listener);
        this.Toggle_Shape_Group.addChild(Toggle_TickMark);

        if(this.Toggle_State) {
            this.onSelect();
        } else {
            this.onDeselect();
        }

    }

    @Override 
    public void createElementText() {
        textFont(this.Element_Font);
        textSize(this.Element_Text_Size);
        textAlign(CENTER, CENTER);

        float[] TickboxParams = this.Toggle_Shape_Group.getChild("Toggle_Shape_TickBox").getParams();
        this.Toggle_Name_Position_X = TickboxParams[0] + TickboxParams[2] / 2 + 10 + textWidth(this.Toggle_Name) / 2 + 5;
        this.Toggle_Name_Position_Y = this.Toggle_Shape_Group.getChild("Toggle_Shape_Base").getParam(1) - (textAscent() - textDescent()) * UI_Constants.GLOBAL_TEXT_ALIGN_FACTOR_Y;
    }

    

/*
======================================= Toggle Interaction =========================================
*/  
    @Override
    public boolean onMousePress() {
        float x = mouseX - this.Toggle_ParentWindow.getWindowPosition().x;
        float y = mouseY - this.Toggle_ParentWindow.getWindowPosition().y;

        return this.Toggle_Shape_Group.getChild("Toggle_Shape_Base_Listener").contains(x, y);
    }

    @Override 
    public void onMouseRelease() {

    }

    @Override
    public void onMouseDrag() {
        
    }
    

    @Override
    public void onSelect() {
        this.Toggle_State = true;
        this.Toggle_Shape_Group.getChild("Toggle_Shape_Base").setStroke(this.Element_Base_Selected_Stroke_Color);
        this.Toggle_Shape_Group.getChild("Toggle_Shape_Base").setFill(this.Element_Base_Selected_Color);
        this.Toggle_Shape_Group.getChild("Toggle_Shape_TickMark").setVisible(true);
    }

    @Override
    public void onDeselect() {
        this.Toggle_State = false;
        this.Toggle_Shape_Group.getChild("Toggle_Shape_Base").setStroke(this.Element_Base_Unselected_Stroke_Color);
        this.Toggle_Shape_Group.getChild("Toggle_Shape_Base").setFill(this.Element_Base_Unselected_Color);
        this.Toggle_Shape_Group.getChild("Toggle_Shape_TickMark").setVisible(false);
    }

/*
===================================== Toggle Draw ==================================================
*/

    @Override
    public void drawText() {
        fill(this.Element_Text_Color);
        textFont(this.Element_Font);
        textSize(this.Element_Text_Size);
        textAlign(CENTER, CENTER);

        text(this.Toggle_Name, this.Toggle_Name_Position_X, this.Toggle_Name_Position_Y);

    }


/*
======================================= Toggle Getters and Setters =================================
*/  
    @Override   
    public String getElementName() {
        return this.Toggle_Name;
    }
    @Override
    public String getGroupName() {
        return this.Toggle_GroupName;
    }

    @Override
    public PShape getShape() {
        return this.Toggle_Shape_Group;
    }

    @Override 
    public float getValue() {
        return 0;
    }

    @Override
    public void setValue(float value) {
        return;
    }

    @Override
    public void incrementValue(float amount) {

    }

    @Override
    public boolean getState() {
        return this.Toggle_State;
    }

    @Override
    public void setState(boolean state) {
        if(state) {
            this.onSelect();
        } else {
            this.onDeselect();
        }
    }

}   
public class UI_Window {
    
    public final String Window_Name;
    public String HotBarSlotRepresentation;
    public PVector Window_Position = new PVector(500, 400);
    public final int Window_ID;

    public boolean Window_Visibility = true;
    public float Window_Scale = displayWidth / 1512;

    public PShape Window_Container;

    /*
    Visuals
    */
    public final PVector Window_Container_Size = new PVector(285, 407);
    public final PVector Window_Text_Container_Size = new PVector(285, 35);
    public final PVector Window_Form_Container_Size = new PVector(285, 407-35);
    public final PVector Window_Text_Position = new PVector();
    public float Window_Text_Width;
    public final int Window_Text_Size = 18;
    public final float Window_Rounding = 7;

    public boolean hasCloseButton = true;

    /*
    Elements
    */
    public ArrayList<UI_Element> Window_Elements = new ArrayList<UI_Element>();



    /*
    Interaction
    */
    public PVector initialMouseDragPosition = new PVector();
    

    public boolean isActiveWindow = false;
    public boolean isMouseOverWindow = false;
    public boolean isMouseOverWindowTextContainer = false;
    public boolean isMouseOverWindowFormContainer = false;

    public boolean isDragging = false;
    public boolean wasMousePressedOverWindow = false;
    /*
    For Testing
    */
    public UI_Window(String Window_Name, int Window_ID) {
        this.Window_Name = Window_Name;
        this.Window_ID = Window_ID;
        this.initializeWindow();
    }

    public UI_Window(String Window_Name, int Window_ID, PVector Window_Container_Size, PVector Window_Text_Container_Size, PVector Window_Form_Container_Size, boolean hasCloseButton) {
        this.Window_Name = Window_Name;
        this.Window_ID = Window_ID;
        this.Window_Container_Size.set(Window_Container_Size);
        this.Window_Text_Container_Size.set(Window_Text_Container_Size);
        this.Window_Form_Container_Size.set(Window_Form_Container_Size);
        this.hasCloseButton = hasCloseButton;
        this.initializeWindow();
    }


/*
============================================= Initialization =======================================
*/
    public void initializeWindow() {
        textFont(UI_Constants.INTER_BOLD);
        textSize(this.Window_Text_Size);
        textAlign(CENTER, CENTER);

        rectMode(CENTER);
        this.Window_Container = createShape(GROUP);

        PShape Element_Group = createShape(GROUP);
            Element_Group.setName("Element_Group");

        PShape Window_Text_Container = createShape(RECT, 0, -this.Window_Form_Container_Size.y / 2 - this.Window_Text_Container_Size.y / 2 + 0.5f, 
                                                             this.Window_Text_Container_Size.x, 
                                                             this.Window_Text_Container_Size.y, 
                                                             this.Window_Rounding, 
                                                             this.Window_Rounding, 
                                                             0, 0);
            Window_Text_Container.setName("Window_Text_Container");
            Window_Text_Container.setStroke(false);
            Window_Text_Container.setFill(UI_Constants.GRAY_500);

        PShape Window_Form_Container = createShape(RECT, 0, 0, this.Window_Form_Container_Size.x,
                                                               this.Window_Form_Container_Size.y, 
                                                               0, 0, 
                                                               this.Window_Rounding,
                                                               this.Window_Rounding);
            Window_Form_Container.setName("Window_Form_Container");
            Window_Form_Container.setStroke(false);
            Window_Form_Container.setFill(UI_Constants.GRAY_600);
        
        PShape Window_Container_Stroke = createShape(RECT, 0, -this.Window_Text_Container_Size.y / 2, this.Window_Container_Size.x, this.Window_Container_Size.y, this.Window_Rounding);
            Window_Container_Stroke.setName("Window_Container_Stroke");
            Window_Container_Stroke.setStroke(UI_Constants.GRAY_400);
            Window_Container_Stroke.setStrokeWeight(2);
            Window_Container_Stroke.setFill(false);
        
        PShape Window_Container_TickMark = createShape(GROUP);
            Window_Container_TickMark.setName("Window_Container_TickMark");

            PShape TickMark_LineOne = createShape();
                TickMark_LineOne.beginShape();
                    TickMark_LineOne.vertex(this.Window_Text_Container_Size.x / 2 - 17, Window_Text_Container.getParam(1) - 6);
                    TickMark_LineOne.vertex(this.Window_Text_Container_Size.x / 2 - 29, Window_Text_Container.getParam(1) + 6);
                TickMark_LineOne.endShape();
                TickMark_LineOne.setFill(false);
                TickMark_LineOne.setStrokeWeight(2);
                TickMark_LineOne.setStroke(UI_Constants.GRAY_25);

            PShape TickMark_LineTwo = createShape();
                TickMark_LineTwo.beginShape();
                    TickMark_LineTwo.vertex(this.Window_Text_Container_Size.x / 2 - 29, Window_Text_Container.getParam(1) - 6);
                    TickMark_LineTwo.vertex(this.Window_Text_Container_Size.x / 2 - 17, Window_Text_Container.getParam(1) + 6);
                TickMark_LineTwo.endShape();
                TickMark_LineTwo.setFill(false);
                TickMark_LineTwo.setStrokeWeight(2);
                TickMark_LineTwo.setStroke(UI_Constants.GRAY_25);
            
            Window_Container_TickMark.addChild(TickMark_LineOne);
            Window_Container_TickMark.addChild(TickMark_LineTwo);

            PShape Window_Container_TickMark_Listener = createShape();
                Window_Container_TickMark_Listener.beginShape();
                    Window_Container_TickMark_Listener.vertex(this.Window_Text_Container_Size.x / 2 - 29, Window_Text_Container.getParam(1) - 6);
                    Window_Container_TickMark_Listener.vertex(this.Window_Text_Container_Size.x / 2 - 17, Window_Text_Container.getParam(1) - 6);
                    Window_Container_TickMark_Listener.vertex(this.Window_Text_Container_Size.x / 2 - 17, Window_Text_Container.getParam(1) + 6);
                    Window_Container_TickMark_Listener.vertex(this.Window_Text_Container_Size.x / 2 - 29, Window_Text_Container.getParam(1) + 6);
                Window_Container_TickMark_Listener.endShape(CLOSE);
                Window_Container_TickMark_Listener.setName("Window_Container_TickMark_Listener");
                Window_Container_TickMark_Listener.setFill(false);
                Window_Container_TickMark_Listener.setStroke(false);   

        PShape Window_Container_Listener = UI_Constants.createElementListener(Window_Container_Stroke);
                Window_Container_Listener.setName("Window_Container_Listener");
        PShape Window_Form_Container_Listener = UI_Constants.createElementListener(Window_Form_Container);
                Window_Form_Container_Listener.setName("Window_Form_Container_Listener");
        PShape Window_Text_Container_Listener = UI_Constants.createElementListener(Window_Text_Container);
                Window_Text_Container_Listener.setName("Window_Text_Container_Listener");
            
        this.Window_Container.addChild(Window_Form_Container);
        this.Window_Container.addChild(Window_Text_Container);
        this.Window_Container.addChild(Window_Container_Stroke);
        
        if(this.hasCloseButton) {
             this.Window_Container.addChild(Window_Container_TickMark);
        }

        this.Window_Container.addChild(Window_Container_Listener);
        this.Window_Container.addChild(Window_Form_Container_Listener);
        this.Window_Container.addChild(Window_Text_Container_Listener);

        if(this.hasCloseButton) {
            this.Window_Container.addChild(Window_Container_TickMark_Listener);
        }

        this.Window_Container.addChild(Element_Group);

        this.Window_Container.resetMatrix();
        this.Window_Container.translate(this.Window_Position.x, this.Window_Position.y);
        this.Window_Container.scale(this.Window_Scale);


        this.Window_Text_Width = textWidth(this.Window_Name);
        this.Window_Text_Position.set(-this.Window_Text_Container_Size.x / 2 + textWidth(this.Window_Name) / 2 + 15, -(this.Window_Form_Container_Size.y + this.Window_Text_Container_Size.y) / 2 + (textAscent() - textDescent()) * UI_Constants.GLOBAL_TEXT_ALIGN_FACTOR_Y);
    }

/*
============================================= Draw =================================================
*/  
    public void draw() {
        if(!this.Window_Visibility) {
            return;
        }

        this.drawShape();
        pushMatrix();
        translate(this.Window_Position.x, this.Window_Position.y);
        scale(this.Window_Scale);
            this.drawText();
            this.drawElementText();
        popMatrix();

        this.updateIsMouseOverWindow();
    }

    public void drawElementText() {
        for(UI_Element element : this.Window_Elements) {
            element.drawText();
        }
    }

    public void drawText() {
        if(this.isActiveWindow) {
            fill(UI_Constants.WHITE);
        } else {
            fill(UI_Constants.GRAY_25);
        }
        textFont(UI_Constants.INTER_BOLD);
        textSize(this.Window_Text_Size);
        textAlign(CENTER, CENTER);

        text(this.Window_Name, this.Window_Text_Position.x, this.Window_Text_Position.y);
    }

    public void drawShape() {
        shape(this.Window_Container, 0, 0);
    }


/*
============================================= Interaction ==========================================
*/
    public void onMouseRelease() {
        if(!this.Window_Visibility) {
            return;
        }

        if(this.wasMousePressedOverWindow) {
            Mouse.getMouseObjectResults().clear();
        }

        this.onElementMouseRelease();
        this.isDragging = false;
        this.wasMousePressedOverWindow = false;
    }

    public void interactionMouseRelease() {

    }


    public boolean onMouseDrag() {
        if(!this.Window_Visibility) {
            return false;
        }

        if(mousePressed && this.isMouseOverWindowFormContainer) {
            this.onElementMouseDrag();
            return true;
        }
        
        if (mousePressed && this.isMouseOverWindowTextContainer && this.wasMousePressedOverWindow) {
            if (!this.isDragging) {
                this.initialMouseDragPosition.set(mouseX, mouseY);
                this.isDragging = true;
            } else {
                PVector mouseDragDifference = PVector.sub(new PVector(mouseX, mouseY), this.initialMouseDragPosition);
                this.Window_Position.add(mouseDragDifference);
                this.Window_Container.resetMatrix();
                this.Window_Container.translate(this.Window_Position.x, this.Window_Position.y);
                this.initialMouseDragPosition.set(mouseX, mouseY);
            }
            return true;
        } else {
            this.isDragging = false;
            return false;
        }
    }

    public void interactionMouseDrag() {

    }

    public boolean onMousePress() {
        if(!this.Window_Visibility) {
            return false;
        }

        if(mouseButton == LEFT) {
            if(this.isMouseOverWindow) {
                this.wasMousePressedOverWindow = true;
                this.checkWindowClose();

                if(!this.Window_Visibility) {
                    return true;
                }

                this.onWindowSelectHotbarCaller();
                this.onElementMousePress();
                return true;
            } else {
                this.wasMousePressedOverWindow = false;
                this.onWindowDeselect();
                return false;
            }
        } else {
            return false;
        }
    }

    public void interactionMousePress() {

    }


    public void onElementMousePress() {
        for(UI_Element element : this.Window_Elements) {
            if(!element.onMousePress()) {
                continue;
            }

            if(element instanceof UI_Toggle) {
                this.handleToggleElement((UI_Toggle)element);
            } else if(element instanceof UI_Slider) {
                element.onSelect();
            } else if(element instanceof UI_FileButton) {
                this.handleFileButtonElement((UI_FileButton)element);
            } else if(element instanceof UI_Button) {
                element.onSelect();
            }
        }
    }

    private void handleToggleElement(UI_Toggle toggleElement) {
        if(toggleElement.getState()) {
            toggleElement.onDeselect();
        } else {
            deselectGroupElements(toggleElement.getGroupName(), toggleElement);
            toggleElement.onSelect();
        }
    }

    private void handleFileButtonElement(UI_FileButton fileButtonElement) {
        if(fileButtonElement.getState()) {
            fileButtonElement.onDeselect();
        } else {
            deselectGroupElements(fileButtonElement.getGroupName(), fileButtonElement);
            fileButtonElement.onSelect();
        }
    }

    private void deselectGroupElements(String groupName, UI_Element selectedElement) {
        if(groupName == null) {
            return;
        }

        for(UI_Element element : this.Window_Elements) {
            if(element != selectedElement && groupName.equals(element.getGroupName())) {
                element.onDeselect();
            }
        }
    }
    public void onElementMouseDrag() {
        for(UI_Element element : this.Window_Elements) {
            element.onMouseDrag();
        }
    }

    public void onElementMouseRelease() {
        for(UI_Element element : this.Window_Elements) {
            element.onMouseRelease();
        }
    }

    public void onWindowSelect() {
        this.deselectAllWindows();
        this.isActiveWindow = true;
        UI_Manager.bringToFront(this);
        this.Window_Container.getChild("Window_Container_Stroke").setStroke(UI_Constants.BLUE_SELECTED);
        this.Window_Container.getChild("Window_Text_Container").setFill(UI_Constants.BLUE_UNSELECTED);
    }


    public void onWindowSelectHotbarCaller() {
        this.deselectAllWindows();
        this.isActiveWindow = true;
        UI_Manager.bringToFront(this);
        this.Window_Container.getChild("Window_Container_Stroke").setStroke(UI_Constants.BLUE_SELECTED);
        this.Window_Container.getChild("Window_Text_Container").setFill(UI_Constants.BLUE_UNSELECTED);

        if(this.HotBarSlotRepresentation != null) {
            switch(this.HotBarSlotRepresentation) {
                case "Editor":
                    UI_Manager.HOT_BAR.onSlotChange(1);
                    this.onWindowSelect();
                    break;
                case "Circle":
                    UI_Manager.HOT_BAR.onSlotChange(2);
                    this.onWindowSelect();
                    break;
                case "Rectangle":
                    UI_Manager.HOT_BAR.onSlotChange(3);
                    this.onWindowSelect();
                    break;
                case "Spring":
                    UI_Manager.HOT_BAR.onSlotChange(4);
                    this.onWindowSelect();
                    break;
                case "Rod":
                    UI_Manager.HOT_BAR.onSlotChange(5);
                    this.onWindowSelect();
                    break;
                case "Motor":
                    UI_Manager.HOT_BAR.onSlotChange(6);
                    this.onWindowSelect();
                    break;
            }
        }

    }

    public void onWindowDeselect() {
        this.isActiveWindow = false;
        this.Window_Container.getChild("Window_Container_Stroke").setStroke(UI_Constants.GRAY_400);
        this.Window_Container.getChild("Window_Text_Container").setFill(UI_Constants.GRAY_500);
    }

    public void onWindowClose() {
        this.Window_Visibility = false;
        this.isMouseOverWindow = false;
        this.isMouseOverWindowTextContainer = false;
        this.isMouseOverWindowFormContainer = false;
        this.wasMousePressedOverWindow = false;
        this.isActiveWindow = false;
    }

    public void updateIsMouseOverWindow() {

        if(!this.Window_Visibility) {
            return;
        }

        float x = mouseX - this.Window_Position.x;
        float y = mouseY - this.Window_Position.y;

        if(this.Window_Container.getChild("Window_Container_Listener").contains(x, y)) {
            if(this.Window_Container.getChild("Window_Text_Container_Listener").contains(x, y)) {
                this.isMouseOverWindowTextContainer = true;
                this.isMouseOverWindowFormContainer = false;
            } else {
                this.isMouseOverWindowTextContainer = false;
                this.isMouseOverWindowFormContainer = true;
            }
            this.isMouseOverWindow = true;
        } else {
            this.isMouseOverWindow = false;
            this.isMouseOverWindowTextContainer = false;
            this.isMouseOverWindowFormContainer = false;
        }
    }

    public void deselectAllWindows() {
        for (int i = 0; i < UI_Manager.WINDOWS.size(); i++) {
            UI_Manager.WINDOWS.get(i).onWindowDeselect();
        }
    }

    public void checkWindowClose() {
        if(this.hasCloseButton) {
            if(this.Window_Container.getChild("Window_Container_TickMark_Listener").contains(mouseX - this.Window_Position.x, mouseY - this.Window_Position.y)) {
                this.onWindowClose();
            }  
        }
    }


/*
============================================= Methods ==============================================
*/

    public void addElement(UI_Element element) {
        this.Window_Elements.add(element);
        this.Window_Container.getChild("Element_Group").addChild(element.getShape());
    }

    public void clearAllElements() {
        for(UI_Element element : this.Window_Elements) {
            this.Window_Container.getChild("Element_Group").removeChild(this.Window_Container.getChild("Element_Group").getChildIndex(element.getShape()));
        }
        this.Window_Elements.clear();
    }

    public void onKeyPress(int keyCode) {

    }
/*
======================================== Getters & Setters =========================================
*/

    public float getWindowContainerWidth() {
        return this.Window_Container_Size.x;
    }
    public float getWindowContainerHeight() {
        return this.Window_Container_Size.y;
    }
    public PVector getWindowContainerDimensions() {
        return this.Window_Container_Size;
    }
    public float getWindowTextContainerWidth() {
        return this.Window_Text_Container_Size.x;
    }
    public float getWindowTextContainerHeight() {
        return this.Window_Text_Container_Size.y;
    }
    public PVector getWindowTextContainerDimensions() {
        return this.Window_Text_Container_Size;
    }
    public float getWindowFormContainerWidth() {
        return this.Window_Form_Container_Size.x;
    }
    public float getWindowFormContainerHeight() {
        return this.Window_Form_Container_Size.y;
    }
    public PVector getWindowFormContainerDimensions() {
        return this.Window_Form_Container_Size;
    }
    public float getWindowContainerCenterPositionX () {
        return this.Window_Position.x;
    }
    public float getWindowContainerCenterPositionY() {
        return this.Window_Position.y;
    }
    public float getWindowPositionX() {
        return this.Window_Position.x;
    }
    public float getWindowPositionY() {
        return this.Window_Position.y;
    }
    public PVector getWindowPosition() {
        return this.Window_Position;
    }

    public UI_Element getElement(int index) {
        return this.Window_Elements.get(index);
    }

    public int getWindowElementArrayListSize() {
        return this.Window_Elements.size();
    }
    
    public int getWindowID() {
        return this.Window_ID;
    }

    public UI_Element getElementByName(String elementName) {
        for(UI_Element element : this.Window_Elements) {
            if(element.getElementName().equals(elementName)) {
                return element;
            }
        }
        throw new IllegalArgumentException("Element with name " + elementName + " does not exist in window " + this.Window_Name);
    }

    public String getWindowName() {
        return this.Window_Name;
    }

    public void setWindowPosition(PVector position) {
        this.Window_Position.set(position);
        this.Window_Container.resetMatrix();
        this.Window_Container.translate(this.Window_Position.x, this.Window_Position.y);
        this.Window_Container.scale(this.Window_Scale);
    }

    public void setWindowPositionX(float posX) {
        this.Window_Position.set(new PVector(posX, this.Window_Position.y));
        this.Window_Container.resetMatrix();
        this.Window_Container.translate(this.Window_Position.x, this.Window_Position.y);
        this.Window_Container.scale(this.Window_Scale);
    }

    public void setWindowVisibility(boolean Window_Visibility) {
        this.Window_Visibility = Window_Visibility;
    }




    public void interactionDraw() {

    }

    public void interactionMouseClick() {

    }

    public void onSlotChange(int previousSlotID) {
        
    }

}


  static public void main(String[] passedArgs) {
    String[] appletArgs = new String[] { "PhysicsEngine" };
    if (passedArgs != null) {
      PApplet.main(concat(appletArgs, passedArgs));
    } else {
      PApplet.main(appletArgs);
    }
  }
}
