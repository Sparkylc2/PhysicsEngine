/* autogenerated by Processing revision 1293 on 2024-02-05 */
import processing.core.*;
import processing.data.*;
import processing.event.*;
import processing.opengl.*;

import java.util.*;
import java.util.concurrent.*;
import java.util.Stack;
import java.math.*;
import java.lang.Enum;
import controlP5.*;
import processing.data.JSONArray;
import processing.data.JSONObject;
import java.util.UUID;

import java.util.HashMap;
import java.util.ArrayList;
import java.io.File;
import java.io.BufferedReader;
import java.io.PrintWriter;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.IOException;

public class PhysicsEngine extends PApplet {



GUI gui;
PShape background;
Softbody softbody;
Cloth cloth;
boolean loadLevel = false;


public void setup() {
/*--------------------- Timing Utilities ---------------------*/
    lastFrameTime = millis();
/*------------------------------------------------------------*/


/*--------------------- Camera Utilities ---------------------*/
    /* size commented out by preprocessor */;
    
    windowMove(10, 4);
    frameRate(300);
    interactivityListener = new InteractivityListener();
    
/*------------------------------------------------------------*/

/*---------------------------- UI ----------------------------*/
    userInterface = new ControlP5(this);
    gui = new GUI(userInterface);
    GUI_GROUP_POSITION_X = gui.calculateGroupPositionX();
    GUI_GROUP_POSITION_Y = gui.calculateGroupPositionY();
    GUI_GLOBAL_GROUP_WIDTH = gui.globalGroupWidth;
    GUI_GLOBAL_GROUP_HEIGHT = gui.globalGroupHeight;
/*------------------------------------------------------------*/

/*------------------- Background ---------------------------*/
    background = loadShape("background.svg");
/*-------------------------- Rigidbodies ------------------------*/
  rigidbodyList = new ArrayList<Rigidbody>();
/*------------------------------------------------------------*/


    Rigidbody floor = RigidbodyGenerator.CreateBoxBody(1000f, 5f, 1f, 0.5f, true, true, 0.05f, new PVector(0,0,0), new PVector(255,255,255));
    Rigidbody springBody = RigidbodyGenerator.CreateBoxBody(4f, 1f, 1f, 0.5f, false, true, 0.05f, new PVector(0, 0, 0), new PVector(255, 255, 255));
    Rigidbody test = RigidbodyGenerator.CreateCircleBody(1f, 1f, 0.5f, false, true, 0.05f, new PVector(0, 0, 0), new PVector(255, 255, 255));
    Rigidbody spinningBody = RigidbodyGenerator.CreateCircleBody(1f, 1f, 0.5f, false, true, 0.05f, new PVector(0, 0, 0), new PVector(255, 255, 255));


        
    floor.SetInitialPosition(new PVector(0, 10));
    test.SetInitialPosition(new PVector(-10, -5));
    springBody.SetInitialPosition(new PVector(-10, -5));
    spinningBody.SetInitialPosition(new PVector(0, -5));

    spinningBody.setIsTranslationallyStatic(true);


    Rod rod = new Rod(springBody, test, new PVector(), new PVector());
    Spring springLeft = new Spring(springBody, new PVector(2,0), new PVector(-8, -10));
    Spring springRight = new Spring(springBody, new PVector(-2,0), new PVector(-12, -10));

    rod.setIsJoint(true);


    springBody.addForceToForceRegistry(rod);
    test.addForceToForceRegistry(rod); 

    springBody.addForceToForceRegistry(springLeft);
    springBody.addForceToForceRegistry(springRight);

    test.addForceToForceRegistry(new Gravity(test));
    springBody.addForceToForceRegistry(new Gravity(springBody));
    spinningBody.addForceToForceRegistry(new Gravity(spinningBody));
    springBody.setIsTranslationallyStatic(true);

    AddBodyToBodyEntityList(springBody);
    AddBodyToBodyEntityList(test);
    AddBodyToBodyEntityList(floor);
    AddBodyToBodyEntityList(spinningBody);

    //ALL_FORCES_ARRAYLIST.add(rod);
    //ALL_FORCES_ARRAYLIST.add(springLeft);
    //ALL_FORCES_ARRAYLIST.add(springRight);


    //softbody = new Softbody(new PVector(0, -50), 0, 2, 2);
    //softbody.CreateBoxSoftbody();
    //cloth = new Cloth(new PVector(-20, -50), new PVector(0, -50), 20);
    //cloth.CreateCloth();
}


public void draw() {
    if(loadLevel) {
        levelEditor.loadLevelState();
        loadLevel = false;
    }
  int currentFrameTime = millis();

  /*NEVER DELETE THIS */
  gui.getActiveTab();
  /* PLEASE */

  interactivityListener.applyTransform();
  render.draw();
    editor.whileEditorSelect(-1);
  
  //for(Softbody softbody : softbodyList) {
  //  softbody.draw();
  //}
  //cloth.updateCloth();

  /*--------------------- Cursor Trail ---------------------*/

  if(IsMouseOverUI()) {
    interactivityListener.setDrawCursorTrail(false);
    cursor();
} else {
    interactivityListener.setDrawCursorTrail(true);
    interactivityListener.drawInteractions();
    noCursor();
  }

  dt = (currentFrameTime - lastFrameTime) / 1000f;
  Step(dt, SUB_STEP_COUNT);

  interactivityListener.resetTransform();

  displayTimings();

  lastFrameTime = currentFrameTime;


}



public class AABB {

  private final PVector Min;
  private final PVector Max;

/*
====================================================================================================
========================================== Constructors ============================================
====================================================================================================
*/

public AABB(PVector min, PVector max) {
    this.Min = min;
    this.Max = max;
}


/*-------------------------------------Overloaded Constructor-------------------------------------*/
public AABB(float minX, float minY, float maxX, float maxY) {
    this.Min = new PVector(minX, maxY);
    this.Max = new PVector(maxX, maxY);
}


/*
====================================================================================================
==============================================GETTERS & SETTERS=====================================
====================================================================================================
*/
  public PVector getMin() {
    return Min;
  }

  public PVector getMax() {
    return Max;
  }

}
public class Cloth {

    private PVector initialLeftCornerPosition;
    private PVector initialRightCornerPosition;

    private float clothWidth;
    private float clothHeight;

    private float stiffness = 300f;
    private float damping = 1f;

    private int numRowParticles;
    private int numColumnParticles;
    private int spacing = 2;
    private float particleRadius = 0.5f;

    private Rigidbody[][] clothBodyParticles;

    public Cloth(PVector initialLeftCornerPosition, PVector initialRightCornerPosition, float length) {

        this.initialLeftCornerPosition = initialLeftCornerPosition;
        this.initialRightCornerPosition = initialRightCornerPosition;
        this.clothWidth = (int)round(PVector.sub(initialLeftCornerPosition, initialRightCornerPosition).mag() / 5.0f) * 5;
        this.clothHeight = (int)round(length / spacing) * spacing;

        this.numRowParticles = (int)clothWidth/spacing;
        this.numColumnParticles = (int)clothHeight/spacing;
        clothBodyParticles = new Rigidbody[numRowParticles][numColumnParticles];
    }


    public void CreateCloth() {
        float initialParticlePositionX = this.initialLeftCornerPosition.x;
        float initialParticlePositionY = this.initialLeftCornerPosition.y;

        for(int row = 0; row < numRowParticles; row++) {
            for(int column = 0; column < numColumnParticles; column++) {

                PVector currentParticlePosition = new PVector(initialParticlePositionX + row*spacing, initialParticlePositionY + column*spacing);

                Rigidbody currentParticle = RigidbodyGenerator.CreateCircleBody(particleRadius, 0.5f, 0.02f, false, true, 0.1f, new PVector(0,0,0), new PVector(255,255,255));
                currentParticle.setPosition(currentParticlePosition);
                currentParticle.previousPosition = currentParticlePosition.copy();

                clothBodyParticles[row][column] = currentParticle;

                currentParticle.addForceToForceRegistry(new Gravity(currentParticle));
                currentParticle.setIsVisible(false);
                AddBodyToBodyEntityList(currentParticle);
            }
        }

        clothBodyParticles[0][0].setIsVisible(true);
        clothBodyParticles[numRowParticles - 1][0].setIsVisible(true);

        clothBodyParticles[0][0].setIsStatic(true);
        clothBodyParticles[numRowParticles - 1][0].setIsStatic(true);


        for(int row = 0; row < numRowParticles; row++) {
            for(int column = 0; column < numColumnParticles; column++) {
            
                Rigidbody currentParticle = clothBodyParticles[row][column];

                // Link to particle below if it exists
                if(row < numRowParticles - 1) {
                    Rigidbody particleToLinkTo = clothBodyParticles[row+1][column];
                    addSpringBetweenParticles(currentParticle, particleToLinkTo);
                }

                // Link to particle to the right if it exists
                if(column < numColumnParticles - 1) {
                    Rigidbody particleToLinkTo = clothBodyParticles[row][column+1];
                    addSpringBetweenParticles(currentParticle, particleToLinkTo);
                }

                if (row == 0 || row == numRowParticles - 1 || column == 0 || column == numColumnParticles - 1) {
                    // If the particle is on the edge, set its collidability to true
                    currentParticle.setCollidability(true);
                } else {
                    // If the particle is not on the edge, set its collidability to false
                    currentParticle.setCollidability(false);
                }
                
            }
        }
    }

    private void addSpringBetweenParticles(Rigidbody particleA, Rigidbody particleB) {
        Spring spring = new Spring(particleA, particleB, new PVector(), new PVector());
        spring.setSpringLength(PVector.dist(particleA.getPosition(), particleB.getPosition()));
        spring.setSpringConstant(this.stiffness);
        spring.setDamping(this.damping);
        spring.drawSpring = false;

        particleA.addForceToForceRegistry(spring);
        particleB.addForceToForceRegistry(spring);
    }

    public void updateCloth() {
      draw();
    }




    public void draw() {
beginShape(LINES);
for (int row = 0; row < numRowParticles; row++) {
    for (int column = 0; column < numColumnParticles - 1; column++) {
        PVector pos = clothBodyParticles[row][column].getPosition();
        PVector rightPos = clothBodyParticles[row][column + 1].getPosition();
        vertex(pos.x, pos.y);
        vertex(rightPos.x, rightPos.y);
    }
}
endShape();

// Draw vertical lines
beginShape(LINES);
for (int column = 0; column < numColumnParticles; column++) {
    for (int row = 0; row < numRowParticles - 1; row++) {
        PVector pos = clothBodyParticles[row][column].getPosition();
        PVector bottomPos = clothBodyParticles[row + 1][column].getPosition();
        vertex(pos.x, pos.y);
        vertex(bottomPos.x, bottomPos.y);
    }
}
endShape();


    }


}

public class CollisionManifold {

    private final Rigidbody RigidbodyA;
    private final Rigidbody RigidbodyB;
    private final PVector Normal;
    private final float Depth;

    private final PVector[] PointsOfContact;
    private final int ContactCount;

    public CollisionManifold(Rigidbody rigidbodyA, Rigidbody rigidbodyB,
                             CollisionResult collisionResult) {

        this.RigidbodyA = rigidbodyA;
        this.RigidbodyB = rigidbodyB;
        this.Normal = collisionResult.getNormal();
        this.Depth = collisionResult.getDepth();
        this.PointsOfContact = collisionResult.getPointsOfContact();
        this.ContactCount = collisionResult.getContactCount();
    }
    

    public Rigidbody getRigidbodyA() {
        return RigidbodyA;
    }

    public Rigidbody getRigidbodyB() {
        return RigidbodyB;
    }

    public PVector getNormal() {
        return Normal;
    }

    public float getDepth() {
        return Depth;
    }

    public PVector[] getPointsOfContact() {
        return PointsOfContact;
    }

    public int getContactCount() {
        return ContactCount;
    }


}
public class CollisionResult {
 
  private boolean isColliding;
  private PVector normal = new PVector();
  private float depth;

  private float distanceSquared;

  private PVector[] pointsOfContact;

  private int contactCount;

  


/*
====================================================================================================
================================ PointSegmentDistance Constructor ==================================
====================================================================================================
*/

//Default constructor for no collision
  public CollisionResult(){

    this.isColliding = false;
    this.normal.set(0,0,0);
    this.depth = 0f;
    this.pointsOfContact = null;
    this.contactCount = 0;
  }


  public CollisionResult(float distanceSquared, PVector pointOfContact) {


    this.distanceSquared = distanceSquared;

    this.pointsOfContact = new PVector[] {pointOfContact};
  }



  public CollisionResult(PVector[] pointsOfContact) {
    this.isColliding = true;

    this.pointsOfContact = pointsOfContact;
    this.contactCount = pointsOfContact.length;
  }

  public CollisionResult(boolean isColliding, PVector normal, float depth, PVector[] pointsOfContact) {
    this.isColliding = isColliding;
    this.normal = normal;
    this.depth = depth;

    this.pointsOfContact = pointsOfContact;
    this.contactCount = pointsOfContact.length;
  }

  
  public CollisionResult(boolean isColliding, PVector normal, float depth) {
    this.isColliding = isColliding;
    this.normal = normal;
    this.depth = depth;
    this.pointsOfContact = null;
    this.contactCount = 0;
  }
 
  /*
  =====================================================================================================
  =========================================== Getters/Setters =========================================
  =====================================================================================================
  */

  public boolean getIsColliding() {
    return isColliding;
  }
  
  public PVector getNormal() {
    return normal;
  }

  public float getDepth() {
    return depth;
  }

  public PVector[] getPointsOfContact() {
    return pointsOfContact;
  }

  public int getContactCount() {
    return contactCount;
  }
  
  public float getDistanceSquared() {
    return distanceSquared;
  }


  public void setIsColliding(boolean isColliding) {
    this.isColliding = isColliding;
  }

  public void setNormal(PVector normal) {
    this.normal = normal;
  }

  public void setDepth(float depth) {
    this.depth = depth;
  }
  public void setDistanceSquared(float distanceSquared) {
    this.distanceSquared = distanceSquared;
  }

  //Overloaded Methods
  public void setPointsOfContact(PVector[] pointsOfContact) {
    this.pointsOfContact = pointsOfContact;
  }
  
  public void setPointsOfContact(PVector pointOfContact) {
    this.pointsOfContact = new PVector[] {pointOfContact};
  }

  public void setPointsOfContact(PVector pointOfContactA, PVector pointOfContactB) {
    this.pointsOfContact = new PVector[] {pointOfContactA, pointOfContactB};
  }

  public void setContactCount(int contactCount) {
    this.contactCount = contactCount;
  }

}
public static class Collisions {
  CollisionResult collisionResult;

  //This is required as there is no enclosing instance of physics class for collisionResult
  public static PhysicsEngine physicsEngine = new PhysicsEngine();




  /*------------------- Reusable  ------------------- */
  public static PVector ZeroNormal = new PVector();
/*
====================================================================================================
===================================== COLLIDE INFO =================================================
====================================================================================================
*/

/*optimizied*/
public static CollisionResult Collide(Rigidbody rigidbodyA, Rigidbody rigidbodyB) {

    ShapeType shapeTypeA = rigidbodyA.getShapeType();
    ShapeType shapeTypeB = rigidbodyB.getShapeType();

    if(shapeTypeA == ShapeType.BOX) {

      if(shapeTypeB == ShapeType.BOX) {

        return IntersectPolygon(rigidbodyA.getPosition(),
                                           rigidbodyA.GetTransformedVertices(),
                                           rigidbodyB.getPosition(),
                                           rigidbodyB.GetTransformedVertices());

      } else if(shapeTypeB == ShapeType.CIRCLE) {
        CollisionResult result = Collisions.IntersectCirclePolygon(rigidbodyB.getPosition(),
                                                                   rigidbodyB.getRadius(),
                                                                   rigidbodyA.getPosition(),
                                                                   rigidbodyA.GetTransformedVertices()
                                                                   );
        result.setNormal(result.getNormal().mult(-1));
        return result;

      }

    }
  if (shapeTypeA == ShapeType.CIRCLE) {
        
        if(shapeTypeB == ShapeType.BOX) {

          return IntersectCirclePolygon(rigidbodyA.getPosition(), 
                                                   rigidbodyA.getRadius(), 
                                                   rigidbodyB.getPosition(), 
                                                   rigidbodyB.GetTransformedVertices());

        } else if(shapeTypeB == ShapeType.CIRCLE) {

          return IntersectCircle(rigidbodyA.getPosition(), rigidbodyB.getPosition(), rigidbodyA.getRadius(), rigidbodyB.getRadius());

        }
      }

    return physicsEngine.new CollisionResult();
  }


/*
====================================================================================================
===================================== CONTACT-POINTS COLLISIONS ====================================
======================================= COLLISION-RESULT ===========================================
*/

/*optimized*/

public static void FindCollisionPoints(Rigidbody rigidbodyA, Rigidbody rigidbodyB,
                                                  CollisionResult collisionResult) {
    int contactCount = 0;

    ShapeType shapeTypeA = rigidbodyA.getShapeType();
    ShapeType shapeTypeB = rigidbodyB.getShapeType();

    if(shapeTypeA == ShapeType.BOX) {

      if(shapeTypeB == ShapeType.BOX) {
        PVector[] pointsOfContact = FindPolygonsCollisionPoints(rigidbodyA.GetTransformedVertices(),
                                                                rigidbodyB.GetTransformedVertices());
        collisionResult.setPointsOfContact(pointsOfContact);
        collisionResult.setContactCount(pointsOfContact.length);
        return;

      } else if(shapeTypeB == ShapeType.CIRCLE) {
        PVector[] pointsOfContact = FindCirclePolygonCollisionPoint(rigidbodyB.getPosition(),
                                                                    rigidbodyB.getRadius(),
                                                                    rigidbodyA.getPosition(),
                                                                    rigidbodyA.GetTransformedVertices());
        collisionResult.setPointsOfContact(pointsOfContact);
        collisionResult.setContactCount(1);
        return;
      }

    }
  if (shapeTypeA == ShapeType.CIRCLE) {
        
        if(shapeTypeB == ShapeType.BOX) {
          PVector[] pointsOfContact = FindCirclePolygonCollisionPoint(rigidbodyA.getPosition(),
                                                                      rigidbodyA.getRadius(),
                                                                      rigidbodyB.getPosition(),
                                                                      rigidbodyB.GetTransformedVertices());
          collisionResult.setPointsOfContact(pointsOfContact);
          collisionResult.setContactCount(1);
          return;

        } else if(shapeTypeB == ShapeType.CIRCLE) {
           PVector[] pointsOfContact = FindCirclesCollisionPoint(rigidbodyA.getPosition(),
                                                                 rigidbodyA.getRadius(),
                                                                 rigidbodyB.getPosition(),
                                                                 rigidbodyB.getRadius());
            collisionResult.setPointsOfContact(pointsOfContact);
            collisionResult.setContactCount(1);
            return;
        }
      }

    /*
    For displaying the points of contact
        for(PVector point : pointsOfContact) {
             //pointsOfContactList.add(point);
        }
   */

}
/*
====================================================================================================
============================== CIRCLE-CIRCLE COLLISION CONTACT POINT ===============================
======================================= COLLISION-RESULT ===========================================
====================================================================================================
*/
 private static PVector[] FindCirclesCollisionPoint(PVector centerA, float radiusA,
                                                         PVector centerB, float radiusB) {
    

    return new PVector[] {PVector.add(centerA, PVector.sub(centerB, centerA).normalize().mult(radiusA))};
    }
/*
====================================================================================================
=============================POLYGON-POLYGON COLLISION CONTACT POINT ===============================
======================================= COLLISION-RESULT ===========================================
====================================================================================================
*/


private static PVector[] FindPolygonsCollisionPoints(PVector[] transformedVerticesA,
                                                           PVector[] transformedVerticesB) {
  PVector contactPointA = new PVector();
  PVector contactPointB = new PVector();

  PVector vertexA = new PVector();
  PVector vertexB = new PVector();
  
  PVector point = new PVector();
  int contactCount = 0;

  float minDistanceSquared = Float.MAX_VALUE;

  for(int i = 0; i < transformedVerticesA.length; i++) {

      point.set(transformedVerticesA[i]);

      for(int j = 0; j < transformedVerticesB.length; j++) {
        
        CollisionResult pointSegmentDistanceResult = PointSegmentDistance(point, transformedVerticesB[j], transformedVerticesB[(j + 1) % transformedVerticesB.length]);

        if(PhysEngMath.Equals(pointSegmentDistanceResult.getDistanceSquared(),minDistanceSquared)) {

            if(!PhysEngMath.Equals(pointSegmentDistanceResult.getPointsOfContact()[0], contactPointA)) {

              contactPointB.set(pointSegmentDistanceResult.getPointsOfContact()[0]);
              contactCount = 2;

            }
            
        } else if(pointSegmentDistanceResult.getDistanceSquared() < minDistanceSquared) {

            minDistanceSquared = pointSegmentDistanceResult.getDistanceSquared();
            contactPointA.set(pointSegmentDistanceResult.getPointsOfContact()[0]);
            contactCount = 1;
        }
      }
    }


  for(int i = 0; i < transformedVerticesB.length; i++) {

      point.set(transformedVerticesB[i]);

      for(int j = 0; j < transformedVerticesA.length; j++) {
          
          vertexA.set(transformedVerticesA[j]);
          vertexB.set(transformedVerticesA[(j + 1) % transformedVerticesA.length]);
  
          CollisionResult pointSegmentDistanceResult = PointSegmentDistance(point, transformedVerticesA[j], transformedVerticesA[(j + 1) % transformedVerticesA.length]);

        if(PhysEngMath.Equals(pointSegmentDistanceResult.getDistanceSquared(),minDistanceSquared)) {

            if(!PhysEngMath.Equals(pointSegmentDistanceResult.getPointsOfContact()[0], contactPointA)) {
              contactPointB.set(pointSegmentDistanceResult.getPointsOfContact()[0]);
              contactCount = 2;
            }

        } else if(pointSegmentDistanceResult.getDistanceSquared() < minDistanceSquared) {
            minDistanceSquared = pointSegmentDistanceResult.getDistanceSquared();
            contactPointA.set(pointSegmentDistanceResult.getPointsOfContact()[0]);
            contactCount = 1;
        }
      }
    }

    if(contactCount == 1){
      return new PVector[] {contactPointA};
    }
    
    return new PVector[] {contactPointA, contactPointB};
  
}

/*
====================================================================================================
=============================CIRCLE-POLYGON COLLISION CONTACT POINT ===============================
======================================= COLLISION-RESULT ===========================================
====================================================================================================
*/

/*Somewhat optimized */

private static PVector[] FindCirclePolygonCollisionPoint(PVector circleCenter,
                                                         float circleRadius,
                                                         PVector polygonCenter,
                                                         PVector[] transformedVertices) {

    float minDistanceSquared = Float.MAX_VALUE;
    PVector contactPoint = new PVector();

    for(int i = 0; i < transformedVertices.length; i++) {

        CollisionResult pointSegmentDistanceResult = PointSegmentDistance(circleCenter, transformedVertices[i], transformedVertices[(i + 1) % transformedVertices.length]); 

        if(pointSegmentDistanceResult.getDistanceSquared() < minDistanceSquared) {

            minDistanceSquared = pointSegmentDistanceResult.getDistanceSquared();
            contactPoint.set(pointSegmentDistanceResult.getPointsOfContact()[0]);
        }
    }

    return new PVector[] {contactPoint};
  }


/*
====================================================================================================
===================================== AABB-AABB Collisions =========================================
====================================================================================================
*/
public static boolean IntersectAABB (AABB aabbA, AABB aabbB) {

  if(aabbA.getMax().x <= aabbB.getMin().x || aabbB.getMax().x <= aabbA.getMin().x
    || aabbA.getMax().y <= aabbB.getMin().y || aabbB.getMax().y <= aabbA.getMin().y) {

    return false;
  }

  return true;
}

/*
====================================================================================================
===================================== AABB-AABB Point Collision ====================================
====================================================================================================
*/
public static boolean IntersectAABBWithPoint(AABB aabb, PVector point) {
    if (point.x >= aabb.getMin().x && point.x <= aabb.getMax().x &&
        point.y >= aabb.getMin().y && point.y <= aabb.getMax().y) {
        return true; // The point is within the AABB
    }
    return false; // The point is outside the AABB
  }

/*
====================================================================================================
===================================== CIRCLE-CIRCLE COLLISIONS =====================================
======================================= COLLISION-RESULT ===========================================
====================================================================================================
*/
/*somewhat Optimized*/
  public static CollisionResult IntersectCircle(PVector centerA, PVector centerB,
                                                float radiusA, float radiusB) {

    PVector direction = PVector.sub(centerB, centerA);
    float distance = direction.mag();
    float radiusSum = (radiusA + radiusB);
    
    if(distance < radiusSum) {
      return physicsEngine.new CollisionResult(true, direction.normalize(), radiusSum - distance);
    } else {
      return physicsEngine.new CollisionResult();
    }
  }
  
                                             

/*
====================================================================================================
===================================== POLYGON-POLYGON COLLISIONS ===================================
======================================= COLLISION-RESULT============================================
====================================================================================================
*/

/*Optimized somewhat*/
public static CollisionResult IntersectPolygon(PVector centerA,
                                               PVector[] transformedVerticesA,
                                               PVector centerB,
                                               PVector[] transformedVerticesB) {

    float depth = Float.MAX_VALUE;

    PVector axis = new PVector();
    PVector normal = new PVector();
    PVector edge = new PVector();

    PVector transformedVertexA = new PVector();
    PVector transformedVertexB = new PVector();

    PVector secondTransformedVertexA = new PVector();
    PVector secondTransformedVertexB = new PVector();


    for(int vertexIndexA = 0; vertexIndexA < transformedVerticesA.length; vertexIndexA++) {
 

      //Gets the transformed vertices in polygon A, when at the end of the list, loops back to the start
      transformedVertexA.set(transformedVerticesA[vertexIndexA]);
      transformedVertexB.set(transformedVerticesA[(vertexIndexA + 1) % transformedVerticesA.length]);

      //Finds the edge between the two vertices,
      edge.set(PVector.sub(transformedVertexB, transformedVertexA));

      //Finds the normal or "axis" from the edge vector
      axis.set(-edge.y, edge.x);
      axis.normalize();

      //Projects the vertices of polygon A onto the axis. Format is [min, max]
      float[] minMaxA = ProjectVertices(transformedVerticesA, axis);
      float[] minMaxB = ProjectVertices(transformedVerticesB, axis);

      if(minMaxA[0] >= minMaxB[1] || minMaxB[0] >= minMaxA[1]) {
        return physicsEngine.new CollisionResult();
      }

      float axisDepth = min(minMaxB[1]-minMaxA[0], minMaxA[1]-minMaxB[0]);

      if(axisDepth < depth) {
        depth = axisDepth;
        normal.set(axis);
      }
    }

    for(int vertexIndexB = 0; vertexIndexB < transformedVerticesB.length; vertexIndexB++) {
      //!!!ALL OF THIS ASSUMES A CLOCKWISE WINDING ORDER!!!

      //Gets the transformed vertices in polygon A, when at the end of the list, loops back to the start
      secondTransformedVertexA.set(transformedVerticesB[vertexIndexB]);
      secondTransformedVertexB.set(transformedVerticesB[(vertexIndexB + 1) % transformedVerticesB.length]);

      //Finds the edge between the two vertices, 
      edge.set(PVector.sub(secondTransformedVertexB, secondTransformedVertexA));

      //Finds the normal or "axis" from the edge vector
      axis.set(-edge.y, edge.x);
      axis.normalize();

      //Projects the vertices of polygon A onto the axis. Format is [min, max]
      float[] minMaxA = ProjectVertices(transformedVerticesA, axis);
      float[] minMaxB = ProjectVertices(transformedVerticesB, axis);

      if(minMaxA[0] >= minMaxB[1] || minMaxB[0] >= minMaxA[1]) {        
        return physicsEngine.new CollisionResult();
      }

      float axisDepth = min(minMaxB[1]-minMaxA[0], minMaxA[1]-minMaxB[0]);
      
      if(axisDepth < depth) {
        depth = axisDepth;
        normal.set(axis);
      }
    }

    //This is correction code so that the normal points in the correct direction
    //If its not pointing in the correct direction, flip the normal
  
    if(PVector.dot(PVector.sub(centerB, centerA), normal) < 0) {
      normal.mult(-1);
    }

    return physicsEngine.new CollisionResult(true, normal, depth);
  }

//The overloaded method is used when the center of the polygon is not known


/*
====================================================================================================
===================================== CIRCLE-POLYGON COLLISIONS ====================================
======================================= COLLISION-RESULT ===========================================
====================================================================================================
*/


public static CollisionResult IntersectCirclePolygon(PVector circleCenter, float circleRadius,
                                                     PVector polygonCenter,
                                                     PVector[] transformedVertices){
    boolean isColliding;
    float depth = Float.MAX_VALUE;
    PVector normal = new PVector();

    PVector edge = new PVector();
    PVector axis = new PVector();

    float axisDepth = 0f;

    for(int vertexIndex = 0; vertexIndex < transformedVertices.length; vertexIndex++) {
      //!!!ALL OF THIS ASSUMES A CLOCKWISE WINDING ORDER!!!

      //Finds the edge between the two vertices,
      edge.set(PVector.sub(transformedVertices[(vertexIndex + 1) % transformedVertices.length], transformedVertices[vertexIndex]));
      
      //Finds the normal or "axis" from the edge vector
       axis.set(-edge.y, edge.x);
       axis.normalize();

      //Projects the vertices of polygon A onto the axis. Format is [min, max]
      float[] minMaxA = ProjectVertices(transformedVertices, axis);

      //Projects the circle onto the axis. Format is [min, max]
      float[] minMaxB = ProjectCircle(circleCenter, axis, circleRadius);

      if(minMaxA[0] >= minMaxB[1] || minMaxB[0] >= minMaxA[1]) {

        return physicsEngine.new CollisionResult();
      }

       axisDepth = min(minMaxB[1]-minMaxA[0], minMaxA[1]-minMaxB[0]);
        if(axisDepth < depth) {
            depth = axisDepth;
            normal.set(axis);
        }
  }

    int index = FindClosestPointOnPolygon(circleCenter, transformedVertices);
    
    if(index == -1) {
      return physicsEngine.new CollisionResult();
    }
    axis.set(PVector.sub(transformedVertices[index], circleCenter).normalize());

     //Projects the vertices of polygon A onto the axis. Format is [min, max]
      float[] minMaxA = ProjectVertices(transformedVertices, axis);
      //Projects the circle onto the axis. Format is [min, max]
      float[] minMaxB = ProjectCircle(circleCenter, axis, circleRadius);


      if(minMaxA[0] >= minMaxB[1] || minMaxB[0] >= minMaxA[1]) {
        
        return physicsEngine.new CollisionResult();
      }

      axisDepth = min(minMaxB[1]-minMaxA[0], minMaxA[1]-minMaxB[0]);

      if(axisDepth < depth) {
        depth = axisDepth;
        normal.set(axis);
      }

        if(PVector.dot(PVector.sub(polygonCenter, circleCenter), normal) < 0) {
          normal.mult(-1);
        }
  
        isColliding = true;

        return physicsEngine.new CollisionResult(isColliding, normal, depth);
}




/*
====================================================================================================
========================================= HELPER-METHODS ===========================================
====================================================================================================
*/

//Returns an array with array = [min, max]
private static float[] ProjectVertices(PVector[] vertices, PVector axis){

  float min = Float.MAX_VALUE;
  float max = Float.MIN_VALUE;

  for(PVector vertex : vertices) {

    float projectedVertex = PVector.dot(vertex, axis);

    if(projectedVertex < min) {
      min = projectedVertex;
    }

    if(projectedVertex > max) {
      max = projectedVertex;
    }

  }
  return new float[] {min, max};
}

private static float[] ProjectCircle(PVector center, PVector axis, float radius) {
  
  PVector directionAndRadius = PVector.mult(axis, radius);

  float min = PVector.dot(PVector.add(center, directionAndRadius), axis);
  float max = PVector.dot(PVector.sub(center, directionAndRadius), axis);
   
  if(min > max){
    float temp = min;
    min = max;
    max = temp;
  }

  return new float[] {min, max};
}

private static int FindClosestPointOnPolygon(PVector circleCenter, PVector[] transformedVertices) {
    int result = -1;
    float minDistanceSq = Float.MAX_VALUE;

    // Check for null or empty input
    if (transformedVertices == null || transformedVertices.length == 0 || circleCenter == null) {
        System.out.println("Input is null or empty");
        return result; // Return -1 to indicate error
    }

    for (int vertexIndex = 0; vertexIndex < transformedVertices.length; vertexIndex++) {
        // Additional check for null vertices, if necessary
        if (transformedVertices[vertexIndex] == null) {
            continue; // Skip this iteration
        }

        float distanceSq = PVector.sub(circleCenter, transformedVertices[vertexIndex]).magSq();

        if (distanceSq < minDistanceSq) {
            minDistanceSq = distanceSq;
            result = vertexIndex;
        }
    }

    return result;
}



public static CollisionResult PointSegmentDistance(PVector point, PVector lineSegmentStart, PVector lineSegmentEnd) {
    //PVector.sub(point, lineSegmentStart) is equivalent to pointToLineSegment

    PVector lineSegment = new PVector();
    lineSegment.set(PVector.sub(lineSegmentEnd, lineSegmentStart));

    float projection = PVector.dot(PVector.sub(point, lineSegmentStart), lineSegment);
    float lineSegmentLengthSquared = lineSegment.magSq();

    float distance = projection / lineSegmentLengthSquared;

    PVector closestPoint = new PVector();

    if (distance <= 0f) {
        closestPoint.set(lineSegmentStart);
    } else if (distance >= 1f) {
        closestPoint.set(lineSegmentEnd);
    } else {
        closestPoint.set(PVector.add(lineSegmentStart, PVector.mult(lineSegment, distance)));
    }

    float distanceSquared = PVector.sub(point, closestPoint).magSq();

    return physicsEngine.new CollisionResult(distanceSquared, closestPoint);
}
} 
public class Editor {


	private Rigidbody rigidbody;
 	

 	private boolean inEditMode = false;
	private int count = 0;

	public Editor () {
	}


	public void onEditorSelect (Rigidbody rigidbody) {
		if(rigidbody.getShapeType() == ShapeType.CIRCLE) {
			return;
		}
		this.rigidbody = rigidbody;
		this.inEditMode = true;
	}


	//ID -1 corresponds to drawing the vertices in the main draw loop
	//ID 0 corresponds to a click
	//ID 1 corresponds to a drag
	//ID 2 corresponds to a delete press

	public void whileEditorSelect(int id) {
		if(inEditMode) {
			if(id == -1) {
				//int index = this.selectVertex(VERTEX_SNAP_RADIUS);
				//this.drawVertices(index);
				this.drawVertices();
				return;
			} else if(id == 0){
				this.addVertexClick();
			} else if(id == 1) {
				int index = this.selectVertex(VERTEX_SNAP_RADIUS);
				if(index != -1) {
					this.moveVertex(index);
				}
			} else if(id == 2) {
				int index = this.selectVertex(VERTEX_SNAP_RADIUS);
				if(index != -1) {
					this.deleteVertex(index);
				}
			}
		}
	}


	public int selectVertex(float radius) {
		PVector[] rigidbodyVertices = rigidbody.GetTransformedVertices();

		for(int i = 0; i < rigidbodyVertices.length; i++) {
			if(PVector.sub(PVector.add(rigidbody.getPosition(), PhysEngMath.SnapController(interactivityListener, rigidbody, interactivityListener.screenToWorld())), rigidbodyVertices[i]).magSq() < radius) {
				//System.out.println(i);
				return i;
			}
		}
		return -1;
	}

	public void addVertexClick() {
		PVector vertex = PhysEngMath.ReverseTransform(interactivityListener.screenToWorld(), this.rigidbody.getPosition().copy().mult(-1), -this.rigidbody.getAngle());
		PVector[] rigidbodyVertices = this.rigidbody.getVertices();
		PVector[] newRigidbodyVertices = new PVector[rigidbodyVertices.length + 1];

		for(int i = 0; i < rigidbodyVertices.length; i++) {
			newRigidbodyVertices[i] = rigidbodyVertices[i];
		}

		newRigidbodyVertices[newRigidbodyVertices.length - 1] = vertex;

		this.rigidbody.updatePolygon(newRigidbodyVertices);
	} 

	public void deleteVertex(int index) {
		ArrayList<PVector> vertexList = new ArrayList<PVector>(Arrays.asList(this.rigidbody.getVertices()));
		vertexList.remove(index);
		this.rigidbody.updatePolygon(vertexList.toArray(new PVector[vertexList.size()]));
	}


	public void drawVertices() {
		PVector[] currentVertices = this.rigidbody.GetTransformedVertices();
		for(PVector vertex : currentVertices) {
			pushMatrix();
			translate(vertex.x, vertex.y);

			fill(0, 255, 0);
			noStroke();
			ellipse(0, 0, 0.25f, 0.25f);
			popMatrix();

		}
	}

	public void moveVertex(int index) {
		PVector vertex = interactivityListener.screenToWorld();
		PVector[] rigidbodyCoreVertices = this.rigidbody.getVertices();

		PVector[] vertexList = Arrays.copyOf(rigidbodyCoreVertices, rigidbodyCoreVertices.length);

		vertexList[index] = PhysEngMath.ReverseTransform(vertex, this.rigidbody.getPosition().copy().mult(-1), -this.rigidbody.getAngle());

		this.rigidbody.updatePolygon(vertexList);
	}

	public void onEditorDeselect() {
		this.rigidbody = null;
		this.inEditMode = false;
	}

	public void onClick() {

	}

	public void onDrag() {

	}

	public void onSelection() {

	}


	public void onRelease(){

	}

	public boolean getInEditMode() {
		return this.inEditMode;
	}

	public Rigidbody getSelectedRigidbody() {
		return this.rigidbody;
	}
}
public interface ForceRegistry {
    public PVector getForce(Rigidbody rigidbody, PVector position);
    public void draw();
    public PVector getApplicationPoint(Rigidbody rigidbody, PVector position);
    public Rigidbody getRigidbodyA();
    public Rigidbody getRigidbodyB();
}

public enum ForceType {
  SPRING,
  ROD,
  MOTOR
}
    public class GUI {
        
        //The size of the group
        public int globalGroupHeight = 225;
        public int globalGroupWidth = 230;
        private int globalGroupBarHeight = 20;

        //The padding of the group from the edges of the screen
        public int globalScreenGroupPaddingX = 40;
        public int globalScreenGroupPaddingY = 40;


        
        //The padding for elements from the edge of the group
        private int globalGroupPaddingX = 10;
        private int globalGroupPaddingY = 10;
        
        //The padding between elements in the group
        private int globalInterElementPaddingX = 10;
        private int globalInterElementPaddingY = 10;

    
        //the group background color
        private int globalGroupColor = color(250, 50);

        private int rowCount = 10;

        //Checks which tab is open
        private boolean isRigidbodiesTabOpen;
        private boolean isForcesTabOpen;
     
        /*---------------------------- Default Values Initialization ------------------------*/
        private Tab defaultTab = userInterface.getTab("Rigidbodies");
        private Tab currentTab = defaultTab;
        /*---------------------------- Rigidbodies Tab -------------------------------------*/
        private boolean defaultCircleSelector = false;
        private boolean defaultRectangleSelector = false;
        private boolean defaultPolygonSelector = false;

        private float defaultRectangleWidth = 2f;
        private float defaultRectangleHeight = 2f;
        private float defaultCircleRadius = 1f;

        private float defaultDensity = 10f;
        private float defaultRestitution = 0.5f;

        private PVector defaultFillColour = new PVector(255, 255, 255);
        private PVector defaultStrokeColour = new PVector(0, 0, 0);
        private float defaultStrokeWeight = 0.05f;

        private boolean defaultIsStatic = false;
        private boolean defaultIsTransStatic = false;
        private boolean defaultIsRotStatic = false;

        private boolean defaultAddGravity = true;
        private boolean defaultIsCollidable = true;
        private float defaultAngle = 0f;
        private float defaultAngularVelocity = 0f;

        private boolean isFillColourSelectedDefault = true;

    /*---------------------------- Forces Tab -------------------------------------*/
        private boolean defaultSpringSelector = false;
        private boolean defaultRodSelector = false;
        private boolean defaultMotorSelector = false;

        private float defaultSpringConstant = 50f;
        private float defaultSpringDamping = 0.5f;
        private float defaultSpringEquilibriumLength = 1f;

        private boolean defaultLockToXAxis = false;
        private boolean defaultLockToYAxis = false;

        private boolean defaultSpringIsPerfect = false;
        private boolean defaultSpringIsHingeable = true;

        private boolean defaultRodIsHingeable = true;
        private boolean defaultRodIsJoint = false;

        private boolean defaultSnapToCenter = true;
        private boolean defaultSnapToEdge = false;

        private float defaultMotorTargetAngularVelocity = 0f;
        private boolean defaultMotorDrawMotor = false;
        private boolean defaultMotorDrawMotorForce = true;

    /*---------------------------- Editor Tab ----------------------- */


/*
====================================================================================================
========================================= User Interface ===========================================
====================================================================================================
*/
        public GUI(ControlP5 userInterface) {
    /*---------------------- Interactivity Listener Initialization -----------------*/
        if(defaultCircleSelector == true){
            interactivityListener.setShapeType(ShapeType.CIRCLE);
        } else if(defaultRectangleSelector == true){

            interactivityListener.setShapeType(ShapeType.BOX);
        } else if(defaultPolygonSelector == true){

            interactivityListener.setShapeType(ShapeType.POLYGON);
        }

        if(defaultSpringSelector) {
            interactivityListener.setForceType(ForceType.SPRING);
        } else if(defaultRodSelector) {

            interactivityListener.setForceType(ForceType.ROD);
        } else if(defaultMotorSelector) {
            interactivityListener.setForceType(ForceType.MOTOR);
        }



        interactivityListener.setWidth(defaultRectangleWidth);
        interactivityListener.setHeight(defaultRectangleHeight);
        interactivityListener.setRadius(defaultCircleRadius);

        interactivityListener.setDensity(defaultDensity);
        interactivityListener.setRestitution(defaultRestitution);

        interactivityListener.setFillColor(defaultFillColour);
        interactivityListener.setStrokeColor(defaultStrokeColour);
        interactivityListener.setStrokeWeight(defaultStrokeWeight);

        interactivityListener.setAngle(defaultAngle);
        interactivityListener.setAngularVelocity(defaultAngularVelocity);

        interactivityListener.setIsStatic(defaultIsStatic);
        interactivityListener.setIsTranslationallyStatic(defaultIsTransStatic);
        interactivityListener.setIsRotationallyStatic(defaultIsRotStatic);
        interactivityListener.setAddGravity(defaultAddGravity);
        interactivityListener.setCollidability(defaultIsCollidable);
        
        interactivityListener.setSpringConstant(defaultSpringConstant);
        interactivityListener.setSpringDamping(defaultSpringDamping);
        interactivityListener.setSpringEquilibriumLength(defaultSpringEquilibriumLength);

        interactivityListener.setLockToXAxis(defaultLockToXAxis);
        interactivityListener.setLockToYAxis(defaultLockToYAxis);

        interactivityListener.setSpringIsPerfect(defaultSpringIsPerfect);
        interactivityListener.setSpringIsHingeable(defaultSpringIsHingeable);
        interactivityListener.setRodIsHingeable(defaultRodIsHingeable);
        interactivityListener.setRodIsJoint(defaultRodIsJoint);
        
        interactivityListener.setSnapToCenter(defaultSnapToCenter);
        interactivityListener.setSnapToEdge(defaultSnapToEdge);


        interactivityListener.setMotorTargetAngularVelocity(defaultMotorTargetAngularVelocity);
        interactivityListener.setMotorDrawMotor(defaultMotorDrawMotor);
        interactivityListener.setMotorDrawMotorForce(defaultMotorDrawMotorForce);

    /*----------------------------------------------------------------------------*/

                Tab Rigidbodies = userInterface.addTab("Rigidbodies")
                                .setLabel("Rigidbodies")
                                .setId(0)
                                .activateEvent(true)
                                .addListener(new ControlListener() {
                                    public void controlEvent(ControlEvent theEvent) {
                                        if(theEvent.isTab() && theEvent.getTab().getId() == 0) {
                                            interactivityListener.setGenerateRigidbodies(true);
                                            interactivityListener.setGenerateForces(false);
                                        }
                                    }
                                })
                                ;
                
  

                Tab Forces = userInterface.addTab("Forces")
                                .setLabel("Forces")
                                .setId(1)
                                .activateEvent(true)
                                .addListener(new ControlListener() {
                                    public void controlEvent(ControlEvent theEvent) {
                                        if(theEvent.isTab() && theEvent.getTab().getId() == 1) {
                                            interactivityListener.setGenerateRigidbodies(false);
                                            interactivityListener.setGenerateForces(true);
                                        }
                                    }
                                })
                                ;

                //Tab Editor = userInterface.addTab("Editor")
                //                .setLabel("Editor")
                //                .setId(2);

                Tab Debug = userInterface.addTab("Debug")
                                .setLabel("Debug")
                                .setId(2);

/*----------------------------------- Rigidbodies Tab ------------------------------------------*/
                Group RigidbodyGeneration = userInterface.addGroup("Rigidbody")
                                .setPosition(calculateGroupPositionX(), calculateGroupPositionY())
                                .setBackgroundHeight(globalGroupHeight)
                                .setBarHeight(globalGroupBarHeight)
                                .setBackgroundColor(globalGroupColor)
                                .setWidth(globalGroupWidth)
                                 //.disableCollapse()
                                .setTab("Rigidbodies")
                                ;

                        Toggle Circle = userInterface.addToggle("Circle")
                                        .setPosition(calculateButtonPositionX(1, calculateButtonWidth(2)), calculateButtonPositionY(1, calculateButtonHeight(rowCount)))
                                        .setSize(calculateButtonWidth(2), calculateButtonHeight(rowCount))
                                        .setLabel("Circle")
                                        .setGroup(RigidbodyGeneration)
                                        .setValue(defaultCircleSelector)
                                        .onChange(new CallbackListener() {
                                                public void controlEvent(CallbackEvent theEvent) {

                                                        CircleShapeSelectorOnChange();
                                                    }
                                                })
                                            ;

                        Toggle Rectangle = userInterface.addToggle("Box")
                                        .setPosition(calculateButtonPositionX(2, calculateButtonWidth(2)), calculateButtonPositionY(1, calculateButtonHeight(rowCount)))
                                        .setSize(calculateButtonWidth(2), calculateButtonHeight(rowCount))
                                        .setLabel("Rectangle")
                                        .setGroup(RigidbodyGeneration)
                                        .setValue(defaultRectangleSelector)
                                        .onChange(new CallbackListener() {
                                                public void controlEvent(CallbackEvent theEvent) {

                                                        RectangleShapeSelectorOnChange();
                                                    }
                                                })
                                            ;

                                        
                        Slider Density = userInterface.addSlider("Density")
                                        .setPosition(calculateButtonPositionX(1, calculateButtonWidth(2)), calculateButtonPositionY(2, calculateButtonHeight(rowCount)))
                                        .setSize(calculateButtonWidth(2),calculateButtonHeight(rowCount))
                                        .setLabel("Density")
                                        .setVisible(false)
                                        .setRange(MIN_BODY_DENSITY, MAX_BODY_DENSITY)
                                        .setValue(defaultDensity)
                                        .setGroup(RigidbodyGeneration)
                                        .onChange(new CallbackListener() {
                                                public void controlEvent(CallbackEvent theEvent) {

                                                        DensityElementOnChange();
                                                    }
                                                })
                                            ;

                        Slider Restitution = userInterface.addSlider("Restitution")
                                        .setPosition(calculateButtonPositionX(2, calculateButtonWidth(2)), calculateButtonPositionY(2, calculateButtonHeight(rowCount)))
                                        .setSize(calculateButtonWidth(2),calculateButtonHeight(rowCount))
                                        .setLabel("Restitution")
                                        .setVisible(false)
                                        .setRange(0.01f, 1)
                                        .setValue(defaultRestitution)
                                        .setGroup(RigidbodyGeneration)
                                        .onChange(new CallbackListener() {
                                                public void controlEvent(CallbackEvent theEvent) {

                                                        RestitutionElementOnChange();
                                                    }
                                                })
                                            ;

                        Slider RectangleWidth = userInterface.addSlider("RectangleWidth")
                                        .setPosition(calculateButtonPositionX(1, calculateButtonWidth(2)), calculateButtonPositionY(3, calculateButtonHeight(rowCount)))
                                        .setSize(calculateButtonWidth(2),calculateButtonHeight(rowCount))
                                        .setLabel("Width")
                                        .setVisible(false)
                                        .setRange(MIN_BODY_WIDTH, MAX_BODY_WIDTH)
                                        .setValue(defaultRectangleWidth)
                                        .setGroup(RigidbodyGeneration)
                                        .onChange(new CallbackListener() {
                                                public void controlEvent(CallbackEvent theEvent) {
                                                        RectangleWidthElementOnChange();
                                                    }
                                                })
                                            ;

                        Slider RectangleHeight = userInterface.addSlider("RectangleHeight")
                                        .setPosition(calculateButtonPositionX(2, calculateButtonWidth(2)), calculateButtonPositionY(3, calculateButtonHeight(rowCount)))
                                        .setSize(calculateButtonWidth(2),calculateButtonHeight(rowCount))
                                        .setLabel("Height")
                                        .setVisible(false)
                                        .setRange(MIN_BODY_HEIGHT, MAX_BODY_HEIGHT)
                                        .setValue(defaultRectangleHeight)
                                        .setGroup(RigidbodyGeneration)
                                        .onChange(new CallbackListener() {
                                                public void controlEvent(CallbackEvent theEvent) {

                                                        RectangleHeightElementOnChange();
                                                    }
                                                })
                                            ;

                        Slider CircleRadius = userInterface.addSlider("CircleRadius")
                                        .setPosition(calculateButtonPositionX(1, calculateButtonWidth(1)), calculateButtonPositionY(3, calculateButtonHeight(rowCount)))
                                        .setSize(calculateButtonWidth(1),calculateButtonHeight(rowCount))
                                        .setLabel("Radius")
                                        .setVisible(false)
                                        .setRange(MIN_BODY_RADIUS, MAX_BODY_RADIUS)
                                        .setValue(defaultCircleRadius)
                                        .setGroup(RigidbodyGeneration)
                                        .onChange(new CallbackListener() {
                                                public void controlEvent(CallbackEvent theEvent) {

                                                        CircleRadiusElementOnChange();
                                                    }
                                                })
                                            ;

                        Toggle fillColour = userInterface.addToggle("FillColour")
                                        .setPosition(calculateButtonPositionX(1, calculateButtonWidth(3)), calculateButtonPositionY(4, calculateButtonHeight(rowCount)))
                                        .setSize(calculateButtonWidth(3),calculateButtonHeight(rowCount))
                                        .setLabel("Fill Colour")
                                        .setVisible(false)
                                        .setGroup(RigidbodyGeneration)
                                        .setValue(false)
                                        .onChange(new CallbackListener() {
                                                public void controlEvent(CallbackEvent theEvent) {

                                                       FillColourSelectorOnChange();
                                                    }
                                                })
                                            ;

                        Toggle strokeColour = userInterface.addToggle("StrokeColour")
                                        .setPosition(calculateButtonPositionX(2, calculateButtonWidth(3)), calculateButtonPositionY(4, calculateButtonHeight(rowCount)))
                                        .setSize(calculateButtonWidth(3),calculateButtonHeight(rowCount))
                                        .setLabel("Stroke Colour")
                                        .setVisible(false)
                                        .setGroup(RigidbodyGeneration)
                                        .setValue(false)
                                        .onChange(new CallbackListener() {
                                                public void controlEvent(CallbackEvent theEvent) {

                                                        StrokeColourSelectorOnChange();
                                                    }
                                                })
                                            ;

                        Slider strokeWeight = userInterface.addSlider("StrokeWeight")
                                        .setPosition(calculateButtonPositionX(3, calculateButtonWidth(3)), calculateButtonPositionY(4, calculateButtonHeight(rowCount)))
                                        .setSize(calculateButtonWidth(3),calculateButtonHeight(rowCount))
                                        .setLabel("Stroke")
                                        .setVisible(false)
                                        .setRange(0, 0.5f)
                                        .setValue(0.05f)
                                        .setGroup(RigidbodyGeneration)
                                        .onChange(new CallbackListener() {
                                                public void controlEvent(CallbackEvent theEvent) {

                                                        StrokeWeightElementOnChange();
                                                    }
                                                })
                                            ;

                        Slider redSliderFill = userInterface.addSlider("RedFill")
                                        .setPosition(calculateButtonPositionX(1, calculateButtonWidth(3)), calculateButtonPositionY(5, calculateButtonHeight(rowCount)))
                                        .setSize(calculateButtonWidth(3),calculateButtonHeight(rowCount))
                                        .setLabel("Red")
                                        .setVisible(false)
                                        .setRange(0, 255)
                                        .setValue(defaultFillColour.x)
                                        .setGroup(RigidbodyGeneration)
                                        .onChange(new CallbackListener() {
                                                public void controlEvent(CallbackEvent theEvent) {
                        
                                                        FillSliderElementOnChange();
                                                    }
                                                })
                                            ;

                        Slider greenSliderFill = userInterface.addSlider("GreenFill")
                                        .setPosition(calculateButtonPositionX(2, calculateButtonWidth(3)), calculateButtonPositionY(5, calculateButtonHeight(rowCount)))
                                        .setSize(calculateButtonWidth(3),calculateButtonHeight(rowCount))
                                        .setLabel("Green")
                                        .setVisible(false)
                                        .setRange(0, 255)
                                        .setValue(defaultFillColour.y)
                                        .setGroup(RigidbodyGeneration)
                                        .onChange(new CallbackListener() {
                                                public void controlEvent(CallbackEvent theEvent) {

                                                        FillSliderElementOnChange();
                                                    }
                                                })
                                            ;

                        Slider blueSliderFill = userInterface.addSlider("BlueFill")
                                        .setPosition(calculateButtonPositionX(3, calculateButtonWidth(3)), calculateButtonPositionY(5, calculateButtonHeight(rowCount)))
                                        .setSize(calculateButtonWidth(3),calculateButtonHeight(rowCount))
                                        .setLabel("Blue")
                                        .setVisible(false)
                                        .setRange(0, 255)
                                        .setValue(defaultFillColour.z)
                                        .setGroup(RigidbodyGeneration)
                                        .onChange(new CallbackListener() {
                                                public void controlEvent(CallbackEvent theEvent) {
                                                        
                                                        FillSliderElementOnChange();
                                                    }
                                                })
                                            ;

                        Slider redSliderStroke = userInterface.addSlider("RedStroke")
                                        .setPosition(calculateButtonPositionX(1, calculateButtonWidth(3)), calculateButtonPositionY(5, calculateButtonHeight(rowCount)))
                                        .setSize(calculateButtonWidth(3),calculateButtonHeight(rowCount))
                                        .setLabel("Red")
                                        .setVisible(false)
                                        .setRange(0, 255)
                                        .setValue(defaultStrokeColour.x)
                                        .setGroup(RigidbodyGeneration)
                                        .onChange(new CallbackListener() {
                                                public void controlEvent(CallbackEvent theEvent) {

                                                        StrokeSliderElementOnChange();
                                                    }
                                                })
                                            ;

                        Slider greenSliderStroke = userInterface.addSlider("GreenStroke")
                                        .setPosition(calculateButtonPositionX(2, calculateButtonWidth(3)), calculateButtonPositionY(5, calculateButtonHeight(rowCount)))
                                        .setSize(calculateButtonWidth(3),calculateButtonHeight(rowCount))
                                        .setLabel("Green")
                                        .setVisible(false)
                                        .setRange(0, 255)
                                        .setValue(defaultStrokeColour.y)
                                        .setGroup(RigidbodyGeneration)
                                        .onChange(new CallbackListener() {
                                                public void controlEvent(CallbackEvent theEvent) {
                                                        
                                                        StrokeSliderElementOnChange();
                                                    }
                                                })
                                            ;

                        Slider blueSliderStroke = userInterface.addSlider("BlueStroke")
                                        .setPosition(calculateButtonPositionX(3, calculateButtonWidth(3)), calculateButtonPositionY(5, calculateButtonHeight(rowCount)))
                                        .setSize(calculateButtonWidth(3),calculateButtonHeight(rowCount))
                                        .setLabel("Blue")
                                        .setVisible(false)
                                        .setRange(0, 255)
                                        .setValue(defaultStrokeColour.z)
                                        .setGroup(RigidbodyGeneration)
                                        .onChange(new CallbackListener() {
                                                public void controlEvent(CallbackEvent theEvent) {
                                                        
                                                        StrokeSliderElementOnChange();
                                                    }
                                                })
                                            ;

                        Bang colorBox = userInterface.addBang("ColorBox")
                                        .setPosition(calculateButtonPositionX(1, calculateButtonWidth(1)), calculateButtonPositionY(6, calculateButtonHeight(rowCount)))
                                        .setSize(calculateButtonWidth(1),calculateButtonHeight(rowCount))
                                        .setLabel("Color")
                                        .setColorForeground(color(defaultFillColour.x, defaultFillColour.y, defaultFillColour.z))
                                        .setColorActive(color(defaultFillColour.x, defaultFillColour.y, defaultFillColour.z))
                                        .setVisible(false)
                                        .setLabelVisible(false)
                                        .setGroup(RigidbodyGeneration)
                                        ;

                        Toggle isStatic = userInterface.addToggle("isStatic")
                                        .setPosition(calculateButtonPositionX(1, calculateButtonWidth(3)), calculateButtonPositionY(7, calculateButtonHeight(rowCount)))
                                        .setSize(calculateButtonWidth(3),calculateButtonHeight(rowCount))
                                        .setLabel("Static")
                                        .setVisible(false)
                                        .setGroup(RigidbodyGeneration)
                                        .setValue(defaultIsStatic)
                                        .onChange(new CallbackListener() {
                                                public void controlEvent(CallbackEvent theEvent) {
                                                        IsStaticSelectorElementOnChange();
                                                    }
                                                })
                                            ;

                        Toggle isTranslationallyStatic = userInterface.addToggle("transStatic")
                                        .setPosition(calculateButtonPositionX(2, calculateButtonWidth(3)), calculateButtonPositionY(7, calculateButtonHeight(rowCount)))
                                        .setSize(calculateButtonWidth(3),calculateButtonHeight(rowCount))
                                        .setLabel("TransStatic")
                                        .setVisible(false)
                                        .setGroup(RigidbodyGeneration)
                                        .setValue(defaultIsTransStatic)
                                        .onChange(new CallbackListener() {
                                                public void controlEvent(CallbackEvent theEvent) {
                                                        IsTransStaticSelectorElementOnChange();
                                                    }
                                                })
                                            ;

                        Toggle isRotationallyStatic = userInterface.addToggle("rotStatic")
                                        .setPosition(calculateButtonPositionX(3, calculateButtonWidth(3)), calculateButtonPositionY(7, calculateButtonHeight(rowCount)))
                                        .setSize(calculateButtonWidth(3),calculateButtonHeight(rowCount))
                                        .setLabel("RotStatic")
                                        .setVisible(false)
                                        .setGroup(RigidbodyGeneration)
                                        .setValue(defaultIsRotStatic)
                                        .onChange(new CallbackListener() {
                                                public void controlEvent(CallbackEvent theEvent) {
                                                        IsRotStaticSelectorElementOnChange();
                                                    }
                                                })
                                            ;

                        Slider angle = userInterface.addSlider("Angle")
                                        .setPosition(calculateButtonPositionX(1, calculateButtonWidth(2)), calculateButtonPositionY(8, calculateButtonHeight(rowCount)))
                                        .setSize(calculateButtonWidth(2),calculateButtonHeight(rowCount))
                                        .setLabel("Angle")
                                        .setVisible(false)
                                        .setRange(-360, 360)
                                        .setValue(defaultAngle)
                                        .setGroup(RigidbodyGeneration)
                                        .onChange(new CallbackListener() {
                                                public void controlEvent(CallbackEvent theEvent) {

                                                       AngleSliderElementOnChange();
                                                    }
                                                })
                                            ;

                        Slider angularVelocity = userInterface.addSlider("AngularVelocity")
                                        .setPosition(calculateButtonPositionX(2, calculateButtonWidth(2)), calculateButtonPositionY(8, calculateButtonHeight(rowCount)))
                                        .setSize(calculateButtonWidth(2),calculateButtonHeight(rowCount))
                                        .setLabel("Angular Vel")
                                        .setVisible(false)
                                        .setRange(-10, 10)
                                        .setValue(defaultAngularVelocity)
                                        .setGroup(RigidbodyGeneration)
                                        .onChange(new CallbackListener() {
                                                public void controlEvent(CallbackEvent theEvent) {
                                                            
                                                        AngularVelocitySliderElementOnChange();
                                                    }
                                                })
                                        ;
                        Toggle addGravity = userInterface.addToggle("AddGravity")
                                        .setPosition(calculateButtonPositionX(1, calculateButtonWidth(2)), calculateButtonPositionY(9, calculateButtonHeight(rowCount)))
                                        .setSize(calculateButtonWidth(2),calculateButtonHeight(rowCount))
                                        .setLabel("Add Gravity")
                                        .setVisible(false)
                                        .setValue(defaultAddGravity)
                                        .setGroup(RigidbodyGeneration)
                                        .onChange(new CallbackListener() {
                                                public void controlEvent(CallbackEvent theEvent) {
                                                        AddGravitySelectorElementOnChange();
                                                    }
                                                })
                                            ;
                        Toggle isCollidable = userInterface.addToggle("IsCollidable") 
                                        .setPosition(calculateButtonPositionX(2, calculateButtonWidth(2)), calculateButtonPositionY(9, calculateButtonHeight(rowCount)))
                                        .setSize(calculateButtonWidth(2),calculateButtonHeight(rowCount))
                                        .setLabel("Collidable")
                                        .setVisible(false)
                                        .setValue(defaultIsCollidable)
                                        .setGroup(RigidbodyGeneration)
                                        .onChange(new CallbackListener() {
                                                public void controlEvent(CallbackEvent theEvent) {
                                                        IsCollidableSelectorElementOnChange();
                                                    }
                                                })
                                            ;

                        

/*----------------------------------- Forces Tab ------------------------------------------*/
            Group ForceGeneration = userInterface.addGroup("Force")
                            .setPosition(calculateGroupPositionX(), calculateGroupPositionY())
                            .setBackgroundHeight(globalGroupHeight)
                            .setBarHeight(globalGroupBarHeight)
                            .setBackgroundColor(globalGroupColor)
                            .setWidth(globalGroupWidth)
                             //.disableCollapse()
                            .setTab("Forces")
                            ;
                        Toggle addSpring = userInterface.addToggle("AddSpring")
                                        .setPosition(calculateButtonPositionX(1, calculateButtonWidth(3)), calculateButtonPositionY(1, calculateButtonHeight(rowCount)))
                                        .setSize(calculateButtonWidth(3),calculateButtonHeight(rowCount))
                                        .setLabel("Spring")
                                        .setValue(defaultSpringSelector)
                                        .setVisible(true)
                                        .setGroup(ForceGeneration)
                                        .onChange(new CallbackListener() {
                                                public void controlEvent(CallbackEvent theEvent) {
                                                        SpringForceSelectorOnChange();
                                                    }
                                                })
                                            ;
                        Toggle addRod = userInterface.addToggle("AddRod")
                                        .setPosition(calculateButtonPositionX(2, calculateButtonWidth(3)), calculateButtonPositionY(1, calculateButtonHeight(rowCount)))
                                        .setSize(calculateButtonWidth(3),calculateButtonHeight(rowCount))
                                        .setLabel("Rod")
                                        .setValue(defaultRodSelector)
                                        .setVisible(true)
                                        .setGroup(ForceGeneration)
                                        .onChange(new CallbackListener() {
                                                public void controlEvent(CallbackEvent theEvent) {
                                                        RodForceSelectorOnChange();
                                                    }
                                                })
                                            ;
                        Toggle addMotor = userInterface.addToggle("AddMotor")
                                        .setPosition(calculateButtonPositionX(3, calculateButtonWidth(3)), calculateButtonPositionY(1, calculateButtonHeight(rowCount)))
                                        .setSize(calculateButtonWidth(3),calculateButtonHeight(rowCount))
                                        .setLabel("Motor")
                                        .setValue(defaultMotorSelector)
                                        .setVisible(true)
                                        .setGroup(ForceGeneration)
                                        .onChange(new CallbackListener() {
                                                public void controlEvent(CallbackEvent theEvent) {
                                                        MotorForceSelectorOnChange();
                                                    }
                                                })
                                            ;
                        Slider springConstant = userInterface.addSlider("SpringConstant")
                                        .setPosition(calculateButtonPositionX(1, calculateButtonWidth(1)), calculateButtonPositionY(2, calculateButtonHeight(rowCount)))
                                        .setSize(calculateButtonWidth(1),calculateButtonHeight(rowCount))
                                        .setLabel("Spring Constant")
                                        .setVisible(false)
                                        .setRange(0, 300)
                                        .setValue(defaultSpringConstant)
                                        .setGroup(ForceGeneration)
                                        .onChange(new CallbackListener() {
                                                public void controlEvent(CallbackEvent theEvent) {
                                                        SpringConstantSliderElementOnChange();
                                                    }
                                                })
                                            ;
                        Slider springEquilibriumLength = userInterface.addSlider("SpringEquilibriumLength")
                                        .setPosition(calculateButtonPositionX(1, calculateButtonWidth(1)), calculateButtonPositionY(3, calculateButtonHeight(rowCount)))
                                        .setSize(calculateButtonWidth(1),calculateButtonHeight(rowCount))
                                        .setLabel("Equilibrium Length")
                                        .setVisible(false)
                                        .setRange(0, 5)
                                        .setValue(defaultSpringEquilibriumLength)
                                        .setGroup(ForceGeneration)
                                        .onChange(new CallbackListener() {
                                                public void controlEvent(CallbackEvent theEvent) {
                                                        SpringEquilibriumLengthSliderElementOnChange();
                                                    }
                                                })
                                            ;

                        Slider springDamping = userInterface.addSlider("SpringDamping")
                                        .setPosition(calculateButtonPositionX(1, calculateButtonWidth(1)), calculateButtonPositionY(4, calculateButtonHeight(rowCount)))
                                        .setSize(calculateButtonWidth(1),calculateButtonHeight(rowCount))
                                        .setLabel("Damping")
                                        .setVisible(false)
                                        .setRange(0, 1)
                                        .setValue(defaultSpringDamping)
                                        .setGroup(ForceGeneration)
                                        .onChange(new CallbackListener() {
                                                public void controlEvent(CallbackEvent theEvent) {
                                                        SpringDampingSliderElementOnChange();
                                                    }
                                                })
                                            ;

                        Toggle springLockToX = userInterface.addToggle("SpringLockToX")
                                        .setPosition(calculateButtonPositionX(1, calculateButtonWidth(1)), calculateButtonPositionY(5, calculateButtonHeight(rowCount)))
                                        .setSize(calculateButtonWidth(1),calculateButtonHeight(rowCount))
                                        .setLabel("Lock translation to x-axis")
                                        .setVisible(false)
                                        .setValue(defaultLockToXAxis)
                                        .setGroup(ForceGeneration)
                                        .onChange(new CallbackListener() {
                                                public void controlEvent(CallbackEvent theEvent) {
                                                        SpringLockToXSelectorElementOnChange();
                                                    }
                                                })
                                            ;
                        Toggle springLockToY = userInterface.addToggle("SpringLockToY")
                                        .setPosition(calculateButtonPositionX(1, calculateButtonWidth(1)), calculateButtonPositionY(6, calculateButtonHeight(rowCount)))
                                        .setSize(calculateButtonWidth(1),calculateButtonHeight(rowCount))
                                        .setLabel("Lock translation to y-axis")
                                        .setVisible(false)
                                        .setValue(defaultLockToYAxis)
                                        .setGroup(ForceGeneration)
                                        .onChange(new CallbackListener() {
                                                public void controlEvent(CallbackEvent theEvent) {
                                                        SpringLockToYSelectorElementOnChange();
                                                    }
                                                })
                                            ;
                        Toggle springIsPerfect = userInterface.addToggle("SpringIsPerfect")
                                        .setPosition(calculateButtonPositionX(1, calculateButtonWidth(1)), calculateButtonPositionY(7, calculateButtonHeight(rowCount)))
                                        .setSize(calculateButtonWidth(1),calculateButtonHeight(rowCount))
                                        .setLabel("Perfect Spring")
                                        .setVisible(false)
                                        .setValue(defaultSpringIsPerfect)
                                        .setGroup(ForceGeneration)
                                        .onChange(new CallbackListener() {
                                                public void controlEvent(CallbackEvent theEvent) {
                                                        SpringIsPerfectSelectorElementOnChange();
                                                    }
                                                })
                                            ;
                        Toggle springSnapToCenter = userInterface.addToggle("SpringSnapToCenter")
                                        .setPosition(calculateButtonPositionX(1, calculateButtonWidth(2)), calculateButtonPositionY(8, calculateButtonHeight(rowCount)))
                                        .setSize(calculateButtonWidth(2),calculateButtonHeight(rowCount))
                                        .setLabel("Snap to Center")
                                        .setVisible(false)
                                        .setValue(defaultSnapToCenter)
                                        .setGroup(ForceGeneration)
                                        .onChange(new CallbackListener() {
                                                public void controlEvent(CallbackEvent theEvent) {
                                                        SpringSnapToCenterSelectorElementOnChange();
                                                    }
                                                })
                                            ;

                        Toggle springSnapToEdge = userInterface.addToggle("SpringSnapToEdge")
                                        .setPosition(calculateButtonPositionX(2, calculateButtonWidth(2)), calculateButtonPositionY(8, calculateButtonHeight(rowCount)))
                                        .setSize(calculateButtonWidth(2),calculateButtonHeight(rowCount))
                                        .setLabel("Snap to Edge")
                                        .setVisible(false)
                                        .setValue(defaultSnapToEdge)
                                        .setGroup(ForceGeneration)
                                        .onChange(new CallbackListener() {
                                                public void controlEvent(CallbackEvent theEvent) {
                                                        SpringSnapToEdgeSelectorElementOnChange();
                                                    }
                                                })
                                            ;
                        Toggle rodSnapToCenter = userInterface.addToggle("RodSnapToCenter")
                                        .setPosition(calculateButtonPositionX(1, calculateButtonWidth(3)), calculateButtonPositionY(2, calculateButtonHeight(rowCount)))
                                        .setSize(calculateButtonWidth(3),calculateButtonHeight(rowCount))
                                        .setLabel("Snap to Center")
                                        .setVisible(false)
                                        .setValue(defaultSnapToCenter)
                                        .setGroup(ForceGeneration)
                                        .onChange(new CallbackListener() {
                                                public void controlEvent(CallbackEvent theEvent) {
                                                        RodSnapToCenterSelectorElementOnChange();
                                                    }
                                                })
                                            ;

                        Toggle rodSnapToEdge = userInterface.addToggle("RodSnapToEdge")
                                        .setPosition(calculateButtonPositionX(2, calculateButtonWidth(3)), calculateButtonPositionY(2, calculateButtonHeight(rowCount)))
                                        .setSize(calculateButtonWidth(3),calculateButtonHeight(rowCount))
                                        .setLabel("Snap to Edge")
                                        .setVisible(false)
                                        .setValue(defaultSnapToEdge)
                                        .setGroup(ForceGeneration)
                                        .onChange(new CallbackListener() {
                                                public void controlEvent(CallbackEvent theEvent) {
                                                        RodSnapToEdgeSelectorElementOnChange();
                                                    }
                                                })
                                            ;
                        Toggle rodIsJoint = userInterface.addToggle("RodIsJoint")
                                        .setPosition(calculateButtonPositionX(3, calculateButtonWidth(3)), calculateButtonPositionY(2, calculateButtonHeight(rowCount)))
                                        .setSize(calculateButtonWidth(3),calculateButtonHeight(rowCount))
                                        .setLabel("Joint")
                                        .setVisible(false)
                                        .setValue(defaultRodIsJoint)
                                        .setGroup(ForceGeneration)
                                        .onChange(new CallbackListener() {
                                                public void controlEvent(CallbackEvent theEvent) {
                                                        RodIsJointSelectorElementOnChange();
                                                    }
                                                })
                                            ;


                        Slider motorTargetAngularVelocity = userInterface.addSlider("MotorTargetAngularVelocity")
                                        .setPosition(calculateButtonPositionX(1, calculateButtonWidth(1)), calculateButtonPositionY(2, calculateButtonHeight(rowCount)))
                                        .setSize(calculateButtonWidth(1),calculateButtonHeight(rowCount))
                                        .setLabel("Target Angular Velocity")
                                        .setVisible(false)
                                        .setRange(-10, 10)
                                        .setValue(defaultMotorTargetAngularVelocity)
                                        .setGroup(ForceGeneration)
                                        .onChange(new CallbackListener() {
                                                public void controlEvent(CallbackEvent theEvent) {
                                                        MotorTargetAngularVelocitySliderElementOnChange();
                                                    }
                                                })
                                            ;
                        Toggle motorDrawMotor = userInterface.addToggle("MotorDrawMotor")
                                        .setPosition(calculateButtonPositionX(1, calculateButtonWidth(2)), calculateButtonPositionY(3, calculateButtonHeight(rowCount)))
                                        .setSize(calculateButtonWidth(2),calculateButtonHeight(rowCount))
                                        .setLabel("Draw Motor")
                                        .setVisible(false)
                                        .setValue(defaultMotorDrawMotor)
                                        .setGroup(ForceGeneration)
                                        .onChange(new CallbackListener() {
                                                public void controlEvent(CallbackEvent theEvent) {
                                                        MotorDrawMotorSelectorElementOnChange();
                                                    }
                                                })
                                            ;
                        Toggle motorDrawMotorForce = userInterface.addToggle("MotorDrawMotorForce")
                                        .setPosition(calculateButtonPositionX(2, calculateButtonWidth(2)), calculateButtonPositionY(3, calculateButtonHeight(rowCount)))
                                        .setSize(calculateButtonWidth(2),calculateButtonHeight(rowCount))
                                        .setLabel("Draw Motor Force")
                                        .setVisible(false)
                                        .setValue(defaultMotorDrawMotorForce)
                                        .setGroup(ForceGeneration)
                                        .onChange(new CallbackListener() {
                                                public void controlEvent(CallbackEvent theEvent) {
                                                        MotorDrawMotorForceSelectorElementOnChange();
                                                    }
                                                })
                                            ;
/*------------------------------------ Debug Tab ----------------------------------------------- */
                Group DebugGroup = userInterface.addGroup("DebugGroup")
                        .setPosition(calculateGroupPositionX(), calculateGroupPositionY())
                        .setBackgroundHeight(globalGroupHeight)
                        .setBarHeight(globalGroupBarHeight)
                        .setBackgroundColor(globalGroupColor)
                        .setWidth(globalGroupWidth)
                        .setLabel("Debug")
                         //.disableCollapse()
                        .setTab("Debug")
                        ;

                        Slider subStepCount = userInterface.addSlider("SubStepCount")
                                        .setPosition(calculateButtonPositionX(1, calculateButtonWidth(1)), calculateButtonPositionY(1, calculateButtonHeight(rowCount)))
                                        .setSize(calculateButtonWidth(1), calculateButtonHeight(rowCount))
                                        .setLabel("Substep Count")
                                        .setVisible(true)
                                        .setRange(0, 1024)
                                        .setValue(128)
                                        .setNumberOfTickMarks(17)
                                        .setSliderMode(Slider.FLEXIBLE)
                                        .setGroup(DebugGroup)
                                        .onChange(new CallbackListener() {
                                                public void controlEvent(CallbackEvent theEvent) {
                                                        SUB_STEP_COUNT = (int) userInterface.getController("SubStepCount").getValue();
                                                    }
                                                })
                                            ;
                        Toggle drawContactPoints = userInterface.addToggle("drawContactPoints")
                                        .setPosition(calculateButtonPositionX(1, calculateButtonWidth(2)), calculateButtonPositionY(2, calculateButtonHeight(rowCount)))
                                        .setSize(calculateButtonWidth(2), calculateButtonHeight(rowCount))
                                        .setLabel("Draw Contact Points")
                                        .setVisible(true)
                                        .setValue(false)
                                        .setGroup(DebugGroup)
                                        .onChange(new CallbackListener() {
                                                public void controlEvent(CallbackEvent theEvent) {
                                                       DRAW_CONTACT_POINTS = !DRAW_CONTACT_POINTS;
                                                    }
                                                })
                                            ;

                        Toggle drawABBs = userInterface.addToggle("drawAABBs")
                                        .setPosition(calculateButtonPositionX(2, calculateButtonWidth(2)), calculateButtonPositionY(2, calculateButtonHeight(rowCount)))
                                        .setSize(calculateButtonWidth(2), calculateButtonHeight(rowCount))
                                        .setLabel("Draw AABB's")
                                        .setVisible(true)
                                        .setValue(false)
                                        .setGroup(DebugGroup)
                                        .onChange(new CallbackListener() {
                                                public void controlEvent(CallbackEvent theEvent) {
                                                       DRAW_AABBS = !DRAW_AABBS;
                                                    }
                                                })
                                            ;





/*
====================================================================================================
======================================== Formatting ================================================
====================================================================================================
*/

userInterface.getController("Circle").getCaptionLabel().align(ControlP5.CENTER, ControlP5.CENTER);
userInterface.getController("Box").getCaptionLabel().align(ControlP5.CENTER, ControlP5.CENTER);

userInterface.getController("RectangleWidth").getCaptionLabel().align(ControlP5.CENTER, ControlP5.CENTER);
userInterface.getController("RectangleHeight").getCaptionLabel().align(ControlP5.CENTER, ControlP5.CENTER);
userInterface.getController("CircleRadius").getCaptionLabel().align(ControlP5.CENTER, ControlP5.CENTER);

userInterface.getController("Density").getCaptionLabel().align(ControlP5.CENTER, ControlP5.CENTER);
userInterface.getController("Restitution").getCaptionLabel().align(ControlP5.CENTER, ControlP5.CENTER);

userInterface.getController("StrokeWeight").getCaptionLabel().align(ControlP5.RIGHT, ControlP5.CENTER);
userInterface.getController("FillColour").getCaptionLabel().align(ControlP5.CENTER, ControlP5.CENTER);
userInterface.getController("StrokeColour").getCaptionLabel().align(ControlP5.CENTER, ControlP5.CENTER);

userInterface.getController("RedStroke").getCaptionLabel().align(ControlP5.RIGHT, ControlP5.CENTER);
userInterface.getController("GreenStroke").getCaptionLabel().align(ControlP5.RIGHT, ControlP5.CENTER);
userInterface.getController("BlueStroke").getCaptionLabel().align(ControlP5.RIGHT, ControlP5.CENTER);

userInterface.getController("RedFill").getCaptionLabel().align(ControlP5.RIGHT, ControlP5.CENTER);
userInterface.getController("GreenFill").getCaptionLabel().align(ControlP5.RIGHT, ControlP5.CENTER);
userInterface.getController("BlueFill").getCaptionLabel().align(ControlP5.RIGHT, ControlP5.CENTER);

userInterface.getController("ColorBox").getCaptionLabel().align(ControlP5.RIGHT, ControlP5.CENTER);

userInterface.getController("isStatic").getCaptionLabel().align(ControlP5.CENTER, ControlP5.CENTER);
userInterface.getController("transStatic").getCaptionLabel().align(ControlP5.CENTER, ControlP5.CENTER);
userInterface.getController("rotStatic").getCaptionLabel().align(ControlP5.CENTER, ControlP5.CENTER);

userInterface.getController("Angle").getCaptionLabel().align(ControlP5.RIGHT, ControlP5.CENTER);
userInterface.getController("AngularVelocity").getCaptionLabel().align(ControlP5.RIGHT, ControlP5.CENTER);

userInterface.getController("AddGravity").getCaptionLabel().align(ControlP5.RIGHT, ControlP5.CENTER);
userInterface.getController("IsCollidable").getCaptionLabel().align(ControlP5.RIGHT, ControlP5.CENTER);

userInterface.getController("AddSpring").getCaptionLabel().align(ControlP5.CENTER, ControlP5.CENTER);
userInterface.getController("AddRod").getCaptionLabel().align(ControlP5.CENTER, ControlP5.CENTER);
userInterface.getController("AddMotor").getCaptionLabel().align(ControlP5.CENTER, ControlP5.CENTER);

userInterface.getController("SpringConstant").getCaptionLabel().align(ControlP5.RIGHT, ControlP5.CENTER);
userInterface.getController("SpringEquilibriumLength").getCaptionLabel().align(ControlP5.RIGHT, ControlP5.CENTER);
userInterface.getController("SpringDamping").getCaptionLabel().align(ControlP5.RIGHT, ControlP5.CENTER);

userInterface.getController("SpringLockToX").getCaptionLabel().align(ControlP5.CENTER, ControlP5.CENTER);
userInterface.getController("SpringLockToY").getCaptionLabel().align(ControlP5.CENTER, ControlP5.CENTER);

userInterface.getController("SpringIsPerfect").getCaptionLabel().align(ControlP5.CENTER, ControlP5.CENTER);
userInterface.getController("SpringSnapToCenter").getCaptionLabel().align(ControlP5.CENTER, ControlP5.CENTER);
userInterface.getController("SpringSnapToEdge").getCaptionLabel().align(ControlP5.CENTER, ControlP5.CENTER);

userInterface.getController("RodSnapToCenter").getCaptionLabel().align(ControlP5.CENTER, ControlP5.CENTER);
userInterface.getController("RodSnapToEdge").getCaptionLabel().align(ControlP5.CENTER, ControlP5.CENTER);
userInterface.getController("RodIsJoint").getCaptionLabel().align(ControlP5.CENTER, ControlP5.CENTER);

userInterface.getController("MotorTargetAngularVelocity").getCaptionLabel().align(ControlP5.RIGHT, ControlP5.CENTER);
userInterface.getController("MotorDrawMotor").getCaptionLabel().align(ControlP5.CENTER, ControlP5.CENTER);
userInterface.getController("MotorDrawMotorForce").getCaptionLabel().align(ControlP5.CENTER, ControlP5.CENTER);


userInterface.getController("SubStepCount").getCaptionLabel().align(ControlP5.RIGHT, ControlP5.CENTER);
userInterface.getController("drawContactPoints").getCaptionLabel().align(ControlP5.CENTER, ControlP5.CENTER);
userInterface.getController("drawAABBs").getCaptionLabel().align(ControlP5.CENTER, ControlP5.CENTER);






userInterface.getTab("default").hide();

    }

/*
====================================================================================================
======================================== Helper Methods ============================================
====================================================================================================
*/
   public int calculateButtonWidth(int buttonCount) {
        return (globalGroupWidth - 2 * globalGroupPaddingX - (buttonCount - 1) * globalInterElementPaddingX) / buttonCount;
     }

    public int calculateButtonHeight(int rowCount) {
     rowCount--;
    return (globalGroupHeight - 2 * globalGroupPaddingY - (rowCount - 1) * globalInterElementPaddingY) / rowCount;
    }

    public int calculateButtonPositionX(int buttonNumber, int buttonWidth) {
     buttonNumber--;
     return  globalGroupPaddingX + buttonNumber * (buttonWidth + globalInterElementPaddingX);
    }
    public int calculateButtonPositionY(int rowNumber, int buttonHeight) {
     rowNumber--;
     return globalGroupPaddingX + rowNumber * (buttonHeight + globalInterElementPaddingY);
    }

    public int calculateGroupPositionX() {
     return width - globalGroupWidth - globalScreenGroupPaddingX;
    }
    public int calculateGroupPositionY() {
     return globalScreenGroupPaddingY;
    }

    public void getActiveTab() {
        if(userInterface.getTab("default").isActive()) {
            interactivityListener.setGenerateRigidbodies(false);
            interactivityListener.setGenerateForces(false);
        } else if(userInterface.getTab("Rigidbodies").isActive()) {
            interactivityListener.setGenerateRigidbodies(true);
            interactivityListener.setGenerateForces(false);
        } else if(userInterface.getTab("Forces").isActive()) {
            interactivityListener.setGenerateRigidbodies(false);
            interactivityListener.setGenerateForces(true);
        }
    }

/*
====================================================================================================
======================================= Element Interactivity ======================================
====================================================================================================
*/
/*--------------------------------- Rigidbodies Tab ----------------------------------------------*/
/*------------------------------ Global Shape Selector Methods -----------------------------------*/
private void ShapeSelectorElementOnSelect() {

    interactivityListener.setGenerateRigidbodies(true);
    interactivityListener.setGenerateForces(false);


    userInterface.getController("Density").setVisible(true);
    userInterface.getController("Restitution").setVisible(true);

    if(isFillColourSelectedDefault) {
        userInterface.getController("RedFill").setVisible(true);
        userInterface.getController("GreenFill").setVisible(true);
        userInterface.getController("BlueFill").setVisible(true);

        userInterface.getController("RedStroke").setVisible(false);
        userInterface.getController("GreenStroke").setVisible(false);
        userInterface.getController("BlueStroke").setVisible(false);
           
        //Default enabled color selector
        userInterface.getController("FillColour").setValue(1);
    } else {
        userInterface.getController("RedFill").setVisible(false);
        userInterface.getController("GreenFill").setVisible(false);
        userInterface.getController("BlueFill").setVisible(false);

        userInterface.getController("RedStroke").setVisible(true);
        userInterface.getController("GreenStroke").setVisible(true);
        userInterface.getController("BlueStroke").setVisible(true);
            
        //Default enabled color selector
        userInterface.getController("StrokeColour").setValue(1);
    }

    userInterface.getController("ColorBox").setVisible(true);

    userInterface.getController("FillColour").setVisible(true);
    userInterface.getController("StrokeColour").setVisible(true);
    userInterface.getController("StrokeWeight").setVisible(true);
                                                            
    userInterface.getController("isStatic").setVisible(true);
    userInterface.getController("transStatic").setVisible(true);
    userInterface.getController("rotStatic").setVisible(true);

    userInterface.getController("Angle").setVisible(true);
    userInterface.getController("AngularVelocity").setVisible(true);
    userInterface.getController("AddGravity").setVisible(true);
    userInterface.getController("IsCollidable").setVisible(true);
    
}

private void ShapeSelectorElementOnDeselect() {

    userInterface.getController("RectangleWidth").setVisible(false);
    userInterface.getController("RectangleHeight").setVisible(false);

    userInterface.getController("CircleRadius").setVisible(false);

    userInterface.getController("Density").setVisible(false);
    userInterface.getController("Restitution").setVisible(false);

    userInterface.getController("RedFill").setVisible(false);
    userInterface.getController("GreenFill").setVisible(false);
    userInterface.getController("BlueFill").setVisible(false);

    userInterface.getController("RedStroke").setVisible(false);
    userInterface.getController("GreenStroke").setVisible(false);
    userInterface.getController("BlueStroke").setVisible(false);

    userInterface.getController("ColorBox").setVisible(false);

    userInterface.getController("StrokeWeight").setVisible(false);
    userInterface.getController("FillColour").setVisible(false);
    userInterface.getController("StrokeColour").setVisible(false);

    userInterface.getController("isStatic").setVisible(false);
    userInterface.getController("transStatic").setVisible(false);
    userInterface.getController("rotStatic").setVisible(false);

    userInterface.getController("Angle").setVisible(false);
    userInterface.getController("AngularVelocity").setVisible(false);

    userInterface.getController("AddGravity").setVisible(false);
    userInterface.getController("IsCollidable").setVisible(false);
}

/*-------------------------------- Global Colouring Element Methods ------------------------------*/
 private void ColouringElementOnDeselect() {
     if(userInterface.getController("FillColour").getValue() == 0
     && userInterface.getController("StrokeColour").getValue() == 0){
         
        userInterface.getController("RedFill").setVisible(false);
        userInterface.getController("GreenFill").setVisible(false);
        userInterface.getController("BlueFill").setVisible(false);

        userInterface.getController("RedStroke").setVisible(false);
        userInterface.getController("GreenStroke").setVisible(false);
        userInterface.getController("BlueStroke").setVisible(false);

        userInterface.getController("ColorBox").setVisible(false);
     }
 }

/* --------------------------------- Circle Shape Selector Element -------------------------------*/

private void CircleShapeSelectorOnChange() {
    if(userInterface.getController("Circle").getValue() == 1){
        ShapeSelectorElementOnSelect();
        CircleShapeSelectorElementOnSelect();
        CircleShapeSelectorInteractivityListener();

    } else if(userInterface.getController("Circle").getValue() == 0
            && userInterface.getController("Box").getValue() == 0){
        
        ShapeSelectorElementOnDeselect();
    }
}

private void CircleShapeSelectorElementOnSelect() {

    userInterface.getController("Box").setValue(0);

    userInterface.getController("RectangleWidth").setVisible(false);
    userInterface.getController("RectangleHeight").setVisible(false);
    userInterface.getController("CircleRadius").setVisible(true);
}

private void CircleShapeSelectorInteractivityListener() {

    interactivityListener.setShapeType(ShapeType.CIRCLE);
}

/* --------------------------------- Rectangle Shape Selector Element ----------------------------*/
private void RectangleShapeSelectorOnChange() {
    if(userInterface.getController("Box").getValue() == 1){
        
        ShapeSelectorElementOnSelect();
        RectangleShapeSelectorElementOnSelect();
        RectangleShapeSelectorElementInteractivityListener();

    } else if(userInterface.getController("Circle").getValue() == 0
            && userInterface.getController("Box").getValue() == 0){
        
        ShapeSelectorElementOnDeselect();
    }
}
private void RectangleShapeSelectorElementOnSelect() {

    userInterface.getController("Circle").setValue(0);

    userInterface.getController("RectangleWidth").setVisible(true);
    userInterface.getController("RectangleHeight").setVisible(true);


    userInterface.getController("CircleRadius").setVisible(false);
}


private void RectangleShapeSelectorElementInteractivityListener() {

    interactivityListener.setShapeType(ShapeType.BOX);

}

/*-------------------------------------- Density Element -----------------------------------------*/
private void DensityElementOnChange() {

    float density = userInterface.getController("Density").getValue();
    interactivityListener.setDensity(density);
}

/*-------------------------------------- Restitution Element -------------------------------------*/
private void RestitutionElementOnChange() {

    float restitution = userInterface.getController("Restitution").getValue();
    interactivityListener.setRestitution(restitution);
}

/*-------------------------------------- Box Width Element ---------------------------------------*/
private void RectangleWidthElementOnChange() {
    if(userInterface.getController("Box").getValue() == 1){

        float width = userInterface.getController("RectangleWidth").getValue();
        interactivityListener.setWidth(width);
    }
}

/*-------------------------------------- Box Height Element --------------------------------------*/
private void RectangleHeightElementOnChange() {
    if(userInterface.getController("Box").getValue() == 1) {

        float height = userInterface.getController("RectangleHeight").getValue();
        interactivityListener.setHeight(height);
    }
}

/*-------------------------------------- Circle Radius Element -----------------------------------*/
private void CircleRadiusElementOnChange() {
    if(userInterface.getController("Circle").getValue() == 1) {

        float radius = userInterface.getController("CircleRadius").getValue();
        interactivityListener.setRadius(radius);
    }
}

/*--------------------------------- Fill Colour Selector Element ---------------------------------*/
private void FillColourSelectorOnChange() {
    if(userInterface.getController("FillColour").getValue() == 1) {

        FillColourElementOnSelect();
    } else if (userInterface.getController("FillColour").getValue() == 0
            && userInterface.getController("StrokeColour").getValue() == 0) {
                
                ColouringElementOnDeselect();
    }
}

private void FillColourElementOnSelect() {

        userInterface.getController("StrokeColour").setValue(0);

        userInterface.getController("RedFill").setVisible(true);
        userInterface.getController("GreenFill").setVisible(true);
        userInterface.getController("BlueFill").setVisible(true);

        userInterface.getController("RedStroke").setVisible(false);
        userInterface.getController("GreenStroke").setVisible(false);
        userInterface.getController("BlueStroke").setVisible(false);

        userInterface.getController("ColorBox").setVisible(true);
}

/*--------------------------------- Stroke Colour Selector Element -------------------------------*/
private void StrokeColourSelectorOnChange() {

    if(userInterface.getController("StrokeColour").getValue() == 1) {

        StrokeColourElementOnSelect();
    } else if (userInterface.getController("FillColour").getValue() == 0
            && userInterface.getController("StrokeColour").getValue() == 0) {

                ColouringElementOnDeselect();
    }
}

private void StrokeColourElementOnSelect() {

    userInterface.getController("FillColour").setValue(0);

    userInterface.getController("RedStroke").setVisible(true);
    userInterface.getController("GreenStroke").setVisible(true);
    userInterface.getController("BlueStroke").setVisible(true);

    userInterface.getController("RedFill").setVisible(false);
    userInterface.getController("GreenFill").setVisible(false);
    userInterface.getController("BlueFill").setVisible(false);
    userInterface.getController("ColorBox").setVisible(true);
}

/*--------------------------------- Fill Slider Elements -----------------------------------------*/
private void FillSliderElementOnChange() {

    int red = (int)userInterface.getController("RedFill").getValue();
    int green = (int)userInterface.getController("GreenFill").getValue();
    int blue = (int)userInterface.getController("BlueFill").getValue();

    userInterface.getController("ColorBox").setColorForeground(color(red, green, blue));
    userInterface.getController("ColorBox").setColorActive(color(red, green, blue));

    interactivityListener.setFillColor(new PVector(red, green, blue));
}

/*--------------------------------- Stroke Slider Elements ------------------------------------*/
private void StrokeSliderElementOnChange() {

    int red = (int)userInterface.getController("RedStroke").getValue();
    int green = (int)userInterface.getController("GreenStroke").getValue();
    int blue = (int)userInterface.getController("BlueStroke").getValue();
    
    userInterface.getController("ColorBox").setColorForeground(color(red, green, blue));
    userInterface.getController("ColorBox").setColorActive(color(red, green, blue));
    interactivityListener.setStrokeColor(new PVector(red, green, blue));
}


/*--------------------------------- Stroke Weight Slider Element ---------------------------------*/
private void StrokeWeightElementOnChange() {

    float strokeWeight = userInterface.getController("StrokeWeight").getValue();
    interactivityListener.setStrokeWeight(strokeWeight);
}

/*--------------------------------- IsStatic Selector Element ------------------------------------*/
private void IsStaticSelectorElementOnChange() {

     if(userInterface.getController("isStatic").getValue() == 1){
        
        userInterface.getController("transStatic").setValue(0);
        userInterface.getController("rotStatic").setValue(0);

        interactivityListener.setIsTranslationallyStatic(false);
        interactivityListener.setIsRotationallyStatic(false);

        interactivityListener.setIsStatic(true);

    }
    else {

        interactivityListener.setIsStatic(false);
    }
}
/*--------------------------------- IsTransStatic Selector Element --------------------------------*/
private void IsTransStaticSelectorElementOnChange() {

    if(userInterface.getController("transStatic").getValue() == 1){

        userInterface.getController("rotStatic").setValue(0);
        userInterface.getController("isStatic").setValue(0);

        interactivityListener.setIsStatic(false);
        interactivityListener.setIsRotationallyStatic(false);

        interactivityListener.setIsTranslationallyStatic(true);

    } else {
        
        interactivityListener.setIsTranslationallyStatic(false);
    }
}

/*--------------------------------- IsRotStatic Selector Element ----------------------------------*/
private void IsRotStaticSelectorElementOnChange() {

    if(userInterface.getController("rotStatic").getValue() == 1){

        userInterface.getController("transStatic").setValue(0);
        userInterface.getController("isStatic").setValue(0);

        interactivityListener.setIsTranslationallyStatic(false);
        interactivityListener.setIsStatic(false);

        interactivityListener.setIsRotationallyStatic(true);

    } else {
        
        interactivityListener.setIsRotationallyStatic(false);
    }
}

/*--------------------------------- Angle Slider Element -----------------------------------------*/
private void AngleSliderElementOnChange() {

    float angle = userInterface.getController("Angle").getValue();
    interactivityListener.setAngle(radians(angle));
}

/*--------------------------------- Angular Velocity Slider Element -------------------------------*/
private void AngularVelocitySliderElementOnChange() {

    float angularVelocity = userInterface.getController("AngularVelocity").getValue();
    interactivityListener.setAngularVelocity(angularVelocity);
}
/*--------------------------------- Add Gravity Selector Element ----------------------------------*/
private void AddGravitySelectorElementOnChange() {
    
        if(userInterface.getController("AddGravity").getValue() == 1) {
    
            interactivityListener.setAddGravity(true);
        } else {
    
            interactivityListener.setAddGravity(false);
        }
}
/*--------------------------------- IsCollidable Selector Element ---------------------------------*/
private void IsCollidableSelectorElementOnChange() {

        if(userInterface.getController("IsCollidable").getValue() == 1) {
                interactivityListener.setCollidability(true);
        } else {
                interactivityListener.setCollidability(false);
        }
}

/*--------------------------------- Forces Tab ---------------------------------------------------*/

private void ForceSelectorElementDeselect() {

    /*-------------------------------- Spring Elements -----------------------------------*/
    userInterface.getController("SpringConstant").setVisible(false);
    userInterface.getController("SpringEquilibriumLength").setVisible(false);
    userInterface.getController("SpringDamping").setVisible(false);

    userInterface.getController("SpringLockToX").setVisible(false);
    userInterface.getController("SpringLockToY").setVisible(false);

    userInterface.getController("SpringIsPerfect").setVisible(false);

    userInterface.getController("SpringSnapToCenter").setVisible(false);
    userInterface.getController("SpringSnapToEdge").setVisible(false);

    /*-------------------------------- Rod Elements --------------------------------------*/
    userInterface.getController("RodSnapToCenter").setVisible(false);
    userInterface.getController("RodSnapToEdge").setVisible(false);
    userInterface.getController("RodIsJoint").setVisible(false);


    /*-------------------------------- Motor Elements ------------------------------------*/
    userInterface.getController("MotorTargetAngularVelocity").setVisible(false);
    userInterface.getController("MotorDrawMotor").setVisible(false);
    userInterface.getController("MotorDrawMotorForce").setVisible(false);

}
/*--------------------------------- Spring Force Selector Element --------------------------------*/
private void SpringForceSelectorOnChange() {
    if(userInterface.getController("AddSpring").getValue() == 1) {

        ForceSelectorElementDeselect();
        interactivityListener.setForceType(ForceType.SPRING);
        interactivityListener.setGenerateRigidbodies(false);
        interactivityListener.setGenerateForces(true);

        userInterface.getController("AddRod").setValue(0);
        userInterface.getController("AddMotor").setValue(0);

        userInterface.getController("SpringConstant").setVisible(true);
        userInterface.getController("SpringEquilibriumLength").setVisible(true);
        userInterface.getController("SpringDamping").setVisible(true);

        userInterface.getController("SpringLockToX").setVisible(true);
        userInterface.getController("SpringLockToY").setVisible(true);

        userInterface.getController("SpringIsPerfect").setVisible(true);

        userInterface.getController("SpringSnapToCenter").setVisible(true);
        userInterface.getController("SpringSnapToEdge").setVisible(true);


    } else if(userInterface.getController("AddSpring").getValue() == 0 && userInterface.getController("AddRod").getValue() == 0 && userInterface.getController("AddMotor").getValue() == 0) {

            ForceSelectorElementDeselect();
            interactivityListener.setGenerateRigidbodies(false);
            interactivityListener.setGenerateForces(false);
    }
}
/*--------------------------------- Rod Force Selector Element -----------------------------------*/
private void RodForceSelectorOnChange() {

        if(userInterface.getController("AddRod").getValue() == 1) {
        
        ForceSelectorElementDeselect();
        interactivityListener.setForceType(ForceType.ROD);
        interactivityListener.setGenerateRigidbodies(false);
        interactivityListener.setGenerateForces(true);

        userInterface.getController("AddSpring").setValue(0);
        userInterface.getController("AddMotor").setValue(0);

        userInterface.getController("RodSnapToCenter").setVisible(true);
        userInterface.getController("RodSnapToEdge").setVisible(true);
        userInterface.getController("RodIsJoint").setVisible(true);

    } else if(userInterface.getController("AddSpring").getValue() == 0 && userInterface.getController("AddRod").getValue() == 0 && userInterface.getController("AddMotor").getValue() == 0) {

            ForceSelectorElementDeselect();
            interactivityListener.setGenerateRigidbodies(false);
            interactivityListener.setGenerateForces(false);
    }
}
/*--------------------------------- Motor Force Selector Element ---------------------------------*/
private void MotorForceSelectorOnChange() {
    if(userInterface.getController("AddMotor").getValue() == 1) {

        ForceSelectorElementDeselect();
        interactivityListener.setForceType(ForceType.MOTOR);
        interactivityListener.setGenerateRigidbodies(false);
        interactivityListener.setGenerateForces(true);

        interactivityListener.setSnapToCenter(true);
        interactivityListener.setSnapToEdge(false);

        userInterface.getController("AddSpring").setValue(0);
        userInterface.getController("AddRod").setValue(0);

        userInterface.getController("MotorTargetAngularVelocity").setVisible(true);
        userInterface.getController("MotorDrawMotor").setVisible(true);
        userInterface.getController("MotorDrawMotorForce").setVisible(true);

    } else if(userInterface.getController("AddSpring").getValue() == 0 && userInterface.getController("AddRod").getValue() == 0 && userInterface.getController("AddMotor").getValue() == 0) {
            ForceSelectorElementDeselect();
            interactivityListener.setGenerateRigidbodies(false);
            interactivityListener.setGenerateForces(false);
    }

}
/*--------------------------------- Spring Constant Slider Element --------------------------------*/
private void SpringConstantSliderElementOnChange() {
    float springConstant = userInterface.getController("SpringConstant").getValue();
    interactivityListener.setSpringConstant(springConstant);
}
/*--------------------------------- Spring Equilibrium Length Slider Element ----------------------*/
private void SpringEquilibriumLengthSliderElementOnChange() {
    float springEquilibriumLength = userInterface.getController("SpringEquilibriumLength").getValue();
    interactivityListener.setSpringEquilibriumLength(springEquilibriumLength);
}
/*--------------------------------- Spring Damping Slider Element --------------------------------*/
private void SpringDampingSliderElementOnChange() {
    float springDamping = userInterface.getController("SpringDamping").getValue();
    interactivityListener.setSpringDamping(springDamping);
}
/*--------------------------------- Spring Lock To X Selector Element -----------------------------*/
private void SpringLockToXSelectorElementOnChange() {
    boolean lockToX = userInterface.getController("SpringLockToX").getValue() == 1 ? true : false;
    interactivityListener.setLockToXAxis(lockToX);
}
/*--------------------------------- Spring Lock To Y Selector Element -----------------------------*/
private void SpringLockToYSelectorElementOnChange() {
    boolean lockToY = userInterface.getController("SpringLockToY").getValue() == 1 ? true : false;
    interactivityListener.setLockToYAxis(lockToY);
}

/*--------------------------------- Spring Is Perfect Selector Element ----------------------------*/
private void SpringIsPerfectSelectorElementOnChange() {
    boolean isPerfect = userInterface.getController("SpringIsPerfect").getValue() == 1 ? true : false;
    interactivityListener.setSpringIsPerfect(isPerfect);
}

/*--------------------------------- Spring Is Hingeable Selector Element --------------------------*/
private void SpringIsHingeableSelectorElementOnChange() {
    boolean isHingeable = userInterface.getController("SpringIsHingeable").getValue() == 1 ? true : false;
    interactivityListener.setSpringIsHingeable(isHingeable);
}
/*--------------------------------- Spring Snap To Center Selector Element ------------------------*/
private void SpringSnapToCenterSelectorElementOnChange() {
    if(userInterface.getController("SpringSnapToCenter").getValue() == 1) {
        userInterface.getController("SpringSnapToEdge").setValue(0);
    }
    boolean snapToCenter = userInterface.getController("SpringSnapToCenter").getValue() == 1 ? true : false;
    interactivityListener.setSnapToCenter(snapToCenter);
}

/*--------------------------------- Spring Snap To Edge Selector Element --------------------------*/
private void SpringSnapToEdgeSelectorElementOnChange() {

    if(userInterface.getController("SpringSnapToEdge").getValue() == 1) {
        userInterface.getController("SpringSnapToCenter").setValue(0);
    }
    boolean snapToEdge = userInterface.getController("SpringSnapToEdge").getValue() == 1 ? true : false;
    interactivityListener.setSnapToEdge(snapToEdge);
}



/*--------------------------------- Rod Is Hingeable Selector Element -----------------------------*/
private void RodIsHingeableSelectorElementOnChange() {
    boolean isHingeable = userInterface.getController("RodIsHingeable").getValue() == 1 ? true : false;
    interactivityListener.setRodIsHingeable(isHingeable);
}

/*--------------------------------- Rod Snap To Center Selector Element ---------------------------*/
private void RodSnapToCenterSelectorElementOnChange() {
    if(userInterface.getController("RodSnapToCenter").getValue() == 1) {
        userInterface.getController("RodSnapToEdge").setValue(0);
    }
    boolean snapToCenter = userInterface.getController("RodSnapToCenter").getValue() == 1 ? true : false;
    interactivityListener.setSnapToCenter(snapToCenter);

}

/*--------------------------------- Rod Snap To Edge Selector Element -----------------------------*/
private void RodSnapToEdgeSelectorElementOnChange() {
    if(userInterface.getController("RodSnapToEdge").getValue() == 1) {

        userInterface.getController("RodSnapToCenter").setValue(0);
    }

    boolean snapToEdge = userInterface.getController("RodSnapToEdge").getValue() == 1 ? true : false;
    interactivityListener.setSnapToEdge(snapToEdge);

}

private void RodIsJointSelectorElementOnChange() {

        if(userInterface.getController("RodIsJoint").getValue() == 1) {
                interactivityListener.setRodIsJoint(true);
        } else {
                interactivityListener.setRodIsJoint(false);
        }
}



/*--------------------------------- Motor Target Angular Velocity Slider Element -------------------*/
private void MotorTargetAngularVelocitySliderElementOnChange() {
    float targetAngularVelocity = userInterface.getController("MotorTargetAngularVelocity").getValue();
    interactivityListener.setMotorTargetAngularVelocity(targetAngularVelocity);
}

/*--------------------------------- Motor Draw Motor Selector Element -----------------------------*/
private void MotorDrawMotorSelectorElementOnChange() {
    boolean drawMotor = userInterface.getController("MotorDrawMotor").getValue() == 1 ? true : false;
    interactivityListener.setMotorDrawMotor(drawMotor);
}
/*--------------------------------- Motor Draw Motor Force Selector Element -----------------------*/
private void MotorDrawMotorForceSelectorElementOnChange() {
    boolean drawMotorForce = userInterface.getController("MotorDrawMotorForce").getValue() == 1 ? true : false;
    interactivityListener.setMotorDrawMotorForce(drawMotorForce);
}

/* --------------------------------- Editor Tab --------------------------------------------------*/
private void EditorEnableEditorSelectorElementOnChange() {
    if(userInterface.getController("EditorEnableEditor").getValue() == 1) {
        interactivityListener.setEnableEditor(true);
    } else {
        interactivityListener.setEnableEditor(false);
    }
}

/*
====================================================================================================
======================================== Getters and Setters =======================================
====================================================================================================
*/

public int getGroupHeight() {
    return this.globalGroupHeight;
}
public int getGroupWidth() {
    return this.globalGroupWidth;
}

    }
public class Gravity implements ForceRegistry {
  private final Rigidbody rigidbody;

  public Gravity(Rigidbody rigidbody) {
    this.rigidbody = rigidbody;
  }

  @Override
  public PVector getForce(Rigidbody rigidbody, PVector position) {
    return PVector.mult(GRAVITY_VECTOR, rigidbody.getMass());
  }

  @Override
  public void draw() {
    // Do nothing
  }

    @Override
    public PVector getApplicationPoint(Rigidbody rigidbody, PVector position) {
      return rigidbody.getPosition();
    }
    @Override
    public Rigidbody getRigidbodyA() {
      return this.rigidbody;
    }
    @Override
    public Rigidbody getRigidbodyB(){
      return this.rigidbody;
    }
}


public class InteractivityListener {

  public PVector position;
  public float zoom;

  public boolean showCursorTrail = true;
  public int lastTime;
  public ArrayList<PVector> trail = new ArrayList<PVector>();


/*--------- Stuff for the velocity calculation ----------------*/
  public boolean mouseDown = false;
  public PVector initialMousePosition = new PVector();
  public PVector currentMousePosition = new PVector();
  public PVector velocity = new PVector();
  public PVector endPoint = new PVector();
/*---------- Stuff for mouse spring ----------- */
  public Spring mouseSpring;
  public boolean mouseSpringCreated = false;


/* Stuff for editing rigidbodies */
  public boolean editRigidbody = false;
  public boolean copied = false;
  public boolean pasted = false;
/*
====================================================================================================
================================= GUI Variables for Rigidbody Generation ===========================
====================================================================================================
*/
  private Rigidbody currentlySelectedRigidbody;
  private float width;
  private float height;

  private float softbodyWidth;
  private float softbodyHeight;

  private PVector[] vertices;

  private float radius;
  private PVector rigidbodyPosition;

  private float density;
  private float restitution;

  
  private float angle;
  private float angularVelocity;

  private boolean generateRigidbodies;
  private boolean generateForces;

    //TODO IMPLEMENT THIS
  private boolean showObjectTrail;

  private boolean isStatic;
  private boolean isTranslationallyStatic;
  private boolean isRotationallyStatic;

  private boolean isCollidable;

  private boolean addGravity;

  private float strokeWeight;
  private PVector strokeColor;
  private PVector fillColor;

  private ShapeType shapeType;
  

  public InteractivityListener() {
    position = new PVector(-50, -50);
    zoom = 10f;
  }
/*
====================================================================================================
=============================== GUI Variables for Force Generation =================================
====================================================================================================
*/

/*------------------------------ Global Variables ----------------------------*/
    private ForceType forceType;


    private ArrayList<Rigidbody> selectedRigidbodies = new ArrayList<Rigidbody>();

    private boolean isFirstClickOnRigidbody = false;
    private boolean drawForces = false;
    private boolean oneRigidbodySelected = false;
    private boolean twoRigidbodiesSelected = false;

    private int opacity = 166;
    private Rigidbody tempBody;

    private Rigidbody selectedRigidbody;
    private Rigidbody selectedRigidbody1;
    private Rigidbody selectedRigidbody2;

    private PVector anchorPoint;
    private PVector localAnchorA;

    private boolean snapToCenter;
    private boolean snapToEdge;
    private boolean snapToVertices;
    private boolean snapGeneral = true;

    private boolean enableEditor;

/*----------------------------- Spring Variables -----------------------------*/

    private boolean lockTranslationToXAxis;
    private boolean lockTranslationToYAxis;
  
    private boolean isPerfectSpring;

    private float equilibriumLength;
    private float springLength;
    private float springConstant;
    private float springDamping;

    private boolean isSpringHingeable;


/*--------------------------- Rod Variables ---------------------------------*/
    
    private boolean isRodHingeable;
    private boolean isTwoBodyRod;
    private boolean isJoint;

/*--------------------------- Motor Variables ----------------------------*/
    private float motorTargetAngularVelocity;
    private boolean motorDrawMotor;
    private boolean motorDrawMotorForce;

/*
====================================================================================================
======================================= GUI Methods ================================================
====================================================================================================
*/

  public void zoom(float amount, float mouseX, float mouseY) {
    PVector mouseBeforeZoom = screenToWorld(mouseX, mouseY);
    zoom *= amount;
    PVector mouseAfterZoom = screenToWorld(mouseX, mouseY);
    PVector shift = PVector.sub(mouseBeforeZoom, mouseAfterZoom);
    position.add(shift);
}


  public void applyTransform() {
    translate(width/2, height/2);
    scale(zoom);
    translate(-position.x, -position.y);
  }

  public void resetTransform() {
    translate(position.x, position.y);
    scale(1/zoom);
    translate(-width/2, -height/2);
  }
  
   public PVector screenToWorld(float x, float y) {
    float worldX = (x - width/2) / zoom + position.x;
    float worldY = (y - height/2) / zoom + position.y;
    return new PVector(worldX, worldY);
  }

  public PVector screenToWorld(){
    return new PVector((mouseX - width / 2) / zoom + position.x, (mouseY - height / 2) / zoom + position.y);
  }

  public void zoom(float amount) {
    zoom *= amount;
  }

  public void move(float dx, float dy) {
    position.x += dx / zoom;
    position.y += dy / zoom;
  }

  public float[] getCameraExtents(float padding) {

  float left = screenToWorld(padding, padding).x;
  float right = screenToWorld(width - padding, padding).x;
  float top = screenToWorld(padding, padding).y;
  float bottom = screenToWorld(width - padding, height - padding).y;

  return new float[] {left, right, top, bottom};
}
//Overloaded method that returns the camera extents as PVector coordinates
public PVector[] getWorldBoundsWithPadding(float padding) {
  PVector topLeft = screenToWorld(padding, padding);
  PVector topRight = screenToWorld(width - padding, padding);
  PVector bottomLeft = screenToWorld(padding, height - padding);
  PVector bottomRight = screenToWorld(width - padding, height - padding);

  return new PVector[] {topLeft, topRight, bottomLeft, bottomRight};
}

public Rigidbody getClickedRigidbody() {
    PVector mousePosition = screenToWorld();

    for (Rigidbody rigidbody : rigidbodyList) {
        if(this.tempBody == rigidbody) {
            continue;
        }
        
        if(!Collisions.IntersectAABBWithPoint(rigidbody.GetAABB(), mousePosition)){
            continue;
        }
        if (rigidbody.contains(mousePosition.x, mousePosition.y)) {
            return rigidbody;
        }
    }
    return null;
}





/*
====================================================================================================
======================================= Generation Methods =========================================
====================================================================================================
*/

/*
====================================================================================================
======================================= Rigidbody Generation Methods ================================
====================================================================================================
*/
public void updateGUIValues(Rigidbody rigidbody) {
    this.currentlySelectedRigidbody = rigidbody;

    this.copied = true;
    this.pasted = false;

    if(rigidbody == null) {
        return;
    }
    if(this.currentlySelectedRigidbody.getShapeType() == ShapeType.CIRCLE) {
        userInterface.getController("Circle").setValue(1);
        userInterface.getController("Box").setValue(0);

        userInterface.getController("CircleRadius").setValue(this.currentlySelectedRigidbody.getRadius());
    } else if(this.currentlySelectedRigidbody.getShapeType() == ShapeType.BOX) {
        userInterface.getController("Circle").setValue(0);
        userInterface.getController("Box").setValue(1);

        userInterface.getController("RectangleWidth").setValue(this.currentlySelectedRigidbody.getWidth());
        userInterface.getController("RectangleHeight").setValue(this.currentlySelectedRigidbody.getHeight());
    }

    userInterface.getController("Density").setValue(this.currentlySelectedRigidbody.getDensity());
    userInterface.getController("Restitution").setValue(this.currentlySelectedRigidbody.getRestitution());

    userInterface.getController("FillColour").setValue(1);
    userInterface.getController("StrokeWeight").setValue(this.currentlySelectedRigidbody.getStrokeWeight());

    userInterface.getController("RedFill").setValue(this.currentlySelectedRigidbody.getFillColour().x);
    userInterface.getController("GreenFill").setValue(this.currentlySelectedRigidbody.getFillColour().y);
    userInterface.getController("BlueFill").setValue(this.currentlySelectedRigidbody.getFillColour().z);

    int staticValue = (this.currentlySelectedRigidbody.getIsStatic()) ? 1 : 0;
    int translationallyStaticValue = (this.currentlySelectedRigidbody.getIsTranslationallyStatic()) ? 1 : 0;
    int rotationallyStaticValue = (this.currentlySelectedRigidbody.getIsRotationallyStatic()) ? 1 : 0;
    int collidabilityValue = (this.currentlySelectedRigidbody.getCollidability()) ? 1 : 0;

    userInterface.getController("isStatic").setValue(staticValue);
    userInterface.getController("transStatic").setValue(translationallyStaticValue);
    userInterface.getController("rotStatic").setValue(rotationallyStaticValue);
    userInterface.getController("IsCollidable").setValue(collidabilityValue);

    userInterface.getController("Angle").setValue(this.currentlySelectedRigidbody.getAngle());
    userInterface.getController("AngularVelocity").setValue(this.currentlySelectedRigidbody.getAngularVelocity());

    this.vertices = rigidbody.getVertices();
}

public void updateRigidbodyValues(){

    if(this.currentlySelectedRigidbody != null) {
        this.currentlySelectedRigidbody.setWidth(this.width);
        this.currentlySelectedRigidbody.setHeight(this.height);
        this.currentlySelectedRigidbody.setRadius(this.radius);
        this.currentlySelectedRigidbody.setDensity(this.density);
        this.currentlySelectedRigidbody.setRestitution(this.restitution);
        this.currentlySelectedRigidbody.setIsStatic(this.isStatic);
        this.currentlySelectedRigidbody.setIsTranslationallyStatic(this.isTranslationallyStatic);
        this.currentlySelectedRigidbody.setIsRotationallyStatic(this.isRotationallyStatic);
        this.currentlySelectedRigidbody.setCollidability(this.isCollidable);
        this.currentlySelectedRigidbody.setStrokeWeight(this.strokeWeight);
        this.currentlySelectedRigidbody.setStrokeColour(this.strokeColor);
        this.currentlySelectedRigidbody.setFillColour(this.fillColor);
        this.currentlySelectedRigidbody.setShapeType(this.shapeType);
    }
}


public void GenerateRigidbody() {
    if(userInterface.getController("Circle").getValue() == 0 && userInterface.getController("Box").getValue() == 0) {
        return;
    }
    if(!isPaused && getClickedRigidbody() != null) {
        return;
    }
    if(isInEditMode) {
        return;
    }

    if(!IsMouseOverUI()){
     if(this.shapeType == ShapeType.BOX) {
            PVector coordinate;
            Rigidbody rigidbody = RigidbodyGenerator.CreateBoxBody( this.width, this.height,
                                                                    this.density, this.restitution,
                                                                    this.isStatic, this.isCollidable,
                                                                    this.strokeWeight, this.strokeColor,
                                                                    this.fillColor);

            if(this.velocity.mag() < 0.1f){
                coordinate = getMouseCoordinatesOverRigidbody();
            } else {
                coordinate = this.endPoint;
            }

            rigidbody.setVelocity(PhysEngMath.SquareVelocity(this.velocity).mult(-1));
            rigidbody.SetInitialPosition(coordinate);
            rigidbody.setIsTranslationallyStatic(this.isTranslationallyStatic);
            rigidbody.setCollidability(this.isCollidable);
            rigidbody.setIsRotationallyStatic(this.isRotationallyStatic);
            rigidbody.RotateTo(this.angle);
            rigidbody.setAngularVelocity(this.angularVelocity);

            if(this.copied && !this.pasted) {
                rigidbody.updatePolygon(this.vertices);
                this.pasted = true;
                this.copied = false;
            }

            if(this.addGravity) {
                rigidbody.addForceToForceRegistry(new Gravity(rigidbody));
            }

            AddBodyToBodyEntityList(rigidbody);
        }

        if(this.shapeType == ShapeType.CIRCLE) {
            PVector coordinate;
            Rigidbody rigidbody = RigidbodyGenerator.CreateCircleBody(this.radius, this.density,
                                                                      this.restitution, this.isStatic,
                                                                      this.isCollidable, this.strokeWeight,
                                                                      this.strokeColor, this.fillColor);

                                        
            if(this.velocity.mag() < 0.1f){
                coordinate = getMouseCoordinatesOverRigidbody();
            } else {
                coordinate = this.endPoint;
            }

            rigidbody.SetInitialPosition(coordinate);
            rigidbody.setVelocity(PhysEngMath.SquareVelocity(this.velocity).mult(-1));
            rigidbody.setIsTranslationallyStatic(this.isTranslationallyStatic);
            rigidbody.setIsRotationallyStatic(this.isRotationallyStatic);
            rigidbody.setCollidability(this.isCollidable);
            rigidbody.RotateTo(this.angle);
            rigidbody.setAngularVelocity(this.angularVelocity);

            if(this.addGravity) {
                rigidbody.addForceToForceRegistry(new Gravity(rigidbody));
            }

            AddBodyToBodyEntityList(rigidbody);
        }

        this.velocity.set(0,0,0);

   }
}

/*
====================================================================================================
======================================= Force Generation Methods ===================================
====================================================================================================
*/


public void addSelectedRigidbody() {
    //Just in case
    if(this.selectedRigidbodies.size() > 2) {
        this.selectedRigidbodies.clear();
    }
    this.selectedRigidbodies.add(getClickedRigidbody());

    if(this.selectedRigidbodies.size() == 1) {
        firstMouseClickInformation();
    }
}

public PVector getMouseCoordinatesOverRigidbody() {
    if(!IsMouseOverUI()) {
        Rigidbody rigidbody = getClickedRigidbody();
        PVector mousePos = screenToWorld();

        if(rigidbody == null) {
            return mousePos;
        } else {
            PVector localAnchorA = PhysEngMath.SnapController(this, rigidbody, mousePos);
            PVector worldAnchorA = PhysEngMath.Transform(localAnchorA, rigidbody.getPosition(), 0f);
            return worldAnchorA.copy();

        }

    } else {
        return null;
    }
}

public void drawMouseOverRigidbody() {
    
    //Rigidbody rigidbody = getClickedRigidbody();
    PVector coordinate = getMouseCoordinatesOverRigidbody();

    fill(255, 0, 0);
    strokeWeight(0.1f);
    stroke(255, 0, 0);
    ellipse(coordinate.x, coordinate.y, 0.1f, 0.1f);

    if(showCursorTrail) {
        trail.add(new PVector(coordinate.x, coordinate.y));
        if (trail.size() > 20) {
            trail.remove(0);
        }
    
        noFill();
        stroke(255, 0, 0);
        strokeWeight(0.1f);
        beginShape();

        for (int i = 0; i < trail.size(); i++) {
            curveVertex(trail.get(i).x, trail.get(i).y);
        }
        endShape();
    }
}

public void drawInteractions() {
    drawMouseOverRigidbody();
    Mouse.DrawMouseCursor();
    if(userInterface.getTab("Forces").isActive()){
        if(userInterface.getController("AddSpring").getValue() == 0 && userInterface.getController("AddRod").getValue() == 0 && userInterface.getController("AddMotor").getValue() == 0) {
            return;
        }
        drawForces();
    } else if(userInterface.getTab("Rigidbodies").isActive() && (userInterface.getController("Circle").getValue() == 1 || userInterface.getController("Box").getValue() == 1)) {
        if(this.mouseDown && !isInEditMode){
            drawVelocityLine();
        }
        if(userInterface.getController("Circle").getValue() == 0 && userInterface.getController("Box").getValue() == 0) {
            return;
        }
        if(userInterface.getTab("Rigidbodies").isActive()){
            if(editRigidbody) {
                updateRigidbodyValues();
            } else if(!mouseSpringAdded && !isInEditMode) {
                drawBodies();
            }
        }
    }
}


public void drawVelocityLine() {

    /*This takes care of updating the new velocity values and endpoint values for the rigidbodies */
    this.velocity.set(PhysEngMath.MouseVelocityCalculationAndClamp(this.initialMousePosition, screenToWorld(), MIN_MOUSE_VELOCITY_MAG, MAX_MOUSE_VELOCITY_MAG));
    endPoint.set(PVector.add(this.initialMousePosition, this.velocity));

    if(PVector.sub(this.initialMousePosition, this.endPoint).magSq() > 0.1f){
        float lerpVal = map(this.velocity.mag(), MIN_MOUSE_VELOCITY_MAG, MAX_MOUSE_VELOCITY_MAG, 0, 1);
        lerpVal = lerpVal * lerpVal; // This creates a quadratic effect

        int colour = lerpColor(color(0, 255, 0), color(255, 0, 0), lerpVal);
        stroke(colour);
        line(this.initialMousePosition.x, this.initialMousePosition.y, endPoint.x, endPoint.y);
    }
}



public void drawBodies() {
    PVector mouseCoordinates = new PVector();
    if(this.velocity.magSq() > 0.1f){
        mouseCoordinates.set(this.endPoint);
    } else {
        mouseCoordinates.set(getMouseCoordinatesOverRigidbody());
    }

    pushMatrix();
    translate(mouseCoordinates.x, mouseCoordinates.y);
    rotate(this.angle);
    if(this.shapeType == ShapeType.CIRCLE) {
        float diameter = this.radius * 2.0f;
        fill(this.fillColor.x, this.fillColor.y, this.fillColor.z, this.opacity);
        strokeWeight(this.strokeWeight);
        stroke(this.strokeColor.x, this.strokeColor.y, this.strokeColor.z, this.opacity);
        ellipseMode(CENTER);

        ellipse(0, 0, diameter,  diameter);

        PVector va = new PVector();
        PVector vb = new  PVector(radius, 0);
        va = PhysEngMath.Transform(va, new PVector(), this.angle);
        vb = PhysEngMath.Transform(vb, new PVector(), this.angle);
        line(va.x, va.y, vb.x, vb.y);

    } else if (this.shapeType == ShapeType.BOX && !this.copied) {
        fill(this.fillColor.x, this.fillColor.y, this.fillColor.z, this.opacity);
        stroke(this.strokeColor.x, this.strokeColor.y, this.strokeColor.z, this.opacity);
        strokeWeight(this.strokeWeight);
        rectMode(CENTER);
        rect(0, 0, this.width, this.height);
    } else if(this.shapeType == ShapeType.BOX) {
        fill(this.fillColor.x, this.fillColor.y, this.fillColor.z, this.opacity);
        stroke(this.strokeColor.x, this.strokeColor.y, this.strokeColor.z, this.opacity);
        strokeWeight(this.strokeWeight);

        beginShape();
        for(PVector vertex : vertices) {
            vertex(vertex.x, vertex.y);
        }
        endShape();
    }

    popMatrix();
}



public void drawForces() {
    PVector worldAnchorA;
    PVector worldAnchorB;

    if(selectedRigidbodies.size() > 0) {
        if(isFirstClickOnRigidbody) {
            worldAnchorA = PhysEngMath.Transform(this.localAnchorA, this.tempBody.getPosition(), tempBody.getAngle());
            worldAnchorB = getMouseCoordinatesOverRigidbody();
        } else {
            worldAnchorA = this.anchorPoint;
            worldAnchorB = getMouseCoordinatesOverRigidbody();        
        }

        if(this.forceType == ForceType.SPRING) {
            fill(255, 255, 255, opacity);
            PVector direction = PVector.sub(worldAnchorA, worldAnchorB);

            float length = direction.mag();
            direction.normalize();

            float segments = 10;
            float segmentLength = length / segments;

            float offsetMagnitude = 0.5f;

            //Draw the rod
            strokeWeight(0.3f);
            stroke(0, 0, 0, opacity); // Black
            line(worldAnchorA.x, worldAnchorA.y, worldAnchorB.x, worldAnchorB.y);
            stroke(255, 255, 255, opacity); // White
            strokeWeight(0.1f);
            line(worldAnchorA.x, worldAnchorA.y, worldAnchorB.x, worldAnchorB.y);
            
            //Draw the spring
            for(int i = 0; i < segments; i++) {
                PVector segmentStart = PVector.add(worldAnchorB, PVector.mult(direction, segmentLength * i));
                PVector segmentEnd = PVector.add(worldAnchorB, PVector.mult(direction, segmentLength * (i + 1)));

                // Calculate the midpoint of the segment
                PVector midPoint = PVector.lerp(segmentStart, segmentEnd, 0.5f);

                // Alternate the offset direction to give appearance of spring
                PVector offset1, offset2;
                if(i % 2 == 0) {
                    offset1 = PVector.mult(new PVector(-direction.y, direction.x), offsetMagnitude);
                    offset2 = PVector.mult(new PVector(direction.y, -direction.x), offsetMagnitude);
                } else {
                    offset1 = PVector.mult(new PVector(direction.y, -direction.x), offsetMagnitude);
                    offset2 = PVector.mult(new PVector(-direction.y, direction.x), offsetMagnitude);
                }

                // Add the offsets to the midpoint
                PVector midPoint1 = PVector.add(midPoint, offset1);
                PVector midPoint2 = PVector.add(midPoint, offset2);

                // Draw the lines
                strokeWeight(0.2f);
                stroke(0, 0, 0, opacity);
                line(segmentStart.x, segmentStart.y, midPoint1.x, midPoint1.y);
                line(midPoint1.x, midPoint1.y, segmentEnd.x, segmentEnd.y);
                line(segmentStart.x, segmentStart.y, midPoint2.x, midPoint2.y);
                line(midPoint2.x, midPoint2.y, segmentEnd.x, segmentEnd.y);
                strokeWeight(0.1f);
                stroke(255, 255, 255, opacity);
                line(segmentStart.x, segmentStart.y, midPoint1.x, midPoint1.y);
                line(midPoint1.x, midPoint1.y, segmentEnd.x, segmentEnd.y);
                line(segmentStart.x, segmentStart.y, midPoint2.x, midPoint2.y);
                line(midPoint2.x, midPoint2.y, segmentEnd.x, segmentEnd.y);
            }

        } else if(this.forceType == ForceType.ROD) {
            strokeWeight(0.15f);
            stroke(0, 0, 0, opacity);
            line(worldAnchorA.x, worldAnchorA.y, worldAnchorB.x, worldAnchorB.y);
            strokeWeight(0.1f);
            stroke(255, 255, 255, opacity);
            line(worldAnchorA.x, worldAnchorA.y, worldAnchorB.x, worldAnchorB.y);

        } else if(this.forceType == ForceType.MOTOR) {
            if(this.tempBody != null) {
            PVector position = this.tempBody.getPosition();
            boolean isClockwise = this.motorTargetAngularVelocity > 0;

            float size = this.tempBody.getRadius() * 0.5f;
            float arrowSize = size * 0.15f;
            float startAngle = 0;
            float endAngle = 3 * PI/2;// Change this to control the curvature of the arrow
            
            pushMatrix();
            translate(position.x, position.y);
            rotate(this.tempBody.getAngle() + PI/6);

            noFill();
            strokeWeight(0.1f);
            stroke(255, 0, 0, opacity);
            arc(0, 0, size, size, startAngle, endAngle);

            // Calculate the start and end of the arc
            float startX =  size * cos(startAngle)/2;
            float startY = size * sin(startAngle)/2;
            float endX = size * cos(endAngle)/2;
            float endY = size * sin(endAngle)/2;


            if(isClockwise) {
                strokeWeight(0.1f);
                stroke(255, 0, 0, opacity);
                triangle(endX, endY-arrowSize, endX, endY+arrowSize, endX+arrowSize*2, endY);
            } else {
                strokeWeight(0.1f);
                stroke(255, 0, 0, opacity);
                triangle(startX-arrowSize, startY, startX + arrowSize, startY, startX, startY - 2 * arrowSize);
            }
            popMatrix();
            }
        }
    }
}

public void updateSelectedRigidbodies() {
    if(this.selectedRigidbodies.size() == 2) {

        //For one body selected
        if(this.selectedRigidbodies.get(0) != null && this.selectedRigidbodies.get(1) == null) {

            this.selectedRigidbody = this.selectedRigidbodies.get(0);

            this.selectedRigidbody1 = null;
            this.selectedRigidbody2 = null;
            this.tempBody = null;

            this.oneRigidbodySelected = true;
            this.twoRigidbodiesSelected = false;

        } else if(this.selectedRigidbodies.get(0) == null && this.selectedRigidbodies.get(1) != null){
            
            this.selectedRigidbody = this.selectedRigidbodies.get(1);

            this.selectedRigidbody1 = null;
            this.selectedRigidbody2 = null;
            this.tempBody = null;

            this.oneRigidbodySelected = true;
            this.twoRigidbodiesSelected = false;
        
        }else if(this.selectedRigidbodies.get(0) != null && this.selectedRigidbodies.get(1) != null) {

            this.selectedRigidbody1 = this.selectedRigidbodies.get(0);
            this.selectedRigidbody2 = this.selectedRigidbodies.get(1);

            this.selectedRigidbody = null;
            this.tempBody = null;

            this.oneRigidbodySelected = false;
            this.twoRigidbodiesSelected = true;

        } else if(this.selectedRigidbodies.get(0) == null && this.selectedRigidbodies.get(1) == null) {

            this.selectedRigidbody = null;
            this.selectedRigidbody1 = null;
            this.selectedRigidbody2 = null;
            this.tempBody = null;

            this.oneRigidbodySelected = false;
            this.twoRigidbodiesSelected = false;
        }
        this.selectedRigidbodies.clear();

    } else if(this.selectedRigidbodies.size() == 1) {
            
            if(this.selectedRigidbodies.get(0) != null) {
    
                this.tempBody = this.selectedRigidbodies.get(0);

                this.selectedRigidbody = null;
                this.selectedRigidbody1 = null;
                this.selectedRigidbody2 = null;
    
                this.oneRigidbodySelected = true;
                this.twoRigidbodiesSelected = false;
    
            } else if(this.selectedRigidbodies.get(0) == null) {
                
                this.tempBody = null;
                this.selectedRigidbody = null;
                this.selectedRigidbody1 = null;
                this.selectedRigidbody2 = null;
    
                this.oneRigidbodySelected = false;
                this.twoRigidbodiesSelected = false;
            }
    }
}


public void createForces() {

    if(userInterface.getController("AddSpring").getValue() == 0 && userInterface.getController("AddRod").getValue() == 0 && userInterface.getController("AddMotor").getValue() == 0){
        return;
    }

    if(this.selectedRigidbody != null && this.selectedRigidbody1 == null && this.selectedRigidbody2 == null) {
        if(this.forceType == ForceType.SPRING) {

            Spring spring;
            PVector mouseCoordinates = screenToWorld();
            if(isFirstClickOnRigidbody) {
                spring = new Spring(this.selectedRigidbody, this.localAnchorA, mouseCoordinates);
            } else {

                this.localAnchorA = PhysEngMath.Transform(PhysEngMath.SnapController(this, this.selectedRigidbody, mouseCoordinates), -this.selectedRigidbody.getAngle());
                spring = new Spring(this.selectedRigidbody, this.localAnchorA, this.anchorPoint);
            }

            spring.setPerfectSpring(this.isPerfectSpring);
            spring.setLockTranslationToXAxis(this.lockTranslationToXAxis);
            spring.setLockTranslationToYAxis(this.lockTranslationToYAxis);

            spring.setEquilibriumLength(this.equilibriumLength);
            spring.setSpringConstant(this.springConstant);

            spring.setDamping(this.springDamping);

            ALL_FORCES_ARRAYLIST.add(spring);
            this.selectedRigidbody.addForceToForceRegistry(spring);

        } else if(this.forceType == ForceType.ROD) {

            Rod rod;
            PVector mouseCoordinates = screenToWorld();

            if(isFirstClickOnRigidbody) {
                rod = new Rod(this.selectedRigidbody, this.localAnchorA, mouseCoordinates);
            } else {
                this.localAnchorA = PhysEngMath.Transform(PhysEngMath.SnapController(this, this.selectedRigidbody, mouseCoordinates), -this.selectedRigidbody.getAngle());
                rod = new Rod(this.selectedRigidbody, this.localAnchorA, this.anchorPoint);
            }

            rod.setIsJoint(this.isJoint);


            ALL_FORCES_ARRAYLIST.add(rod);
            this.selectedRigidbody.addForceToForceRegistry(rod);

        } else if(this.forceType == ForceType.MOTOR) {
            Motor motor = new Motor(this.selectedRigidbody, this.motorTargetAngularVelocity);
            motor.setDrawMotor(this.motorDrawMotor);
            motor.setDrawMotorForce(this.motorDrawMotorForce);
            
            Iterator<ForceRegistry> iterator = this.selectedRigidbody.getForceRegistry().iterator();
            
            while (iterator.hasNext()) {
                ForceRegistry force = iterator.next();
                
                if (force instanceof Motor) {
                    iterator.remove();
                }
            }
            ALL_FORCES_ARRAYLIST.add(motor);
            this.selectedRigidbody.addForceToForceRegistry(motor);
        }

    } else if(this.selectedRigidbody1 != null && this.selectedRigidbody2 != null && this.selectedRigidbody == null && this.selectedRigidbody1 != this.selectedRigidbody2) {
        if(this.forceType == ForceType.SPRING) {


            PVector localAnchorB = PhysEngMath.Transform(PhysEngMath.SnapController(this, this.selectedRigidbody2, screenToWorld()), -this.selectedRigidbody2.getAngle());

            Spring spring = new Spring(this.selectedRigidbody1, this.selectedRigidbody2, this.localAnchorA, localAnchorB);

            spring.setPerfectSpring(this.isPerfectSpring);

            spring.setLockTranslationToXAxis(this.lockTranslationToXAxis);
            spring.setLockTranslationToYAxis(this.lockTranslationToYAxis);

            spring.setEquilibriumLength(this.equilibriumLength);

            spring.setSpringConstant(this.springConstant);

            spring.setDamping(this.springDamping);


            ALL_FORCES_ARRAYLIST.add(spring);
            this.selectedRigidbody1.addForceToForceRegistry(spring);
            this.selectedRigidbody2.addForceToForceRegistry(spring);

        } else if(this.forceType == ForceType.ROD) {
            Rod rod;

            PVector localAnchorB = PhysEngMath.Transform(PhysEngMath.SnapController(this, this.selectedRigidbody2, screenToWorld()), -this.selectedRigidbody2.getAngle());

            rod = new Rod(this.selectedRigidbody1, this.selectedRigidbody2, this.localAnchorA, localAnchorB);

            rod.setIsJoint(this.isJoint);

            ALL_FORCES_ARRAYLIST.add(rod);
            this.selectedRigidbody1.addForceToForceRegistry(rod);
            this.selectedRigidbody2.addForceToForceRegistry(rod);
        }

} else if((this.selectedRigidbody1 != null && this.selectedRigidbody2 != null && this.selectedRigidbody1 == this.selectedRigidbody2) || (this.selectedRigidbody1 != null && this.selectedRigidbody2 == null))

        if(this.forceType == ForceType.ROD) {
            Rod rod;

            if(this.isJoint){
                rod = new Rod(this.selectedRigidbody1, this.selectedRigidbody1.getPosition(), this.selectedRigidbody1.getPosition());
                rod.setIsJoint(true);
            } else {
                rod = new Rod(this.selectedRigidbody1, this.localAnchorA, screenToWorld());
            }

            ALL_FORCES_ARRAYLIST.add(rod);
            this.selectedRigidbody1.addForceToForceRegistry(rod);
        }

        else if(this.forceType == ForceType.MOTOR) {

            Motor motor = new Motor(this.selectedRigidbody1, this.motorTargetAngularVelocity);
            motor.setDrawMotor(this.motorDrawMotor);
            motor.setDrawMotorForce(this.motorDrawMotorForce);
            
            Iterator<ForceRegistry> iterator = this.selectedRigidbody1.getForceRegistry().iterator();
            
            while (iterator.hasNext()) {
                ForceRegistry force = iterator.next();
                
                if (force instanceof Motor) {
                    iterator.remove();
                    ALL_FORCES_ARRAYLIST.remove(force);
                }
            }
            ALL_FORCES_ARRAYLIST.add(motor);
            this.selectedRigidbody1.addForceToForceRegistry(motor);
        }
    }


public void firstMouseClickInformation() {
    Rigidbody clickedBody = getClickedRigidbody();
    PVector mousePos = screenToWorld();

    if(clickedBody != null) {        
        this.localAnchorA = PhysEngMath.Transform(PhysEngMath.SnapController(this, clickedBody, mousePos), -clickedBody.getAngle());
        this.anchorPoint = mousePos;
        this.isFirstClickOnRigidbody = true;
    } else {
        this.anchorPoint = mousePos;
        this.isFirstClickOnRigidbody = false;
    }
}




/*
====================================================================================================
======================================= Getters & Setters ==========================================
====================================================================================================
*/


public void setWidth(float width) {
  this.width = width;
}

public void setHeight(float height) {
  this.height = height;
}

public void setRadius(float radius) {
  this.radius = radius;
}

public void setDensity(float density) {
  this.density = density;
}

public void setRestitution(float restitution) {
  this.restitution = restitution;
}

public void setIsStatic(boolean isStatic) {
  this.isStatic = isStatic;
}

public void setStrokeWeight(float strokeWeight) {
  this.strokeWeight = strokeWeight;
}

public void setStrokeColor(PVector strokeColor) {
  this.strokeColor = strokeColor;
}

public void setFillColor(PVector fillColor) {
  this.fillColor = fillColor;
}

public void setShapeType(ShapeType shapeType) {
  this.shapeType = shapeType;
}

public void setIsTranslationallyStatic(boolean isTranslationallyStatic) {
  this.isTranslationallyStatic = isTranslationallyStatic;
}

public void setIsRotationallyStatic(boolean isRotationallyStatic) {
  this.isRotationallyStatic = isRotationallyStatic;
}

public void setGenerateRigidbodies(boolean generateRigidbodies) {
  this.generateRigidbodies = generateRigidbodies;
}

public void setGenerateForces(boolean generateForces) {
  this.generateForces = generateForces;
}

public void setAngle(float angle) {
  this.angle = angle;
}

public void setAngularVelocity(float angularVelocity) {
  this.angularVelocity = angularVelocity;
}

public void setForceType(ForceType forceType) {
  this.forceType = forceType;
}

public void setAddGravity(boolean addGravity) {
  this.addGravity = addGravity;
}

public void setSpringIsPerfect(boolean isPerfectSpring) {
  this.isPerfectSpring = isPerfectSpring;
}

public void setSpringIsHingeable(boolean isSpringHingeable) {
  this.isSpringHingeable = isSpringHingeable;
}
public void setSpringEquilibriumLength(float equilibriumLength) {
  this.equilibriumLength = equilibriumLength;
}

public void setSpringDamping(float damping) {
  this.springDamping = damping;
}

public void setSpringConstant(float springConstant) {
  this.springConstant = springConstant;
}

public void setLockToXAxis(boolean lockTranslationToXAxis) {
  this.lockTranslationToXAxis = lockTranslationToXAxis;
}

public void setLockToYAxis(boolean lockTranslationToYAxis) {
  this.lockTranslationToYAxis = lockTranslationToYAxis;
}

public void setRigidbodyPosition(PVector position) {
  this.rigidbodyPosition = position;
}

public void setCollidability(boolean isCollidable) {
  this.isCollidable = isCollidable;
}

public void setRodIsHingeable(boolean isRodHingeable) {
  this.isRodHingeable = isRodHingeable;
}

public void setSnapToCenter(boolean snapToCenter) {
  this.snapToCenter = snapToCenter;
}

public void setSnapToEdge(boolean snapToEdge) {
  this.snapToEdge = snapToEdge;
}

public void setSnapToVertices(boolean snapToVertices) {
  this.snapToVertices = snapToVertices;
}

public void setMotorDrawMotorForce(boolean motorDrawMotorForce) {
  this.motorDrawMotorForce = motorDrawMotorForce;
}

public void setMotorDrawMotor(boolean motorDrawMotor) {
  this.motorDrawMotor = motorDrawMotor;
}

public void setMotorTargetAngularVelocity(float motorTargetAngularVelocity) {
  this.motorTargetAngularVelocity = motorTargetAngularVelocity;
}

public void setSelectedRigidbody(Rigidbody selectedRigidbody) {
  this.selectedRigidbody = selectedRigidbody;
}

public void setSelectedRigidbody1() {
  this.selectedRigidbody1 = this.selectedRigidbody;
}

public void setSelectedRigidbody2(Rigidbody selectedRigidbody2) {
  this.selectedRigidbody2 = selectedRigidbody2;
}

public void setDrawCursorTrail(boolean showCursorTrail) {
  this.showCursorTrail = showCursorTrail;
}

public void setEnableEditor(boolean enableEditor) {
  this.enableEditor = enableEditor;
}

public void setVertices(PVector[] vertices) {
  this.vertices = vertices;
}

public void setSoftbodyWidth(float softbodyWidth) {
  this.softbodyWidth = softbodyWidth;
}

public void setSoftbodyHeight(float softbodyHeight) {
  this.softbodyHeight = softbodyHeight;
}

public void setRodIsJoint(boolean isJoint) {
    this.isJoint = isJoint;
}

public float getWidth() {
  return this.width;
}

public float getHeight() {
  return this.height;
}

public float getRadius() {
  return this.radius;
}

public float getDensity() {
  return this.density;
}

public float getRestitution() {
  return this.restitution;
}

public boolean getIsStatic() {
  return this.isStatic;
}

public boolean getCollidability() {
  return this.isCollidable;
}

public float getStrokeWeight() {
  return this.strokeWeight;
}

public PVector getStrokeColor() {
  return this.strokeColor;
}

public PVector getFillColor() {
    return this.fillColor;
}

public ShapeType getShapeType() {
  return this.shapeType;
}

public boolean getIsTranslationallyStatic() {
  return this.isTranslationallyStatic;
}

public boolean getIsRotationallyStatic() {
  return this.isRotationallyStatic;
}

public boolean getGenerateRigidbodies() {
  return this.generateRigidbodies;
}

public boolean getGenerateForces() {
  return this.generateForces;
}

public float getAngle() {
  return this.angle;
}

public float getAngularVelocity() {
  return this.angularVelocity;
}

public boolean getAddGravity() {
  return this.addGravity;
}

public boolean getIsPerfectSpring() {
  return this.isPerfectSpring;
}


public boolean getSnapToEdge() {
    return this.snapToEdge;
}

public boolean getSnapToCenter() {
    return this.snapToCenter;
}

public boolean getSnapToVertices() {
    return this.snapToVertices;
}
public boolean getMotorDrawMotorForce() {
    return this.motorDrawMotorForce;
}

public boolean getMotorDrawMotor() {
    return this.motorDrawMotor;
}

public float getMotorTargetAngularVelocity() {
    return this.motorTargetAngularVelocity;
}

public Rigidbody getSelectedRigidbody() {
    return this.selectedRigidbody;
}

public Rigidbody getSelectedRigidbody1() {
    return this.selectedRigidbody1;
}

public Rigidbody getSelectedRigidbody2() {
    return this.selectedRigidbody2;
}

public boolean getEnableEditor() {
    return this.enableEditor;
}

public PVector[] getVertices() {
    return this.vertices;
}

public float getSoftbodyWidth(){
    return this.softbodyWidth;
}

public float getSoftbodyHeight(){
    return this.softbodyHeight;
}

public boolean getRodIsJoint(){
    return this.isJoint;
}

public ArrayList<Rigidbody> getSelectedRigidbodiesArrayList(){
    return this.selectedRigidbodies;
}

public int getOpacity() {
    return this.opacity;
}

public boolean getSnapGeneral(){
    return this.snapGeneral;
}

public void setSnapGeneral(boolean snapGeneral) {
    this.snapGeneral = snapGeneral;

}

}







public class Level {

	public Level() {
		//Do Nothing
	}


	public void loadLevelState() {
		isPaused = true;
		JSONArray rigidbodyArray = loadJSONArray("test.json");
		ALL_FORCES_ARRAYLIST.clear();
		rigidbodyList.clear();

		for(int i = 0; i < rigidbodyArray.size()-1; i++) {
			JSONObject rigidbodyJSON = rigidbodyArray.getJSONObject(i);
			Rigidbody rigidbody = this.deserializeRigidbody(rigidbodyJSON);
			rigidbody.addForceToForceRegistry(new Gravity(rigidbody));
			rigidbodyList.add(rigidbody);

		}

		JSONArray forcesArray = rigidbodyArray.getJSONArray(rigidbodyArray.size() - 1);

		for(int i = 0; i < forcesArray.size(); i++) {
			Spring spring = null;
			Rod rod = null;
			Motor motor = null;
			Gravity gravity = null;

			JSONObject forceJSON = forcesArray.getJSONObject(i);

			if(forceJSON.getString("ForceType").equals("Spring")){
				spring = this.deserializeSpring(forceJSON);
			} else if (forceJSON.getString("ForceType").equals("Rod")) {
				rod = this.deserializeRod(forceJSON);
			} else if (forceJSON.getString("ForceType").equals("Motor")) {
				motor = this.deserializeMotor(forceJSON);
			} else if(forceJSON.getString("ForceType").equals("Gravity")) {
				gravity = this.deserializeGravity(forceJSON);
			}

			if(spring != null) {
				if(spring.getIsTwoBodySpring()) {
					spring.getRigidbodyA().addForceToForceRegistry(spring);
					spring.getRigidbodyB().addForceToForceRegistry(spring);
					ALL_FORCES_ARRAYLIST.add(spring);
				} else {
					spring.getRigidbodyA().addForceToForceRegistry(spring);
					ALL_FORCES_ARRAYLIST.add(spring);
				}
			} else if(rod != null) {
				if(rod.getTwoBodyRod()) {
					rod.getRigidbodyA().addForceToForceRegistry(rod);
					rod.getRigidbodyB().addForceToForceRegistry(rod);

					if(rod.getIsJoint()) {
						rod.getRigidbodyA().addBodyToCollisionExclusionList(rod.getRigidbodyB());
						rod.getRigidbodyB().addBodyToCollisionExclusionList(rod.getRigidbodyA());
					}
					ALL_FORCES_ARRAYLIST.add(rod);
				} else {
					rod.getRigidbodyA().addForceToForceRegistry(rod);
					ALL_FORCES_ARRAYLIST.add(rod);
				}
			} else if(motor != null) {
				motor.getRigidbodyA().addForceToForceRegistry(motor);
				ALL_FORCES_ARRAYLIST.add(spring);

			} else if(gravity != null) {
				gravity.getRigidbodyA().addForceToForceRegistry(gravity);
				ALL_FORCES_ARRAYLIST.add(gravity);
			}
		}
		isPaused = false;
	}

	public void saveLevelState() {
		JSONArray rigidbodyArray = new JSONArray();

		for(Rigidbody body : rigidbodyList) {

			String ID = body.getID();

			/*---------------- Main Rigidbody JSON Object --------------*/
			JSONObject rigidbodyJSON = new JSONObject();
			/*----------------------------------------------------------*/

			JSONObject IDJSON = new JSONObject();
					IDJSON.setString("ID", ID);
				rigidbodyJSON.setJSONObject("RigidbodyID", IDJSON);

			JSONObject positionAndVelocityJSON = new JSONObject();
					positionAndVelocityJSON.setJSONObject("position", this.serialize2DPVector(body.getPosition()));
					positionAndVelocityJSON.setJSONObject("velocity", this.serialize2DPVector(body.getVelocity()));
				rigidbodyJSON.setJSONObject("positionAndVelocity", positionAndVelocityJSON);


			JSONObject angleAndAngularVelocityJSON = new JSONObject();
					angleAndAngularVelocityJSON.setFloat("angle", body.getAngle());
					angleAndAngularVelocityJSON.setFloat("angularVelocity", body.getAngularVelocity());
				rigidbodyJSON.setJSONObject("angleAndAngularVelocity", angleAndAngularVelocityJSON);

			JSONObject shapeTypeJSON = new JSONObject();
					shapeTypeJSON.setString("shapeType", body.getShapeType().name());
				rigidbodyJSON.setJSONObject("shapeType", shapeTypeJSON);

			JSONObject densityAndRestitutionJSON = new JSONObject();
					densityAndRestitutionJSON.setFloat("density", body.getDensity());
					densityAndRestitutionJSON.setFloat("restitution", body.getRestitution());
				rigidbodyJSON.setJSONObject("densityAndRestitution", densityAndRestitutionJSON);

			JSONObject geometryJSON = new JSONObject();
					JSONArray verticesArray = serializePVectorArray(body.getVertices());
					geometryJSON.setJSONArray("vertices", verticesArray);
					geometryJSON.setFloat("radius", body.getRadius());
					geometryJSON.setFloat("width", body.getWidth());
					geometryJSON.setFloat("height", body.getHeight());
				rigidbodyJSON.setJSONObject("geometry", geometryJSON);

		JSONObject frictionJSON = new JSONObject();
				frictionJSON.setFloat("coeffOfStaticFriction", body.getCoefficientOfStaticFriction());
				frictionJSON.setFloat("coeffOfKineticFriction", body.getCoefficientOfKineticFriction());
			rigidbodyJSON.setJSONObject("friction", frictionJSON);

		JSONObject staticityJSON = new JSONObject();
				staticityJSON.setBoolean("isStatic", body.getIsStatic());
				staticityJSON.setBoolean("isTranslationallyStatic", body.getIsTranslationallyStatic());
				staticityJSON.setBoolean("isRotationallyStatic", body.getIsRotationallyStatic());
			rigidbodyJSON.setJSONObject("staticity", staticityJSON);

		JSONObject drawingPropertiesJSON = new JSONObject();
				drawingPropertiesJSON.setFloat("strokeWeight", body.getStrokeWeight());
				drawingPropertiesJSON.setJSONObject("strokeColour", serialize3DPVector(body.getStrokeColour()));
				drawingPropertiesJSON.setJSONObject("fillColour", serialize3DPVector(body.getFillColour()));
			rigidbodyJSON.setJSONObject("drawingProperties", drawingPropertiesJSON);

		JSONObject visibilityAndCollidabilityJSON = new JSONObject();
				visibilityAndCollidabilityJSON.setBoolean("visibility", body.getIsVisible());
				visibilityAndCollidabilityJSON.setBoolean("collidability", body.getCollidability());
			rigidbodyJSON.setJSONObject("visibilityAndCollidability", visibilityAndCollidabilityJSON);


			rigidbodyArray.append(rigidbodyJSON);
		}

		rigidbodyArray.append(this.serializeForces());

		saveJSONArray(rigidbodyArray, "test.json");
	}

	private JSONArray serializeForces() {
			JSONArray forcesArray = new JSONArray();

			for(int i = 0; i < ALL_FORCES_ARRAYLIST.size(); i++) {
				JSONObject forceJSON = new JSONObject();
				ForceRegistry force = ALL_FORCES_ARRAYLIST.get(i);

				if(force instanceof Spring) {
					forceJSON = serializeSpring((Spring)force);
				} else if(force instanceof Rod) {
					forceJSON = serializeRod((Rod)force);
				} else if(force instanceof Motor) {
					forceJSON = serializeMotor((Motor)force);
				} else if(force instanceof Gravity) {
					forceJSON = serializeGravity((Gravity)force);
				}
				forcesArray.append(forceJSON);
			}
			return forcesArray;
	}


	private Rigidbody deserializeRigidbody(JSONObject rigidbodyJSON) {
		Rigidbody rigidbody;
		ShapeType shapeType = this.deserializeShapeType(rigidbodyJSON.getJSONObject("shapeType"));

		if(shapeType == ShapeType.CIRCLE) {
			rigidbody = RigidbodyGenerator.CreateCircleBody(rigidbodyJSON.getJSONObject("geometry").getFloat("radius"),
															rigidbodyJSON.getJSONObject("densityAndRestitution").getFloat("density"),
															rigidbodyJSON.getJSONObject("densityAndRestitution").getFloat("restitution"),
															rigidbodyJSON.getJSONObject("staticity").getBoolean("isStatic"),
															rigidbodyJSON.getJSONObject("visibilityAndCollidability").getBoolean("collidability"),
															rigidbodyJSON.getJSONObject("drawingProperties").getFloat("strokeWeight"),
															this.deserialize3DPVector(rigidbodyJSON.getJSONObject("drawingProperties").getJSONObject("strokeColour")),
															this.deserialize3DPVector(rigidbodyJSON.getJSONObject("drawingProperties").getJSONObject("fillColour")));

		} else {
			rigidbody = RigidbodyGenerator.CreatePolygon(this.deserializePVectorArray(rigidbodyJSON.getJSONObject("geometry").getJSONArray("vertices")),
															rigidbodyJSON.getJSONObject("densityAndRestitution").getFloat("density"),
															rigidbodyJSON.getJSONObject("densityAndRestitution").getFloat("restitution"),
															rigidbodyJSON.getJSONObject("staticity").getBoolean("isStatic"),
															rigidbodyJSON.getJSONObject("staticity").getBoolean("isTranslationallyStatic"),
															rigidbodyJSON.getJSONObject("staticity").getBoolean("isRotationallyStatic"),
															rigidbodyJSON.getJSONObject("visibilityAndCollidability").getBoolean("collidability"),
															rigidbodyJSON.getJSONObject("drawingProperties").getFloat("strokeWeight"),
															this.deserialize3DPVector(rigidbodyJSON.getJSONObject("drawingProperties").getJSONObject("strokeColour")),
															this.deserialize3DPVector(rigidbodyJSON.getJSONObject("drawingProperties").getJSONObject("fillColour")));
		}

			rigidbody.setID(rigidbodyJSON.getJSONObject("RigidbodyID").getString("ID"));
			rigidbody.setIsStatic(rigidbodyJSON.getJSONObject("staticity").getBoolean("isStatic"));
			rigidbody.setIsTranslationallyStatic(rigidbodyJSON.getJSONObject("staticity").getBoolean("isTranslationallyStatic"));
			rigidbody.setIsRotationallyStatic(rigidbodyJSON.getJSONObject("staticity").getBoolean("isRotationallyStatic"));

			rigidbody.SetInitialPosition(this.deserialize2DPVector(rigidbodyJSON.getJSONObject("positionAndVelocity").getJSONObject("position")));
			rigidbody.setVelocity(this.deserialize2DPVector(rigidbodyJSON.getJSONObject("positionAndVelocity").getJSONObject("velocity")));
			rigidbody.setAngle(rigidbodyJSON.getJSONObject("angleAndAngularVelocity").getFloat("angle"));
			rigidbody.setAngularVelocity(rigidbodyJSON.getJSONObject("angleAndAngularVelocity").getFloat("angularVelocity"));


			return rigidbody;
	}

	private Spring deserializeSpring(JSONObject springJSON) {

		boolean isTwoBodySpring = springJSON.getBoolean("isTwoBodySpring");
		if(isTwoBodySpring) {
			Rigidbody rigidbodyA = this.getRigidbodyByID(springJSON.getString("rigidbodyAID"));
			Rigidbody rigidbodyB = this.getRigidbodyByID(springJSON.getString("rigidbodyBID"));


			PVector localAnchorA = this.deserialize2DPVector(springJSON.getJSONObject("localAnchorA"));
			PVector localAnchorB = this.deserialize2DPVector(springJSON.getJSONObject("localAnchorB"));

			Spring spring = new Spring(rigidbodyA, rigidbodyB, localAnchorA, localAnchorB);

			spring.setSpringConstant(springJSON.getFloat("springConstant"));
			spring.setEquilibriumLength(springJSON.getFloat("equilibriumLength"));
			spring.setDamping(springJSON.getFloat("damping"));
			spring.setDrawSpring(springJSON.getBoolean("drawSpring"));
			spring.setLockTranslationToXAxis(springJSON.getBoolean("lockTranslationToXAxis"));
			spring.setLockTranslationToYAxis(springJSON.getBoolean("lockTranslationToYAxis"));
			spring.setPerfectSpring(springJSON.getBoolean("isPerfectSpring"));
			spring.setSpringLength(springJSON.getFloat("springLength"));

			return spring;
		} else {
			Rigidbody rigidbodyA = this.getRigidbodyByID(springJSON.getString("rigidbodyAID"));
			PVector localAnchorA = this.deserialize2DPVector(springJSON.getJSONObject("localAnchorA"));
			PVector anchorPoint = this.deserialize2DPVector(springJSON.getJSONObject("anchorPoint"));

			Spring spring = new Spring(rigidbodyA, localAnchorA, anchorPoint);
			spring.setSpringConstant(springJSON.getFloat("springConstant"));
			spring.setEquilibriumLength(springJSON.getFloat("equilibriumLength"));
			spring.setDamping(springJSON.getFloat("damping"));
			spring.setDrawSpring(springJSON.getBoolean("drawSpring"));
			spring.setLockTranslationToXAxis(springJSON.getBoolean("lockTranslationToXAxis"));
			spring.setLockTranslationToYAxis(springJSON.getBoolean("lockTranslationToYAxis"));
			spring.setPerfectSpring(springJSON.getBoolean("isPerfectSpring"));
			spring.setSpringLength(springJSON.getFloat("springLength"));

			return spring;
		}
	}

	private Rod deserializeRod(JSONObject rodJSON) {
			boolean isTwoBodyRod = rodJSON.getBoolean("isTwoBodyRod");
			if(isTwoBodyRod) {
					Rigidbody rigidbodyA = this.getRigidbodyByID(rodJSON.getString("rigidbodyAID"));
					Rigidbody rigidbodyB = this.getRigidbodyByID(rodJSON.getString("rigidbodyBID"));

					PVector localAnchorA = this.deserialize2DPVector(rodJSON.getJSONObject("localAnchorA"));
					PVector localAnchorB = this.deserialize2DPVector(rodJSON.getJSONObject("localAnchorB"));

					Rod rod = new Rod(rigidbodyA, rigidbodyB, localAnchorA, localAnchorB);
					System.out.println(rodJSON.getFloat("length"));
					rod.setLength(rodJSON.getFloat("length"));
					rod.setDamping(rodJSON.getFloat("damping"));
					rod.setIsJoint(rodJSON.getBoolean("isJoint"));

					return rod;
			} else {
					Rigidbody rigidbodyA = this.getRigidbodyByID(rodJSON.getString("rigidbodyAID"));
					PVector localAnchorA = this.deserialize2DPVector(rodJSON.getJSONObject("localAnchorA"));
					PVector anchorPoint = this.deserialize2DPVector(rodJSON.getJSONObject("anchorPoint"));

					Rod rod = new Rod(rigidbodyA, localAnchorA, anchorPoint);
					rod.setLength(rodJSON.getFloat("length"));
					rod.setDamping(rodJSON.getFloat("damping"));
					rod.setIsJoint(rodJSON.getBoolean("isJoint"));
					return rod;
			}
	}

	private Motor deserializeMotor(JSONObject motorJSON) {
			Rigidbody rigidbody = this.getRigidbodyByID(motorJSON.getString("rigidbodyID"));

			Motor motor = new Motor(rigidbody);
			motor.setLocalAnchor(this.deserialize2DPVector(motorJSON.getJSONObject("localAnchor")));
			motor.setTargetAngularVelocity(motorJSON.getFloat("targetAngularVelocity"));
			motor.setDrawMotor(motorJSON.getBoolean("drawMotor"));
			motor.setDrawMotorForce(motorJSON.getBoolean("drawMotorForce"));

			return motor;

		}

	private Gravity deserializeGravity(JSONObject gravityJSON) {
			Rigidbody rigidbody = this.getRigidbodyByID(gravityJSON.getString("rigidbodyID"));
			return new Gravity(rigidbody);
	}


	private JSONObject serializeSpring(Spring spring) {
			JSONObject springJSON = new JSONObject();

			springJSON.setString("rigidbodyAID", spring.getRigidbodyA().getID());

			if(spring.getIsTwoBodySpring()) {
					springJSON.setString("rigidbodyBID", spring.getRigidbodyB().getID());
			}

			springJSON.setString("ForceType", "Spring");
			springJSON.setFloat("springConstant", spring.getSpringConstant());
			springJSON.setFloat("equilibriumLength", spring.getEquilibriumLength());
			springJSON.setFloat("damping", spring.getDamping());

			springJSON.setJSONObject("localAnchorA", serialize2DPVector(spring.getLocalAnchorA()));
			springJSON.setJSONObject("localAnchorB", serialize2DPVector(spring.getLocalAnchorB()));
			springJSON.setJSONObject("anchorPoint", serialize2DPVector(spring.getAnchorPoint()));

			springJSON.setBoolean("drawSpring", spring.getDrawSpring());
			springJSON.setBoolean("lockTranslationToXAxis", spring.getLockTranslationToXAxis());
			springJSON.setBoolean("lockTranslationToYAxis", spring.getLockTranslationToYAxis());

			springJSON.setBoolean("isPerfectSpring", spring.getPerfectSpring());
			springJSON.setBoolean("isTwoBodySpring", spring.getIsTwoBodySpring());
			springJSON.setFloat("springLength", spring.getSpringLength());

			return springJSON;
	}

	private JSONObject serializeRod(Rod rod) {
			JSONObject rodJSON = new JSONObject();

			rodJSON.setString("rigidbodyAID", rod.getRigidbodyA().getID());
			if(rod.getTwoBodyRod()) {
					rodJSON.setString("rigidbodyBID", rod.getRigidbodyB().getID());
			}
			rodJSON.setString("ForceType", "Rod");
			rodJSON.setFloat("length", rod.getLength());
			rodJSON.setFloat("damping", rod.getDamping());

			rodJSON.setJSONObject("localAnchorA", serialize2DPVector(rod.getLocalAnchorA()));
			rodJSON.setJSONObject("localAnchorB", serialize2DPVector(rod.getLocalAnchorB()));
			rodJSON.setJSONObject("anchorPoint", serialize2DPVector(rod.getAnchorPoint()));

			rodJSON.setBoolean("isTwoBodyRod", rod.getTwoBodyRod());
			rodJSON.setBoolean("isJoint", rod.getIsJoint());

			return rodJSON;
	}

	private JSONObject serializeMotor(Motor motor) {
			JSONObject motorJSON = new JSONObject();

			motorJSON.setString("ForceType", "Motor");
			motorJSON.setString("rigidbodyID", motor.getRigidbodyA().getID());
			motorJSON.setJSONObject("localAnchor", serialize2DPVector(motor.getLocalAnchor()));
			motorJSON.setFloat("targetAngularVelocity", motor.getTargetAngularVelocity());
			motorJSON.setBoolean("drawMotorForce", motor.getDrawMotorForce());
			motorJSON.setBoolean("drawMotor", motor.getDrawMotor());
			
			return motorJSON;
	}

	private JSONObject serializeGravity(Gravity gravity) {
			JSONObject gravityJSON = new JSONObject();

			gravityJSON.setString("ForceType", "Gravity");
			gravityJSON.setString("rigidbodyID", gravity.getRigidbodyA().getID());
			return gravityJSON;
	}


	private ShapeType deserializeShapeType(JSONObject shapeTypeJSON) {
			return ShapeType.valueOf(shapeTypeJSON.getString("shapeType"));
	}

	private JSONObject serialize2DPVector(PVector vector) {
			JSONObject vectorJSON = new JSONObject();

			vectorJSON.setFloat("x", vector.x);
			vectorJSON.setFloat("y", vector.y);
			return vectorJSON;
	}

	private PVector deserialize2DPVector(JSONObject vectorJSON) {
			return new PVector(vectorJSON.getFloat("x"), vectorJSON.getFloat("y"));
	}

	private JSONObject serialize3DPVector(PVector vector) {
			JSONObject vectorJSON = new JSONObject();

			vectorJSON.setFloat("x", vector.x);
			vectorJSON.setFloat("y", vector.y);
			vectorJSON.setFloat("z", vector.z);
			return vectorJSON;
	}

	private PVector deserialize3DPVector(JSONObject vectorJSON) {
			return new PVector(vectorJSON.getFloat("x"), vectorJSON.getFloat("y"), vectorJSON.getFloat("z"));
	}


	private JSONArray serializePVectorArray(PVector[] vectors) {
			JSONArray vectorArray = new JSONArray();
			if(vectors == null || vectors.length == 0) {
				return vectorArray;
			}
			for(PVector vector : vectors) {
				vectorArray.append(this.serialize2DPVector(vector));
			}
			return vectorArray;
	}

	private PVector[] deserializePVectorArray(JSONArray vectorArrayJSON) {
			PVector[] vectorArray = new PVector[vectorArrayJSON.size()];

			for(int i = 0; i < vectorArrayJSON.size(); i++) {
				vectorArray[i] = this.deserialize2DPVector(vectorArrayJSON.getJSONObject(i));
			}
			return vectorArray;
	}


	private Rigidbody getRigidbodyByID(String id) {
			for(Rigidbody body : rigidbodyList) {
					if(body.getID().equals(id)) {
						return body;
					}
			}
		return null;
	}

}










public class Motor implements ForceRegistry {

    private final Rigidbody rigidbody;
    private PVector localAnchor;

    private float targetAngularVelocity;

    private boolean drawMotorForce;
    private boolean drawMotor;


    public Motor(Rigidbody rigidbody) {
        this.rigidbody = rigidbody;
        this.localAnchor = new PVector(this.rigidbody.getRadius(), 0);
        this.drawMotorForce = true;
    }

    public Motor(Rigidbody rigidbody, float targetAngularVelocity) {
        this.rigidbody = rigidbody;
        this.targetAngularVelocity = targetAngularVelocity;
        this.localAnchor = new PVector(this.rigidbody.getRadius(), 0);
        this.drawMotorForce = true;
    }


@Override
public PVector getForce(Rigidbody rigidbody, PVector position) {

    if(this.rigidbody != rigidbody) {
        throw new IllegalArgumentException("Rigidbody is not the same as the one this force is applied to");
    }

    this.rigidbody.setAngularVelocity(targetAngularVelocity);
    
    return new PVector(0, 0);
    
    
}

@Override
public void draw() {

if(!drawMotorForce) {
    return;
}
    PVector position = this.rigidbody.getPosition();
    boolean isClockwise = targetAngularVelocity > 0;

    float size = this.rigidbody.getRadius() * 0.5f;
    float arrowSize = size * 0.15f;
    float startAngle = 0;
    float endAngle = 3 * PI/2;// Change this to control the curvature of the arrow

    // Draw the curved part of the arrow
    pushMatrix();
    translate(position.x, position.y);
    rotate(this.rigidbody.getAngle() + PI/6);
    noFill();
    stroke(255, 0, 0); // Red color
    arc(0, 0, size, size, startAngle, endAngle);

    // Calculate the start and end of the arc
    float startX =  size * cos(startAngle)/2;
    float startY = size * sin(startAngle)/2;
    float endX = size * cos(endAngle)/2;
    float endY = size * sin(endAngle)/2;

    fill(255, 0, 0); // Red color
    noStroke();
    
    if(isClockwise) {
        triangle(endX, endY-arrowSize, endX, endY+arrowSize, endX+arrowSize*2, endY);
    } else {
        triangle(startX-arrowSize, startY, startX + arrowSize, startY, startX, startY - 2 * arrowSize);
    }

    popMatrix();

}
@Override
public PVector getApplicationPoint(Rigidbody rigidbody, PVector position) {
    return PhysEngMath.Transform(localAnchor, position, rigidbody.getAngle());
}


/*
====================================================================================================
======================================== Getters and Setters ========================================
====================================================================================================
*/
    public void setTargetAngularVelocity(float targetAngularVelocity) {
        this.targetAngularVelocity = targetAngularVelocity;
    }

    public void setLocalAnchor(PVector localAnchor) {
        this.localAnchor = localAnchor;
    } 
    public void setDrawMotor(boolean drawMotor) {
        this.drawMotor = drawMotor;
    }

    public boolean getDrawMotor() {
        return drawMotor;
    }


    public boolean getDrawMotorForce() {
        return drawMotorForce;
    }

    public void setDrawMotorForce(boolean drawMotorForce) {
        this.drawMotorForce = drawMotorForce;
    }

    public float getTargetAngularVelocity() {
        return targetAngularVelocity;
    }

    public PVector getLocalAnchor() {
        return localAnchor;
    }
    @Override
    public Rigidbody getRigidbodyA(){
        return this.rigidbody;
    }
    @Override
    public Rigidbody getRigidbodyB(){
        return this.rigidbody;
    }



}

public int qCount = 0;
public boolean switchTab = true;


public boolean firstTime = true;
public Spring mouseSpring;
public boolean mouseSpringAdded = false;
public boolean rigidbodySelected = false;
public boolean isInEditMode = false;

public Rigidbody clickedRigidbody;

public boolean mouseDown = false;

public boolean shiftPressed = false;
public boolean tabPressed = false;
public boolean deletePressed = false;
public boolean ctrlEPressed = false;
public boolean ctrlCPressed = false;
public boolean ctrlVPressed = false;

public boolean onePressed = false;
public boolean twoPressed = false;
public boolean threePressed = false;
public boolean fourPressed = false;
public boolean fivePressed = false;
public boolean sixPressed = false;


public boolean dPressed = false;
public boolean wPressed = false;
public boolean sPressed = false;
public boolean aPressed = false;
public boolean qPressed = false;
public boolean cPressed = false;
public boolean rPressed = false;
public boolean ePressed = false;
public boolean vPressed = false;

public void keyPressed() {
    if(keyCode == BACKSPACE) {
        deletePressed = true;
    }
    if(key == 'c' || key == 'C') {
        cPressed = true;
    }
    
    if (key == 'd' || key == 'D') {
        dPressed = true;
    }

    if (key == 'w' || key == 'W') {
        wPressed = true;
    }
    if (key == 's' || key == 'S') {
        sPressed = true;
    }

    if (key == 'a' || key == 'A') {
        aPressed = true;
    }

    if(key == 'q' || key == 'Q') {
        qPressed = true;
    }

    if(key == 'e' || key == 'E') {
        ePressed = true;
    }
    if (keyCode == SHIFT) {
        shiftPressed = true;
    }

    if(key == 'v' || key == 'V') {
        vPressed = true;
    }

    if(key == ' ') {
        isPaused = !isPaused;
    }
    if(key == 'r') {
        rigidbodyList.clear();
        ALL_FORCES_ARRAYLIST.clear();
        softbodyList.clear();
    }
    if(keyCode == BACKSPACE || keyCode == DELETE) {
        Rigidbody rigidbody = interactivityListener.getClickedRigidbody();

        if(rigidbody != null) {
            ArrayList<ForceRegistry> forceRegistry = rigidbody.getForceRegistry();
            
            for(ForceRegistry force : forceRegistry) {
                ALL_FORCES_ARRAYLIST.remove(force);
            }
            rigidbodyList.remove(rigidbody);
        }
    }
    if(key == 69 || key == 101) {
        ctrlEPressed = true;
    }
    if(key == 67 || key == 99) {
        ctrlCPressed = true;
    }
    if(key == 86 || key == 118) {
        ctrlVPressed = true;
    }


    if(key == 'f') {
        levelEditor.saveLevelState();
    }
    if(key == 'g') {
        loadLevel = true;
    }

    if(key == 'm') {
        interactivityListener.position = new PVector(-50, -50);
        interactivityListener.zoom = 10f;
    }

    if(key == 'z' || key == 'Z') {
            qCount++;
            if(qCount == 1) {
                interactivityListener.setSnapToCenter(true);
                interactivityListener.setSnapToEdge(false);
    
                if(userInterface.getController("AddSpring").getValue() == 1) {
                    userInterface.getController("SpringSnapToCenter").setValue(1);
                    userInterface.getController("SpringSnapToEdge").setValue(0);
                } else if(userInterface.getController("AddRod").getValue() == 1) {
                    userInterface.getController("RodSnapToCenter").setValue(1);
                    userInterface.getController("RodSnapToEdge").setValue(0);
                }
            } else if(qCount == 2) {
                interactivityListener.setSnapToCenter(false);
                interactivityListener.setSnapToEdge(true);
    
                if(userInterface.getController("AddSpring").getValue() == 1) {
                    userInterface.getController("SpringSnapToCenter").setValue(0);
                    userInterface.getController("SpringSnapToEdge").setValue(1);
                } else if(userInterface.getController("AddRod").getValue() == 1) {
                    userInterface.getController("RodSnapToCenter").setValue(0);
                    userInterface.getController("RodSnapToEdge").setValue(1);
                }
            } else if(qCount == 3) {
                interactivityListener.setSnapToCenter(false);
                interactivityListener.setSnapToEdge(false);
    
                if(userInterface.getController("AddSpring").getValue() == 1) {
                    userInterface.getController("SpringSnapToCenter").setValue(0);
                    userInterface.getController("SpringSnapToEdge").setValue(0);
                } else if(userInterface.getController("AddRod").getValue() == 1) {
                    userInterface.getController("RodSnapToCenter").setValue(0);
                    userInterface.getController("RodSnapToEdge").setValue(0);
                }
                qCount = 0;
            }
    }

    if(qPressed) {
        if(shiftPressed) {
            if(userInterface.getTab("Rigidbodies").isActive()) {
                if(userInterface.getController("Angle").getValue() == -360) {
                    userInterface.getController("Angle").setValue(360);
                } else {
                    userInterface.getController("Angle").setValue(userInterface.getController("Angle").getValue() - 10);
                }
            }
        } else {
            if(userInterface.getTab("Rigidbodies").isActive()) {
                if(userInterface.getController("Angle").getValue() == -360) {
                    userInterface.getController("Angle").setValue(360);
                } else {
                    userInterface.getController("Angle").setValue(userInterface.getController("Angle").getValue() - 1);
                }
            }
        }
    }

    /*

      if(ctrlEPressed) {
        Rigidbody newClickedRigidbody = interactivityListener.getClickedRigidbody();
        if(newClickedRigidbody != null){
            interactivityListener.updateGUIValues(clickedRigidbody);
            interactivityListener.editRigidbody = true;
        }
    } else
*/
    /* ------------ FIX THIS ---------------- */

   if(ePressed) {
        if(shiftPressed){
            if(userInterface.getTab("Rigidbodies").isActive()) {
                if(userInterface.getController("Angle").getValue() == 360) {
                    userInterface.getController("Angle").setValue(-360);
                } else {
                    userInterface.getController("Angle").setValue(userInterface.getController("Angle").getValue() + 10);
                }
            }
        } else {
            if(userInterface.getTab("Rigidbodies").isActive()) {
                if(userInterface.getController("Angle").getValue() == 360) {
                    userInterface.getController("Angle").setValue(-360);
                } else {
                    userInterface.getController("Angle").setValue(userInterface.getController("Angle").getValue() + 1);
                }
            }
        }
    } 
/*----------------------------------------------------------------------------------- */

    

    if(key == '1') {
        if(userInterface.getTab("Forces").isActive()) {
            if(userInterface.getController("AddSpring").getValue() == 0){
                userInterface.getController("AddSpring").setValue(1);
                userInterface.getController("AddRod").setValue(0);
                userInterface.getController("AddMotor").setValue(0);
            } else {
                userInterface.getController("AddSpring").setValue(0);
                userInterface.getController("AddRod").setValue(0);
                userInterface.getController("AddMotor").setValue(0);
            }

        } else if(userInterface.getTab("Rigidbodies").isActive()) {
            if(userInterface.getController("Circle").getValue() == 0){
                userInterface.getController("Circle").setValue(1);
                userInterface.getController("Box").setValue(0);
            } else {
                userInterface.getController("Circle").setValue(0);
                userInterface.getController("Box").setValue(0);               
            }
        }
    }
    if(key == '2') {
        if(userInterface.getTab("Forces").isActive()) {
            if(userInterface.getController("AddRod").getValue() == 0){
                userInterface.getController("AddSpring").setValue(0);
                userInterface.getController("AddRod").setValue(1);
                userInterface.getController("AddMotor").setValue(0);
            } else {
                userInterface.getController("AddSpring").setValue(0);
                userInterface.getController("AddRod").setValue(0);
                userInterface.getController("AddMotor").setValue(0);
            }

        } else if(userInterface.getTab("Rigidbodies").isActive()) {
            if(userInterface.getController("Box").getValue() == 0){
                userInterface.getController("Circle").setValue(0);
                userInterface.getController("Box").setValue(1);
            } else {
                userInterface.getController("Circle").setValue(0);
                userInterface.getController("Box").setValue(0);               
            }
        }
    }
    if(key == '3') {
        if(userInterface.getTab("Forces").isActive()) {
            if(userInterface.getController("AddMotor").getValue() == 0){
                userInterface.getController("AddSpring").setValue(0);
                userInterface.getController("AddRod").setValue(0);
                userInterface.getController("AddMotor").setValue(1);
            } else {
                userInterface.getController("AddSpring").setValue(0);
                userInterface.getController("AddRod").setValue(0);
                userInterface.getController("AddMotor").setValue(0);
            }
        }
    }

    if(key == '4') {
        if(userInterface.getTab("Rigidbodies").isActive()) {
            if(userInterface.getController("isStatic").getValue() == 1) {
                userInterface.getController("isStatic").setValue(0);
            } else {
                userInterface.getController("isStatic").setValue(1);
            }

            userInterface.getController("transStatic").setValue(0);
            userInterface.getController("rotStatic").setValue(0);

        } else if(userInterface.getTab("Forces").isActive()) {
            if(userInterface.getController("AddSpring").getValue() == 1) {
                if(userInterface.getController("SpringLockToX").getValue() == 1) {
                    userInterface.getController("SpringLockToX").setValue(0);
                } else {
                    userInterface.getController("SpringLockToX").setValue(1);
                }
            } else if(userInterface.getController("AddRod").getValue() == 1) {
                if(userInterface.getController("RodIsHingeable").getValue() == 0){
                    userInterface.getController("RodIsHingeable").setValue(1);
                } else {
                    userInterface.getController("RodIsHingeable").setValue(0);
                }
            }
        }
    }

    if(key == '5') {
        if(userInterface.getTab("Rigidbodies").isActive()) {
            if(userInterface.getController("transStatic").getValue() == 1) {
                userInterface.getController("transStatic").setValue(0);
            } else {
                userInterface.getController("transStatic").setValue(1);
            }

            userInterface.getController("isStatic").setValue(0);
            userInterface.getController("rotStatic").setValue(0);
        } else if(userInterface.getTab("Forces").isActive()) {
            if(userInterface.getController("AddSpring").getValue() == 1){
                if(userInterface.getController("SpringLockToY").getValue() == 1) {
                    userInterface.getController("SpringLockToY").setValue(0);
                } else {
                    userInterface.getController("SpringLockToY").setValue(1);
                }
            } else if(userInterface.getController("AddRod").getValue() == 1) {
                if(userInterface.getController("RodIsJoint").getValue() == 0) {
                    userInterface.getController("RodIsJoint").setValue(1);
                } else {
                    userInterface.getController("RodIsJoint").setValue(0);
                }
            }
        }
    }

    if(key == '6') {
        if(userInterface.getTab("Rigidbodies").isActive()) {
            if(userInterface.getController("rotStatic").getValue() == 1) {
                userInterface.getController("rotStatic").setValue(0);
            } else {
                userInterface.getController("rotStatic").setValue(1);
            }

            userInterface.getController("isStatic").setValue(0);
            userInterface.getController("transStatic").setValue(0);
        }
    }

    if(key == TAB) {
        if(switchTab) {
            userInterface.getTab("Rigidbodies").bringToFront();

        } else {
            userInterface.getTab("Forces").bringToFront();
        }   
        switchTab = !switchTab;
    }

    if(aPressed) {
        if(shiftPressed) {
            if(userInterface.getTab("Rigidbodies").isActive()) {
                if(userInterface.getController("Circle").getValue() == 1) {
                    userInterface.getController("CircleRadius").setValue(userInterface.getController("CircleRadius").getValue() - 0.5f);
                }
                if(userInterface.getController("Box").getValue() == 1) {
                    userInterface.getController("RectangleWidth").setValue(userInterface.getController("RectangleWidth").getValue() - 1f);
                }
            } else if(userInterface.getTab("Forces").isActive()) {
                if(userInterface.getController("AddSpring").getValue() == 1) {
                    userInterface.getController("SpringConstant").setValue(userInterface.getController("SpringConstant").getValue() - 20f);
                }
                if(userInterface.getController("AddMotor").getValue() == 1) {
                    userInterface.getController("MotorTargetAngularVelocity").setValue(userInterface.getController("MotorTargetAngularVelocity").getValue() - 1f);
                }
            }
        } else {
            if(userInterface.getTab("Rigidbodies").isActive()) {
                if(userInterface.getController("Circle").getValue() == 1) {
                    userInterface.getController("CircleRadius").setValue(userInterface.getController("CircleRadius").getValue() - 0.05f);
                }
                if(userInterface.getController("Box").getValue() == 1) {
                    userInterface.getController("RectangleWidth").setValue(userInterface.getController("RectangleWidth").getValue() - 0.1f);
                }
            } else if(userInterface.getTab("Forces").isActive()) {
                if(userInterface.getController("AddSpring").getValue() == 1) {
                    userInterface.getController("SpringConstant").setValue(userInterface.getController("SpringConstant").getValue() - 1f);
                }
                if(userInterface.getController("AddMotor").getValue() == 1) {
                    userInterface.getController("MotorTargetAngularVelocity").setValue(userInterface.getController("MotorTargetAngularVelocity").getValue() - 0.1f);
                }
            }
        }
    }

    if(dPressed) {
        if(shiftPressed){
            if(userInterface.getTab("Rigidbodies").isActive()) {
                if(userInterface.getController("Circle").getValue() == 1) {
                    userInterface.getController("CircleRadius").setValue(userInterface.getController("CircleRadius").getValue() + 0.5f);
                }
                if(userInterface.getController("Box").getValue() == 1) {
                    userInterface.getController("RectangleWidth").setValue(userInterface.getController("RectangleWidth").getValue() + 1f);
                }
            } else if(userInterface.getTab("Forces").isActive()) {
                if(userInterface.getController("AddSpring").getValue() == 1) {
                    userInterface.getController("SpringConstant").setValue(userInterface.getController("SpringConstant").getValue() + 20f);
                }
                if(userInterface.getController("AddMotor").getValue() == 1) {
                    userInterface.getController("MotorTargetAngularVelocity").setValue(userInterface.getController("MotorTargetAngularVelocity").getValue() + 1f);
                }
            }
        } else {
            if(userInterface.getTab("Rigidbodies").isActive()) {
                if(userInterface.getController("Circle").getValue() == 1) {
                    userInterface.getController("CircleRadius").setValue(userInterface.getController("CircleRadius").getValue() + 0.05f);
                }
                if(userInterface.getController("Box").getValue() == 1) {
                    userInterface.getController("RectangleWidth").setValue(userInterface.getController("RectangleWidth").getValue() + 0.1f);
                }
            } else if(userInterface.getTab("Forces").isActive()) {
                if(userInterface.getController("AddSpring").getValue() == 1) {
                    userInterface.getController("SpringConstant").setValue(userInterface.getController("SpringConstant").getValue() + 1f);
                }
                if(userInterface.getController("AddMotor").getValue() == 1) {
                    userInterface.getController("MotorTargetAngularVelocity").setValue(userInterface.getController("MotorTargetAngularVelocity").getValue() + 0.1f);
                }
            }
        }
    }

   
    if(wPressed) {
        if(shiftPressed){
            if(userInterface.getTab("Rigidbodies").isActive()) {
                if(userInterface.getController("Circle").getValue() == 1) {
                    userInterface.getController("CircleRadius").setValue(userInterface.getController("CircleRadius").getValue() + 0.5f);
                }
                if(userInterface.getController("Box").getValue() == 1) {
                    userInterface.getController("RectangleHeight").setValue(userInterface.getController("RectangleHeight").getValue() + 1f);
                }
            }
        } else {
            if(userInterface.getTab("Rigidbodies").isActive()) {
                if(userInterface.getController("Circle").getValue() == 1) {
                    userInterface.getController("CircleRadius").setValue(userInterface.getController("CircleRadius").getValue() + 0.05f);
                }
                if(userInterface.getController("Box").getValue() == 1) {
                    userInterface.getController("RectangleHeight").setValue(userInterface.getController("RectangleHeight").getValue() + 0.1f);
                }
            }
        }
    }

    if(sPressed) {
        if(shiftPressed){
            if(userInterface.getTab("Rigidbodies").isActive()) {
                if(userInterface.getController("Circle").getValue() == 1) {
                    userInterface.getController("CircleRadius").setValue(userInterface.getController("CircleRadius").getValue() - 0.5f);
                }
                if(userInterface.getController("Box").getValue() == 1) {
                    userInterface.getController("RectangleHeight").setValue(userInterface.getController("RectangleHeight").getValue() - 1f);
                }
            }
        } else {
            if(userInterface.getTab("Rigidbodies").isActive()) {
                if(userInterface.getController("Circle").getValue() == 1) {
                    userInterface.getController("CircleRadius").setValue(userInterface.getController("CircleRadius").getValue() - 0.05f);
                }
                if(userInterface.getController("Box").getValue() == 1) {
                    userInterface.getController("RectangleHeight").setValue(userInterface.getController("RectangleHeight").getValue() - 0.1f);
                }
            }
        }
    }




    if(ctrlCPressed) {
        interactivityListener.updateGUIValues(interactivityListener.getClickedRigidbody());
    }

    if(ctrlVPressed) {
        //interactivityListener.GenerateRigidbody();
    }

    if(deletePressed) {
        if(isInEditMode) {
            editor.whileEditorSelect(2);
        }
    }

}

public void keyReleased() {

    if(keyCode == BACKSPACE) {
        deletePressed = false;
    }
    if (key == 'd' || key == 'D') {
        dPressed = false;
    }

    if (keyCode == SHIFT) {
        shiftPressed = false;
    }

    if(key == 'c' || key == 'C') {
        cPressed = false;
    }

    if(key == 67 || key == 99) {
        ctrlCPressed = false;
    }
    if(key == 86 || key == 118) {
        ctrlVPressed = false;
    }
    if(key == 69 || key == 101) {
        ctrlEPressed = false;
    }

    if (key == 'w' || key == 'W') {
        wPressed = false;
    }
    if (key == 's' || key == 'S') {
        sPressed = false;
    }
    if (key == 'a' || key == 'A') {
        aPressed = false;
    }
    if(key == 'q' || key == 'Q') {
        qPressed = false;
    }
    if(key == 'e' || key == 'E') {
        ePressed = false;
    }
    if(key == 'v' || key == 'V') {
        vPressed = false;
    }

}


public void mousePressed(){
    if(mouseButton == LEFT){
        if(shiftPressed) {
            clickedRigidbody = interactivityListener.getClickedRigidbody();

            if(clickedRigidbody != null){
                if(firstTime){
                    mouseSpringAdded = true;
                    PVector mouseCoordinates = interactivityListener.screenToWorld();
                    PVector localAnchorA = PhysEngMath.Transform(PhysEngMath.SnapController(interactivityListener, this.clickedRigidbody, mouseCoordinates), -this.clickedRigidbody.getAngle());
                    //PVector localAnchorA = PhysEngMath.Transform(PVector.sub(mouseCoordinates, clickedRigidbody.getPosition()), -clickedRigidbody.getAngle());

                    mouseSpring = new Spring(clickedRigidbody, localAnchorA, mouseCoordinates);
                    mouseSpring.setSpringConstant(200f);
                    mouseSpring.setSpringLength(0f);
                    clickedRigidbody.addForceToForceRegistry(mouseSpring);
                    firstTime = false;
                } else {
                    mouseSpringAdded = true;
                    PVector mouseCoordinates = interactivityListener.screenToWorld();
                    PVector localAnchorA = PhysEngMath.Transform(PhysEngMath.SnapController(interactivityListener, this.clickedRigidbody, mouseCoordinates), -clickedRigidbody.getAngle());

                    mouseSpring.setRigidbodyA(clickedRigidbody);
                    mouseSpring.setLocalAnchorA(localAnchorA.x, localAnchorA.y);
                    mouseSpring.setAnchorPoint(mouseCoordinates.x, mouseCoordinates.y);
                    clickedRigidbody.addForceToForceRegistry(mouseSpring);
                }
            }
        } else {
            /* Velocity Calculation Stuff */
            interactivityListener.mouseDown = true;
            interactivityListener.initialMousePosition.set(interactivityListener.screenToWorld());
            /* Velocity Calculation Stuff */
        } 
    }
}

public void mouseReleased(){
    if(mouseButton == LEFT){

        interactivityListener.mouseDown = false;

        if(mouseSpringAdded && clickedRigidbody != null){
            mouseSpringAdded = false;
            clickedRigidbody.removeForceFromForceRegistry(mouseSpring);
        } else {
            if(userInterface.getTab("Rigidbodies").isActive() && !userInterface.getTab("Forces").isActive()) {
                interactivityListener.GenerateRigidbody();
            } else if(userInterface.getTab("Forces").isActive() && !userInterface.getTab("Rigidbodies").isActive()) {
                interactivityListener.addSelectedRigidbody();
                interactivityListener.updateSelectedRigidbodies();
                interactivityListener.createForces();
            }
        }
    }
}

public void mouseClicked() {
    if(mouseButton == LEFT) {
        if(ctrlVPressed) {
            Rigidbody rigidbody = interactivityListener.getClickedRigidbody();
            if(!isInEditMode && rigidbody != null) {
                isInEditMode = true;
                editor.onEditorSelect(rigidbody);
                System.out.println("In Edit mode");
                return;
            } else if(isInEditMode) {
                isInEditMode = false;
                editor.onEditorDeselect();
                System.out.println("Out of Edit mode");
                return;
            }
        }

        editor.whileEditorSelect(0);
    } 
}

public void mouseWheel(MouseEvent event) {
    if(!userInterface.isMouseOver()) {
        float e = -event.getCount();
        interactivityListener.zoom(pow(1.1f, e), mouseX, mouseY);
    }
}

public void mouseDragged() {
    if(!userInterface.isMouseOver() && mouseButton == RIGHT){
        interactivityListener.move(pmouseX - mouseX, pmouseY - mouseY);
    }
    if(!userInterface.isMouseOver() && mouseButton == LEFT) {
        if(mouseSpringAdded){
            PVector mousePos = interactivityListener.screenToWorld();
            mouseSpring.setAnchorPoint(mousePos.x, mousePos.y);
        } else if(isInEditMode) {
            editor.whileEditorSelect(1);
        }
    }
}

public void mouseMoved() {
   // Mouse.updateMouseCoordinates();
}


public boolean IsMouseOverUI() {
  if(userInterface.isMouseOver() || gui.calculateGroupPositionX() < mouseX && mouseX < gui.calculateGroupPositionX() + gui.globalGroupWidth &&  gui.calculateGroupPositionY() < mouseY && mouseY <  gui.calculateGroupPositionY() +  gui.globalGroupHeight) {
    return true;
    } else {
    return false;
    }
}

public class MouseObject {

	private ArrayList<MouseObjectResult> interactionResults = new ArrayList<MouseObjectResult>();

	private PVector mouseCoordinates = new PVector();

    private PVector mouseDownCoordinates = new PVector();
    private PVector mouseUpCoordinates = new PVector();

	private Rigidbody currentMouseOverRigidbody;


	private boolean isMouseOverUI = false;
  	private boolean showCursorTrail = true;
  	private ArrayList<PVector> cursorTrailArrayList = new ArrayList<PVector>();


	public MouseObject() {
		//Do nothing
		
	}


	public boolean IsMouseOverUI() {
  		if(GUI_GROUP_POSITION_X < mouseX && mouseX < GUI_GROUP_POSITION_X + GUI_GLOBAL_GROUP_WIDTH &&  GUI_GROUP_POSITION_Y < mouseY && mouseY <  GUI_GROUP_POSITION_Y + GUI_GLOBAL_GROUP_HEIGHT) {
    		return true;
    	} else {
    		return false;
    	}
	}


	public Rigidbody getRigidbodyUnderMouse() {
        PVector mouseCoordinates = interactivityListener.screenToWorld();
    	for (Rigidbody rigidbody : rigidbodyList) {
            if(!Collisions.IntersectAABBWithPoint(rigidbody.GetAABB(), mouseCoordinates)) {
           		continue;
            }
            if (rigidbody.contains(mouseCoordinates.x, mouseCoordinates.y)) {
           		return rigidbody;
            }
    	}
    	return null;
	}	


	public void addSelectedRigidbody() {
		if(this.interactionResults.size() > 2) {
			this.interactionResults.clear();
		}
		this.interactionResults.add(new MouseObjectResult(this.getRigidbodyUnderMouse(), this.mouseCoordinates));
	}


	public void updateMouseCoordinates() {
		this.isMouseOverUI = this.IsMouseOverUI();
		mouseCoordinates.set(PhysEngMath.WorldSnapController(interactivityListener, this.getRigidbodyUnderMouse(), interactivityListener.screenToWorld()));
	}

    public void updateMouseDownCoordinates() {
        this.mouseDownCoordinates.set(PhysEngMath.WorldSnapController(interactivityListener, this.getRigidbodyUnderMouse(), interactivityListener.screenToWorld()));
    }

    public void updateMouseUpCoordinates() {
        this.mouseUpCoordinates.set(PhysEngMath.WorldSnapController(interactivityListener, this.getRigidbodyUnderMouse(), interactivityListener.screenToWorld()));
    }





    public void DrawMouseCursor() {
        fill(255, 0, 0);
        strokeWeight(0.1f);
        stroke(255, 0, 0);
        ellipse(this.mouseCoordinates.x, this.mouseCoordinates.y, 0.1f, 0.1f);

        if(this.showCursorTrail) {
        	if(cursorTrailArrayList.size() < 20) {
        		cursorTrailArrayList.add(new PVector(mouseCoordinates.x, mouseCoordinates.y));
        	} else {
                cursorTrailArrayList.add(cursorTrailArrayList.get(0).set(this.mouseCoordinates.x, this.mouseCoordinates.y));
                cursorTrailArrayList.remove(0);
        	}

            noFill();
            beginShape();
                for(PVector cursorTrailVertex : cursorTrailArrayList) {
                    curveVertex(cursorTrailVertex.x, cursorTrailVertex.y);
                }
            endShape();
        }
    }



	public PVector getMouseCoordinates() {
		return mouseCoordinates;
	}
    
    public PVector getMouseDownCoordinates() {
        return mouseDownCoordinates;
    }
    
    public PVector getMouseUpCoordinates() {
        return mouseUpCoordinates;
    }

	public boolean getIsMouseOverUI() {
		return isMouseOverUI;
	}
}
public class MouseObjectResult {
	private Rigidbody SelectedRigidbody;
	private PVector SelectedRigidbodyPosition;
	private PVector Coordinate;


	public MouseObjectResult(Rigidbody selectedRigidbody, PVector coordinate) {

		this.SelectedRigidbody = selectedRigidbody;

		if(this.SelectedRigidbody != null) {
			this.SelectedRigidbodyPosition = selectedRigidbody.getPosition();
		}

		this.Coordinate = coordinate;
	}


	public Rigidbody getSelectedRigidbody() {
		return this.SelectedRigidbody;
	}

	public PVector getWorldCoordinate() {
		return this.Coordinate;
	}

	public PVector getLocalCoordinate() {
		return PVector.sub(this.Coordinate, this.SelectedRigidbodyPosition);
	}

	public String toString() {
		return "MouseObjectResult: " + SelectedRigidbody + ", " + Coordinate;
	}


}

public static class PhysEngMath {

    private static final PVector emptyVector = new PVector(0, 0);
    
    //Precision for float comparison, equal to 0.00005 meters
    public static final float precision = 0.0001f;

    public static float Clamp(float value, float min, float max) {
        if (min == max) {
            return min;
        } else if (min > max) {
            throw new IllegalArgumentException("min must be less than max");
        } else if (value < min) {
            return min;
        } else if (value > max) {
            return max;
        } else {
            return value;
        }
  }

public static float fastInverseSq(PVector vector) {
    return fastInverseSq(vector.x * vector.x + vector.y * vector.y);
}


public static float fastInverseSq (float number) {
    float x = number;
    float xhalf = 0.5f * x;
    int i = Float.floatToIntBits(x);
    i = 0x5f3759df - (i >> 1);
    x = Float.intBitsToFloat(i);
    for (int it = 0; it < 2; it++) { // Reduced iterations for float
        x = x * (1.5f - xhalf * x * x);
    }
    x *= number;
    return x;
}

public static PVector[] OrderVerticesClockwise(PVector[] vertices) {
  // Calculate the centroid
  PVector centroid = new PVector(0, 0);
  for (PVector v : vertices) {
    centroid.add(v);
  }
  centroid.div(vertices.length);

  // Calculate angle for each vertex
  float[] angles = new float[vertices.length];
  for (int i = 0; i < vertices.length; i++) {
    angles[i] = PVector.sub(vertices[i], centroid).heading();
  }

  // Sort vertices based on angles
  for (int i = 0; i < angles.length; i++) {
    for (int j = i + 1; j < angles.length; j++) {
      if (angles[i] > angles[j]) {
        // Swap angles
        float tempAngle = angles[i];
        angles[i] = angles[j];
        angles[j] = tempAngle;
        // Swap vertices
        PVector tempVertex = vertices[i];
        vertices[i] = vertices[j];
        vertices[j] = tempVertex;
      }
    }
  }

  // Return ordered vertices
  return vertices;
}

public static PVector MouseVelocityCalculationAndClamp(PVector initial, PVector current, float min, float max) {

    float dx = current.x - initial.x;
    float dy = current.y - initial.y;

    float magnitude = fastInverseSq(dx * dx + dy * dy);  

    if (Equals(magnitude, 0f)) { // To avoid division by zero
        dx = 0f;
        dy = 0f;
    } else {
        dx /= magnitude;
        dy /= magnitude;
    }

    magnitude = constrain(magnitude, min, max);

    dx *= magnitude;
    dy *= magnitude;

    return new PVector(dx, dy);
}


public static PVector SquareVelocity(PVector vector) {
    float x = vector.x;
    float y = vector.y;

    float magSq = x * x + y * y;
    float mag = fastInverseSq(magSq);

    if(Equals(mag, 0f)) {
        x = 0f;
        y = 0f;
    } else {
        x /= mag;
        y /= mag;
    }

    return new PVector(x * magSq, y * magSq);
}

public static PVector Clamp(PVector vector, float min, float max) {

    float dx = vector.x;
    float dy = vector.y;

    float mag = fastInverseSq(dx * dx + dy * dy);

    if (Equals(mag, 0f)) { // To avoid division by zero
        dx = 0f;
        dy = 0f;
    } else {
        dx /= mag;
        dy /= mag;
    }

    mag = constrain(mag, min, max);

    dx *= mag;
    dy *= mag;

    return new PVector(dx, dy);
  }

  public static int Clamp(int value, int min, int max) {
    if (min == max) {
      return min;
    } else if (min > max) {
      throw new IllegalArgumentException("min must be less than max");
    } else if (value < min) {
      return min;
    } else if (value > max) {
      return max;
    } else {
      return value;
    }
  }
  

  public static PVector Transform(PVector vertex, float angle) {
    float sin = sin(angle);
    float cos = cos(angle);

    return new PVector(vertex.x * cos - vertex.y * sin, vertex.x * sin + vertex.y * cos);
  }
  
  public static PVector Transform(PVector vertex, PVector position, float angle){
    float sin = sin(angle);
    float cos = cos(angle);
    
    return new PVector(vertex.x * cos - vertex.y * sin + position.x, vertex.x * sin + vertex.y * cos + position.y);
  }

  public static PVector ReverseTransform(PVector vertex, PVector position, float angle){
  // Translate the vertex by the position first
  PVector translatedVertex = new PVector(vertex.x + position.x, vertex.y + position.y);

  // Then, calculate sine and cosine for the angle to rotate the translated vertex
  float sin = (float) Math.sin(angle); // Use Math.sin for Java
  float cos = (float) Math.cos(angle); // Use Math.cos for Java

  // Rotate the translated vertex
  return new PVector(
    translatedVertex.x * cos - translatedVertex.y * sin, // Rotate x
    translatedVertex.x * sin + translatedVertex.y * cos  // Rotate y
  );
}

  
  //Overloaded method for Transform
    public static PVector Transform(float x, float y, float angle) {
        float sin = sin(angle);
        float cos = cos(angle);
    
        return new PVector(x * cos - y * sin + x, x * sin + y * cos + y);
  }

  

  public static PVector zeroTransform = Transform(0, 0, 0);



    public static boolean Equals(float a, float b) {
        return Math.abs(a - b) < precision;
    }

public static boolean Equals(PVector a, PVector b) {
    return PVector.sub(a, b).magSq() < precision * precision; //magSq is faster than mag
  }

    

public static PVector SnapController(InteractivityListener interactivityListener, Rigidbody rigidbody, PVector point) {
    if(rigidbody == null) {
        return point;
    }

    if(interactivityListener.getSnapGeneral()) {
        if(rigidbody.getShapeType() == ShapeType.BOX) {
            PVector[] vertices = rigidbody.GetTransformedVertices();

            for(int i = 0; i < vertices.length; i++) {
                if(PVector.sub(vertices[i], point).magSq() < VERTEX_SNAP_RADIUS) {
                    return PVector.sub(vertices[i], rigidbody.getPosition());
                }
            }

            PVector closestPoint = new PVector();
            float minDistanceSq = Float.MAX_VALUE;

            for (int i = 0; i < vertices.length; i++) {
                PVector start = vertices[i];
                PVector end = vertices[(i + 1) % vertices.length]; // Loop back to the first vertex

                PVector closestOnEdge = getClosestPointOnLine(start, end, point);
                float distanceSq = PVector.dist(closestOnEdge, point);

                if (distanceSq < minDistanceSq) {
                    minDistanceSq = distanceSq;
                    closestPoint = closestOnEdge;
                }
            }

            if(PVector.sub(closestPoint, rigidbody.getPosition()).magSq() / 2 > PVector.sub(point, rigidbody.getPosition()).magSq()) {
                return new PVector();
            } else {
                return PVector.sub(closestPoint, rigidbody.getPosition());
            }

        } else if(rigidbody.getShapeType() == ShapeType.CIRCLE) {
            if(PVector.sub(point, rigidbody.getPosition()).magSq() < rigidbody.getRadius()/2) {
                return new PVector();
            } else {
                return point.sub(rigidbody.getPosition()).normalize().mult(rigidbody.getRadius()).copy();
            }
        } else {
            throw new IllegalArgumentException("Rigidbody is not a circle or box");
        }
    } else {
        return PVector.sub(point, rigidbody.getPosition());
    }
}

public static PVector WorldSnapController(InteractivityListener interactivityListener, Rigidbody rigidbody, PVector point) {
    if(rigidbody == null) {
        return point;
    }

    if(interactivityListener.getSnapGeneral()) {
        if(rigidbody.getShapeType() == ShapeType.BOX) {
            PVector[] vertices = rigidbody.GetTransformedVertices();

            for(int i = 0; i < vertices.length; i++) {
                if(PVector.sub(vertices[i], point).magSq() < VERTEX_SNAP_RADIUS) {
                    return vertices[i];
                }
            }

            PVector closestPoint = new PVector();
            float minDistanceSq = Float.MAX_VALUE;

            for (int i = 0; i < vertices.length; i++) {
                PVector start = vertices[i];
                PVector end = vertices[(i + 1) % vertices.length]; // Loop back to the first vertex

                PVector closestOnEdge = getClosestPointOnLine(start, end, point);
                float distanceSq = PVector.dist(closestOnEdge, point);

                if (distanceSq < minDistanceSq) {
                    minDistanceSq = distanceSq;
                    closestPoint = closestOnEdge;
                }
            }

            if(PVector.sub(closestPoint, rigidbody.getPosition()).magSq() / 2 > PVector.sub(point, rigidbody.getPosition()).magSq()) {
                return rigidbody.getPosition();
            } else {
                return closestPoint;
            }

        } else if(rigidbody.getShapeType() == ShapeType.CIRCLE) {
            if(PVector.sub(point, rigidbody.getPosition()).magSq() < rigidbody.getRadius()/2) {
                return rigidbody.getPosition();
            } else {
                return point.sub(rigidbody.getPosition()).normalize().mult(rigidbody.getRadius()).add(rigidbody.getPosition());
            }
        } else {
            throw new IllegalArgumentException("Rigidbody is not a circle or box");
        }
    } else {
        return point;
    }
}


    public static PVector[] reverseVertices(PVector[] vertices) {
        PVector[] reversedVertices = new PVector[vertices.length];

        for (int i = 0; i < vertices.length; i++) {
            reversedVertices[i] = vertices[vertices.length - 1 - i];
        }
        return reversedVertices;
    }

    private static PVector getClosestPointOnLine(PVector start, PVector end, PVector point) {
        PVector line = PVector.sub(end, start);
        float len = line.mag();
        line.normalize();
        PVector v = PVector.sub(point, start);
        float d = PVector.dot(v, line);
        d = constrain(d, 0, len);
        return PVector.add(start, line.mult(d));
    }

}
/*------------------------Related to Timekeeping Debugging ---------------------------------------*/
public long totalWorldStepTime;
public long subWorldStepTime;

public int totalBodyCount;
public double systemTime;

public int totalSampleCount;
public int subSampleCount;

public double totalStepTime;
public double subStepTime;
public int bodyCount;

String totalStepTimeUnit;
String subStepTimeUnit;


int lastFrameTime;
float dt;
float fps;
float displayTimeStep;

public static boolean isPaused = false;

/*------------------------------------------------------------------------------------------------*/


/*
====================================================================================================
===================================  PHYSICS ENGINE OBJECTS  =======================================
====================================================================================================
*/
/*------------------------------------ NEVER CHANGE THIS -----------------------------------------*/

public static ArrayList<PVector> pointsOfContactList = new ArrayList<PVector>();


public InteractivityListener interactivityListener = new InteractivityListener();
public MouseObject Mouse = new MouseObject();
public ControlP5 userInterface;


public Rigidbody RigidbodyGenerator = new Rigidbody();
public Shape render = new Shape();

public Level levelEditor = new Level();
public Editor editor = new Editor();

public static ArrayList<Rigidbody> rigidbodyList = new ArrayList<Rigidbody>();
public static ArrayList<Softbody> softbodyList = new ArrayList<Softbody>();

public ArrayList<ArrayList<Integer>> collisionPairs = new ArrayList<ArrayList<Integer>>();
    

public PVector[] contactList = new PVector[0];
public PVector[] impulseList = new PVector[2];
public PVector[] raList = new PVector[2]; 
public PVector[] rbList = new PVector[2];
public PVector[] frictionImpulseList = new PVector[2];
public float[] jList = new float[2];

/*
====================================================================================================
===================================  PHYSICS ENGINE CONSTANTS  =====================================
====================================================================================================
*/

public final float MIN_BODY_AREA = 0.001f * 0.001f; // m^2
public final float MAX_BODY_AREA = 300f * 300f; // m^2

public final float MIN_BODY_DENSITY = 0.01f; //g/cm^3
public final float MAX_BODY_DENSITY = 300.0f; //g/cm^3

public final float MIN_BODY_WIDTH = 0.01f; // m
public final float MAX_BODY_WIDTH = 300; // m

public final float MIN_BODY_HEIGHT = 0.01f; // m
public final float MAX_BODY_HEIGHT = 300.0f; // m

public final float MIN_BODY_RADIUS = 0.01f;
public final float MAX_BODY_RADIUS = 300.0f;

public final float MIN_MOUSE_VELOCITY_MAG = 0.0f;
public final float MAX_MOUSE_VELOCITY_MAG = 15.0f;

public final int MIN_ITERATIONS = 1;
public final int MAX_ITERATIONS = 1024;

public PVector BACKGROUND_COLOUR = new PVector(16, 18, 19);

public int SUB_STEP_COUNT = 128;
public boolean DRAW_CONTACT_POINTS = false;
public boolean DRAW_AABBS = false;


public final PVector GRAVITY_VECTOR = new PVector(0, 9.81f, 0);
public final float GRAVITY_MAG = 9.81f;

public ArrayList<ForceRegistry> ALL_FORCES_ARRAYLIST = new ArrayList<ForceRegistry>();


public static float VERTEX_SNAP_RADIUS = 0.25f;
public float GUI_GROUP_POSITION_X;
public float GUI_GROUP_POSITION_Y;
public float GUI_GLOBAL_GROUP_WIDTH;
public float GUI_GLOBAL_GROUP_HEIGHT;


/*
====================================================================================================
===================================  PHYSICS ENGINE METHODS  =======================================
====================================================================================================
*/


//Iterations for substeps for each frame
public void Step(float dt, int totalIterations) {
    
    
    /*-----------------Related to Timekeeping Debugging -----------------*/
    long totalWorldStepTimeStart = System.nanoTime();
    /*-------------------------------------------------------------------*/
    
    
    totalIterations = PhysEngMath.Clamp(totalIterations, MIN_ITERATIONS, MAX_ITERATIONS);
    
    for (int currentIteration = 0; currentIteration < totalIterations; currentIteration++) {
        
        /*-----------------Related to Timekeeping Debugging -----------------*/
        long subWorldStepTimeStart = System.nanoTime();
        /*-------------------------------------------------------------------*/
        
        
        this.collisionPairs.clear();

        StepBodies(dt, totalIterations);
        BroadPhaseStep();
        NarrowPhaseStep();
        
        /*-----------------Related to Timekeeping Debugging -----------------*/
        subSampleCount++;
        subWorldStepTime += System.nanoTime() - subWorldStepTimeStart;
        /*-------------------------------------------------------------------*/
}
    /*-----------------Related to Timekeeping Debugging -----------------*/
    totalSampleCount++;
    totalWorldStepTime += System.nanoTime() - totalWorldStepTimeStart;
    /*-------------------------------------------------------------------*/
}


/*
====================================================================================================
=================================== Collision Resolution Methods ===================================
====================================================================================================
*/

public void SeperateBodies(Rigidbody rigidbodyA, Rigidbody rigidbodyB, PVector minimumTranslationVector) {
    
    if (rigidbodyA.getIsStatic() || rigidbodyA.getIsTranslationallyStatic()) {
        
        rigidbodyB.Move(minimumTranslationVector);
        
    } else if (rigidbodyB.getIsStatic() || rigidbodyB.getIsTranslationallyStatic()) {
        
        rigidbodyA.Move(PVector.mult(minimumTranslationVector, -1.0f));
        
    } else {
        
        rigidbodyA.Move(PVector.mult(minimumTranslationVector, -0.5f));
        rigidbodyB.Move(PVector.mult(minimumTranslationVector, 0.5f));
    }
}


public void ResolveCollisionLinear(CollisionManifold collisionManifold) {
    
    Rigidbody rigidbodyA = collisionManifold.getRigidbodyA();
    Rigidbody rigidbodyB = collisionManifold.getRigidbodyB();
    PVector normal = collisionManifold.getNormal();
    float depth = collisionManifold.getDepth();
    
    
    PVector velocityA = rigidbodyA.getVelocity().copy();
    PVector velocityB = rigidbodyB.getVelocity().copy();
    float restitution = min(rigidbodyA.getRestitution(), rigidbodyB.getRestitution());
    PVector relativeVelocity = PVector.sub(velocityB, velocityA);
    
    if (PVector.dot(relativeVelocity, normal) > 0.0f) {
        return;
    }
    
    float invMassA = rigidbodyA.getInvMass();
    float invMassB = rigidbodyB.getInvMass();
    
    float j = -(1f + restitution) * PVector.dot(relativeVelocity, normal) / (invMassA + invMassB);
    
    PVector impulse = PVector.mult(normal, j);
    
    
    velocityA = PVector.add(velocityA, PVector.mult(PVector.mult(impulse, -1), invMassA));
    velocityB = PVector.add(velocityB, PVector.mult(impulse, invMassB));
    
    rigidbodyA.setVelocity(velocityA);
    rigidbodyB.setVelocity(velocityB);
    
}

public void ResolveCollisionRotation(CollisionManifold contact) {
    
    Rigidbody rigidbodyA = contact.getRigidbodyA();
    Rigidbody rigidbodyB = contact.getRigidbodyB();
    float invMassA = rigidbodyA.getInvMass();
    float invMassB = rigidbodyB.getInvMass();
    float invRotationalInertiaA = rigidbodyA.getInvRotationalInertia();
    float invRotationalInertiaB = rigidbodyB.getInvRotationalInertia();
    PVector normal = contact.getNormal();
    PVector velocityA = rigidbodyA.getVelocity();
    PVector velocityB = rigidbodyB.getVelocity();
    float angularVelocityA = rigidbodyA.getAngularVelocity();
    float angularVelocityB = rigidbodyB.getAngularVelocity();

    int contactCount = contact.getContactCount();
    contactList = contact.getPointsOfContact();

    float e = min(rigidbodyA.getRestitution(), rigidbodyB.getRestitution());


    for(int i = 0; i < contactCount; i++) {
        this.impulseList[i] = new PVector();
        this.raList[i] = new PVector();
        this.rbList[i] = new PVector();
    }

    for (int i = 0; i < contactCount; i++) {
        PVector ra = PVector.sub(contactList[i], rigidbodyA.getPosition());
        PVector rb = PVector.sub(contactList[i], rigidbodyB.getPosition());

        raList[i] = ra;
        rbList[i] = rb;

        PVector raPerp = new PVector(-ra.y, ra.x);
        PVector rbPerp = new PVector(-rb.y, rb.x);

        PVector angularLinearVelocityA = PVector.mult(raPerp, angularVelocityA);
        PVector angularLinearVelocityB = PVector.mult(rbPerp, angularVelocityB);

        PVector relativeVelocity = PVector.sub(PVector.add(velocityB, angularLinearVelocityB),
                                               PVector.add(velocityA, angularLinearVelocityA));

        float contactVelocityMag = relativeVelocity.dot(normal);

        if (contactVelocityMag > 0f) {
            continue;
        }

        float raPerpDotN = raPerp.dot(normal);
        float rbPerpDotN = rbPerp.dot(normal);

        float denom = (invMassA + invMassB) +
            ((raPerpDotN * raPerpDotN) * invRotationalInertiaA) +
            ((rbPerpDotN * rbPerpDotN) * invRotationalInertiaB);

        float j = -(1f + e) * contactVelocityMag;
        j /= denom;
        j /= (float)contactCount;

        PVector impulse = PVector.mult(normal, j);
        impulseList[i] = impulse;
    }

    for(int i = 0; i < contactCount; i++) {
        PVector impulse = impulseList[i];
        PVector ra = raList[i];
        PVector rb = rbList[i];

        //float raCrossImpulse = ra.x * impulse.y - ra.y * impulse.x;
        //float rbCrossImpulse = rb.x * impulse.y - rb.y * impulse.x;

        velocityA.add(PVector.mult(impulse, -invMassA));
        velocityB.add(PVector.mult(impulse, invMassB));

        angularVelocityA += ra.cross(impulse).z * -1 * invRotationalInertiaA;
        angularVelocityB += rb.cross(impulse).z * invRotationalInertiaB;

        rigidbodyA.setVelocity(velocityA);
        rigidbodyB.setVelocity(velocityB);
        rigidbodyA.setAngularVelocity(angularVelocityA);
        rigidbodyB.setAngularVelocity(angularVelocityB);
    }
}


public void ResolveCollisionRotationAndFriction(CollisionManifold contact) {

    Rigidbody rigidbodyA = contact.getRigidbodyA();
    Rigidbody rigidbodyB = contact.getRigidbodyB();

    float invMassA = rigidbodyA.getInvMass();
    float invMassB = rigidbodyB.getInvMass();

    float invRotationalInertiaA = rigidbodyA.getInvRotationalInertia();
    float invRotationalInertiaB = rigidbodyB.getInvRotationalInertia();

    PVector positionA = rigidbodyA.getPosition();
    PVector positionB = rigidbodyB.getPosition();

    PVector velocityA = rigidbodyA.getVelocity();
    PVector velocityB = rigidbodyB.getVelocity();

    float angularVelocityA = rigidbodyA.getAngularVelocity();
    float angularVelocityB = rigidbodyB.getAngularVelocity();

    PVector normal = contact.getNormal();
    int contactCount = contact.getContactCount();
    contactList = contact.getPointsOfContact();



    float restitution = min(rigidbodyA.getRestitution(), rigidbodyB.getRestitution());

    float coefficientOfStaticFriction = (rigidbodyA.getCoefficientOfStaticFriction()
                                        + rigidbodyB.getCoefficientOfStaticFriction()) * 0.5f;
    float coefficientOfKineticFriction = (rigidbodyA.getCoefficientOfKineticFriction()
                                         + rigidbodyB.getCoefficientOfKineticFriction()) * 0.5f;
    
    for(int i = 0; i < contactCount; i++) {
        this.impulseList[i] = new PVector();
        this.raList[i] = new PVector();
        this.rbList[i] = new PVector();
        this.frictionImpulseList[i] = new PVector();
        this.jList[i] = 0f;
    }

    for(int i = 0; i < contactCount; i++) {

        PVector ra = PVector.sub(contactList[i], positionA);
        PVector rb = PVector.sub(contactList[i], positionB);

        raList[i] = ra;
        rbList[i] = rb;

        PVector raPerp = new PVector(-ra.y, ra.x);
        PVector rbPerp = new PVector(-rb.y, rb.x);

        PVector angularLinearVelocityA = PVector.mult(raPerp, angularVelocityA);
        PVector angularLinearVelocityB = PVector.mult(rbPerp, angularVelocityB);

        PVector relativeVelocity = PVector.sub(PVector.add(velocityB, angularLinearVelocityB),
                                               PVector.add(velocityA, angularLinearVelocityA));

        float contactVelocityMagnitude = relativeVelocity.dot(normal);
        
        if(contactVelocityMagnitude > 0f) {
            continue;
        }
        
        float raPerpendicularDotN = raPerp.dot(normal);
        float rbPerpendicularDotN = rbPerp.dot(normal);

        float denom = invMassA + invMassB
                    + (raPerpendicularDotN * raPerpendicularDotN) * invRotationalInertiaA
                    + (rbPerpendicularDotN * rbPerpendicularDotN) * invRotationalInertiaB;

        float j = -(1f + restitution) * contactVelocityMagnitude;
        j /= denom;
        j /= (float)contactCount;

        jList[i] = j;

        PVector impulse = PVector.mult(normal, j);
        impulseList[i] = impulse;
    }

    for(int i = 0; i < contactCount; i++) {

        PVector impulse = impulseList[i];
        PVector ra = raList[i];
        PVector rb = rbList[i];

        velocityA.add(PVector.mult(impulse, -invMassA));
        velocityB.add(PVector.mult(impulse, invMassB));

        angularVelocityA += -ra.cross(impulse).z * invRotationalInertiaA;
        angularVelocityB += rb.cross(impulse).z * invRotationalInertiaB;

    }

    for(int i = 0; i < contactCount; i++) {
        PVector ra = PVector.sub(contactList[i], positionA);
        PVector rb = PVector.sub(contactList[i], positionB);

        raList[i] = ra;
        rbList[i] = rb;

        PVector raPerp = new PVector(-ra.y, ra.x);
        PVector rbPerp = new PVector(-rb.y, rb.x);

        PVector angularLinearVelocityA = PVector.mult(raPerp, angularVelocityA);
        PVector angularLinearVelocityB = PVector.mult(rbPerp, angularVelocityB);

        PVector relativeVelocity = PVector.sub(PVector.add(velocityB, angularLinearVelocityB),
                                               PVector.add(velocityA, angularLinearVelocityA));
        PVector tangent = PVector.sub(relativeVelocity, PVector.mult(normal, relativeVelocity.dot(normal)));

        if(PhysEngMath.Equals(tangent, new PVector())) {

            continue;

        } else {

            tangent.normalize();

        }

        float raPerpDotT = raPerp.dot(tangent);
        float rbPerpDotT = rb.dot(tangent);

        float denom = invMassA + invMassB
                    + (raPerpDotT * raPerpDotT) * invRotationalInertiaA
                    + (rbPerpDotT * rbPerpDotT) * invRotationalInertiaB;

        float jt = -relativeVelocity.dot(tangent);
        jt /= denom;
        jt /= (float)contactCount;

        PVector frictionImpulse;
        float j = jList[i];

        if(abs(jt) <= j * coefficientOfStaticFriction) {
            frictionImpulse = PVector.mult(tangent, jt);
        } else {
            frictionImpulse = PVector.mult(tangent, -j * coefficientOfKineticFriction);
        }
        
        this.frictionImpulseList[i] = frictionImpulse;
    }
        for(int i = 0; i < contactCount; i++) {
            PVector frictionImpulse = frictionImpulseList[i];
            PVector ra = raList[i];
            PVector rb = rbList[i];

            velocityA.add(PVector.mult(frictionImpulse, -invMassA));
            velocityB.add(PVector.mult(frictionImpulse, invMassB));

            angularVelocityA += -ra.cross(frictionImpulse).z * invRotationalInertiaA;
            angularVelocityB += rb.cross(frictionImpulse).z * invRotationalInertiaB;

            rigidbodyA.setVelocity(velocityA);
            rigidbodyB.setVelocity(velocityB);

            rigidbodyA.setAngularVelocity(angularVelocityA);
            rigidbodyB.setAngularVelocity(angularVelocityB);
        }

    }

/*
====================================================================================================
============================ Broad & Narrow - Phase Collision Methods ==============================
====================================================================================================
*/

public void BroadPhaseStep() {
    if(this.isPaused) {
        return;
    }

    for (int i = 0; i < rigidbodyList.size() - 1; i++) {
        
        Rigidbody rigidbodyA = rigidbodyList.get(i);
        ArrayList<Rigidbody> rigidbodyACollisionExclusionList = rigidbodyA.getCollisionExclusionList();
        AABB rigidbodyA_AABB = rigidbodyA.GetAABB();
        
        
        
        for (int j = i + 1; j < rigidbodyList.size(); j++) {
            Rigidbody rigidbodyB = rigidbodyList.get(j);
            AABB rigidbodyB_AABB = rigidbodyB.GetAABB();

            if(rigidbodyACollisionExclusionList.contains(rigidbodyB)) {
                continue;
            }

            if ((rigidbodyA.getIsStatic() && rigidbodyB.getIsStatic())) {
                continue;
            }
            

            //Remove this if shit breaks
            if(!rigidbodyA.getCollidability() || !rigidbodyB.getCollidability()) {
                continue;
            }
            
            if (!Collisions.IntersectAABB(rigidbodyA_AABB, rigidbodyB_AABB)) {
                continue;
            }

            ArrayList<Integer> pair = new ArrayList<Integer>(Arrays.asList(i, j));
            collisionPairs.add(pair);
        }
    }
}

public void NarrowPhaseStep() {
    if(isPaused) {
        return;
    }
    
    for (int i = 0; i < collisionPairs.size(); i++)
    {
        ArrayList<Integer> pair = collisionPairs.get(i);

        Rigidbody rigidbodyA = rigidbodyList.get(pair.get(0));
        Rigidbody rigidbodyB = rigidbodyList.get(pair.get(1));
        
        CollisionResult collisionResult = Collisions.Collide(rigidbodyA, rigidbodyB);
            
        if (collisionResult.getIsColliding()) {
            
            PVector minimumTranslationVector = PVector.mult(collisionResult.getNormal(), collisionResult.getDepth());
            
            SeperateBodies(rigidbodyA, rigidbodyB, minimumTranslationVector);
            Collisions.FindCollisionPoints(rigidbodyA, rigidbodyB, collisionResult);
            CollisionManifold collisionManifold = new CollisionManifold(rigidbodyA, rigidbodyB, collisionResult);
            this.ResolveCollisionRotationAndFriction(collisionManifold);

            for(PVector contact : collisionResult.getPointsOfContact()) {
                pointsOfContactList.add(contact);
            }
        }
    }
}
    

public void StepBodies(float dt, int totalIterations) {
    for(Rigidbody rigidbody : rigidbodyList) {

        if(rigidbody.getIsStatic()) {
            continue;
        }
        rigidbody.update(dt, totalIterations);
    }
}
            
/*
==================================================================================================
======================================== Helper Methods  =========================================
==================================================================================================
*/
public void AddBodyToBodyEntityList(Rigidbody body) {
    rigidbodyList.add(body);
}

public void RemoveBodyFromBodyEntityList(Rigidbody body) {
     rigidbodyList.remove(body);
}
        
public void RemoveBodyFromBodyEntityList(int index) {
   
   if(index < 0 || index >= rigidbodyList.size()) {
        throw new IndexOutOfBoundsException("Index: " + index + ", Size: " + rigidbodyList.size());
    }

    rigidbodyList.remove(index);
}

public Rigidbody GetBodyFromBodyEntityList(int index) {

    if(index < 0 || index >= rigidbodyList.size()) {
        throw new IndexOutOfBoundsException("Index: " + index + ", Size: " + rigidbodyList.size());
    }

    return rigidbodyList.get(index);
}
                        
public void ClearBodyEntityList() {
    rigidbodyList.clear();
}

public void displayTimings() {

if(millis() - systemTime>= 200) {
  totalStepTime = ((totalWorldStepTime) / totalSampleCount);
  subStepTime = ((subWorldStepTime) / subSampleCount);
  bodyCount = rigidbodyList.size();
  
  totalStepTimeUnit = "ns";
  subStepTimeUnit = "ns";

  if(totalStepTime > 1000) {
    totalStepTime /= 1000;
    totalStepTime = new BigDecimal(totalStepTime).setScale(3, RoundingMode.HALF_UP).doubleValue();
    totalStepTimeUnit = "s";
  }
  if(subStepTime > 1000) {
    subStepTime /= 1000;
    subStepTime = new BigDecimal(subStepTime).setScale(3, RoundingMode.HALF_UP).doubleValue();
    subStepTimeUnit = "s";
  }
  if (totalStepTime > 1000) {
    totalStepTime /= 1000;
    totalStepTime = new BigDecimal(totalStepTime).setScale(3, RoundingMode.HALF_UP).doubleValue();
    totalStepTimeUnit = "ms";
  }
  if (subStepTime > 1000) {
    subStepTime /= 1000;
    subStepTime = new BigDecimal(subStepTime).setScale(3, RoundingMode.HALF_UP).doubleValue();
    subStepTimeUnit = "ms";
  }

  //updates the counter and resets values
  totalWorldStepTime = 0;
  subWorldStepTime = 0;
  totalSampleCount = 0;
  subSampleCount = 0;
  systemTime = millis();

  fps = frameRate;
  displayTimeStep = dt;


}
stroke(255);
fill(255);
text("Total Step Time: " + totalStepTime + totalStepTimeUnit, 10, 20);
text("Sub Step Time: " + subStepTime + subStepTimeUnit, 10, 40);
text("Body Count: " + bodyCount, 10, 60);
text("FPS: " + fps, 10, 80);
text("dt: " + displayTimeStep, 10, 100);
/*------------------------------------------------------------------------------------------------*/
}

    
                                        
                                        
public class Rigidbody {

  //Capital letter denotes read only
  private String ID;
  private PVector position;
  public PVector previousPosition;
  private PVector linearVelocity;
  private float angle;
  private float angularVelocity;
    
  private ShapeType ShapeType;
  private float Mass;
  private float InvMass;
  private float Density;
  private float Restitution;
  private float Area;
  private float RotationalInertia;
  private float InvRotationalInertia;
  private float Radius;
  private float Width;
  private float Height;
  private float coefficientOfStaticFriction;
  private float coefficientOfKineticFriction;
  

  private PVector[] Vertices = new PVector[0];
  private AABB aabb;
  private PVector[] transformedVertices = new PVector[0];

  private ArrayList<Rigidbody> collisionExclusionList = new ArrayList<Rigidbody>();

  private Shape shapeRenderer;
  private float strokeWeight;
  private PVector strokeColour;
  private PVector fillColour;
  
  private boolean transformUpdateRequired;
  private boolean aabbUpdateRequired;
  
  private boolean isStatic;
  private boolean isTranslationallyStatic;
  private boolean isRotationallyStatic;
  private boolean isVisible;
  private boolean isCollidable;


  
  private float netTorque = 0f;
  private PVector netForce = new PVector();
  
  private ArrayList<ForceRegistry> forceRegistry = new ArrayList<ForceRegistry>();
  
  
  
  
  
  
  /*
  ==================================================================================================
  ==================================CONSTRUCTORS====================================================
  ==================================================================================================
  */
  public Rigidbody() {
      //this.aabbUpdateRequired = true;
      //this.transformUpdateRequired = true;
  }
  
  private Rigidbody(float density, float mass, float rotationalIntertia, float restitution,
    float area, float radius, float width, float height, PVector[] vertices, boolean isStatic,
    boolean isCollidable, float strokeWeight, PVector strokeColour, PVector fillColour, ShapeType shapeType)
  {
    this.ID = UUID.randomUUID().toString();
    this.Mass = mass;
    this.RotationalInertia = rotationalIntertia;
    this.InvMass = mass > 0 ? 1 / mass : 0;
    this.InvRotationalInertia = rotationalIntertia > 0 ? 1 / rotationalIntertia : 0;


    this.Density = density;
    this.Restitution = restitution;
    this.Area = area;
    this.Radius = radius;
    this.Width = width;
    this.Height = height;

    this.coefficientOfStaticFriction = 0.8f;
    this.coefficientOfKineticFriction = 0.3f;
  

    this.ShapeType = shapeType;
    this.strokeWeight = strokeWeight;
    this.strokeColour = strokeColour;
    this.fillColour = fillColour;


    this.isStatic = isStatic;
    this.isCollidable = true;
    this.isVisible = true;

    this.position = new PVector();
    this.linearVelocity = new PVector();
    this.angle = 0f;
    this.angularVelocity = 0f;
    
    
    if (shapeType == ShapeType.BOX) {

      this.Vertices = vertices;
      this.transformedVertices = new PVector[this.Vertices.length];
      this.aabb = this.GetAABB();
      
    } else {

        this.Vertices = null;
        this.transformedVertices = null;
    }
    
    //Sets InvMass for static objects to 0

    
    this.aabbUpdateRequired = true;
    this.transformUpdateRequired = true;
  }





  
  
  
  /*
  ==================================================================================================
  ========================== BODY & COLLIDER GEOMETRY METHODS ======================================
  ==================================================================================================
  */
  private PVector[] CreateBoxVertices(float width, float height) {
    float left = -width / 2;
    float right = width / 2;
    float top = height / 2;
    float bottom = -height / 2;
    
    PVector[] vertices = new PVector[4];
    vertices[0] = new PVector(left, top);
    vertices[1] = new PVector(right, top);
    vertices[2] = new PVector(right, bottom);
    vertices[3] = new PVector(left, bottom);
    return vertices;
  }
  
  public PVector[] GetTransformedVertices() {
    if (this.transformUpdateRequired) {

      for (int i = 0; i < this.Vertices.length; i++) {

        PVector vertex = this.Vertices[i];

        this.transformedVertices[i] = PhysEngMath.Transform(vertex, this.position, this.angle);
      }
    }
    
    /*
    The way this transform system works, is that it caches the transformed vertices,
    and only transforms them once a change has been made. This means that,
    if no change is made is made, cached vertices are returned.
    if the transform is updated, the vertices are transformed, and the cache is updated.
    */
    this.aabbUpdateRequired = true;
    this.transformUpdateRequired = false;
    return this.transformedVertices;
  }
  
  
  public Rigidbody CreateCircleBody(float radius, float density,
    float restitution, boolean isStatic, boolean isCollidable, float strokeWeight,
    PVector strokeColour, PVector fillColour) {

    Rigidbody rigidbody;
    
    float area = (float) PI * radius * radius;
    
    //Argument exceptions for area and density
    if (area < MIN_BODY_AREA || area > MAX_BODY_AREA) {

      throw new IllegalArgumentException("Body area is too small or large");
    }

    if (density < MIN_BODY_DENSITY || density > MAX_BODY_DENSITY) {

      throw new IllegalArgumentException("Density is too small or large");
    } 

    
    //Clamps restitution between 0 and 1
    restitution = PhysEngMath.Clamp(restitution, 0, 1);


    float mass = 0f;
    float rotationalIntertia = 0f;

    if(!isStatic) {
      mass = area * density;
      rotationalIntertia =  abs(0.5f * mass * radius * radius);
    }
    


    rigidbody = new Rigidbody(density, mass, rotationalIntertia, restitution, area, radius, 0, 0,
                              null, isStatic, isCollidable, strokeWeight,
                              strokeColour, fillColour, ShapeType.CIRCLE);
    
    return rigidbody;
  }
  


  public Rigidbody CreateBoxBody(float width, float height, float density,
    float restitution, boolean isStatic, boolean isCollidable, float strokeWeight,
    PVector strokeColour, PVector fillColour) {
    Rigidbody rigidbody;
    
    float area = width * height;
    
    //Argument exceptions for area and density
    if (area < MIN_BODY_AREA || area > MAX_BODY_AREA) {

      throw new IllegalArgumentException("Body area is too small or large");
    }

    if (density < MIN_BODY_DENSITY || density > MAX_BODY_DENSITY) {

      throw new IllegalArgumentException("Density is too small or large");
    } 
    
    //Clamps restitution between 0 and 1
    restitution = PhysEngMath.Clamp(restitution, 0, 1);
    
    //calculates mass from density and area
    float mass = 0f;
    float rotationalIntertia = 0f;

    if(!isStatic) {
      mass = area * density;
      rotationalIntertia = 0.5f * mass * width * width + height * height;
    }

    PVector[] vertices = CreateBoxVertices(width, height);
    
    rigidbody = new Rigidbody(density, mass, rotationalIntertia, restitution, area, 0, width,
                              height, vertices, isStatic, isCollidable, strokeWeight, strokeColour,
                              fillColour, ShapeType.BOX);
    
    return rigidbody;
  }


  public Rigidbody CreatePolygon(PVector[] vertices, float density,
    float restitution, boolean isStatic, boolean isTranslationallyStatic,
    boolean isRotationallyStatic, boolean isCollidable, float strokeWeight,
    PVector strokeColour, PVector fillColour) {

    Rigidbody rigidbody;

    float area = this.calculateArea(vertices);
    
    //Argument exceptions for area and density
    if (area < MIN_BODY_AREA || area > MAX_BODY_AREA) {

      throw new IllegalArgumentException("Body area is too small or large");
    }

    if (density < MIN_BODY_DENSITY || density > MAX_BODY_DENSITY) {

      throw new IllegalArgumentException("Density is too small or large");
    } 
    
    //Clamps restitution between 0 and 1
    restitution = PhysEngMath.Clamp(restitution, 0, 1);
    
    //calculates mass from density and area
    float mass = 0f;
    float rotationalIntertia = 0f;

    if(isStatic) {
      mass = 0f;
      rotationalIntertia = 0f;
    } else if(isTranslationallyStatic) {
      mass = 0f;
      rotationalIntertia = calculateMomentOfInertia(vertices, mass);
    } else if(isRotationallyStatic) {
      mass = area * density;
      rotationalIntertia = 0f;
    } else {
      mass = area * density;
      rotationalIntertia = calculateMomentOfInertia(vertices, mass);
    }

    
    rigidbody = new Rigidbody(density, mass, rotationalIntertia, restitution, area, 0, width,
                              height, vertices, isStatic, isCollidable, strokeWeight, strokeColour,
                              fillColour, ShapeType.BOX);
    
    return rigidbody;
  }


  public AABB GetAABB() {
    if(this.aabbUpdateRequired) {

    float minX = Float.MAX_VALUE;
    float minY = Float.MAX_VALUE;

    float maxX = -Float.MAX_VALUE;
    float maxY = -Float.MAX_VALUE;
    
    if(this.ShapeType == ShapeType.CIRCLE) {
      
      minX = this.position.x - this.Radius;
      minY = this.position.y - this.Radius;
      maxX = this.position.x + this.Radius;
      maxY = this.position.y + this.Radius;

    } else if (this.ShapeType == ShapeType.BOX) {

      PVector[] vertices = this.GetTransformedVertices();
      for (PVector vertex : vertices) {
        if (vertex.x < minX) {
            minX = vertex.x;
          }
          if (vertex.x > maxX) {
            maxX = vertex.x;
          }
          if (vertex.y < minY) {
            minY = vertex.y;
          }
          if (vertex.y > maxY) {
            maxY = vertex.y;
          }
        }
    }

    this.aabb = new AABB(new PVector(minX, minY), new PVector(maxX, maxY));
    this.aabbUpdateRequired = false;

  }
  return this.aabb;
}


public float calculateArea(PVector[] vertices) {
  float area = 0;
  int n = vertices.length;

  for (int i = 0, j = n - 1; i < n; j = i++) {
    area += vertices[i].x * vertices[j].y - vertices[j].x * vertices[i].y;
  }
  return Math.abs(area / 2.0f);
}


public float calculateMass(PVector[] vertices) {
  float area = calculateArea(vertices);
  return area * this.Density;
}


public float calculateMomentOfInertia(PVector[] vertices, float mass) {
  float I = 0;
  float area = calculateArea(vertices);
  int n = vertices.length;
  PVector centroid = calculateCentroid(vertices);

  for (int i = 0, j = n - 1; i < n; j = i++) {
    float xi = vertices[i].x - centroid.x, yi = vertices[i].y - centroid.y;
    float xj = vertices[j].x - centroid.x, yj = vertices[j].y - centroid.y;
    float cross = Math.abs(xi * yj - xj * yi);
    I += cross * (xi * xi + yi * yi + xi * xj + yi * yj + xj * xj + yj * yj);
  }
  I *= mass / (6 * area);
  return I;
}


public PVector calculateCentroid(PVector[] vertices) {
    float signedArea = 0;
    float cx = 0;
    float cy = 0;
    for (int i = 0, j = vertices.length - 1; i < vertices.length; j = i++) {
        float temp = (vertices[i].x * vertices[j].y) - (vertices[j].x * vertices[i].y);
        signedArea += temp;
        cx += (vertices[i].x + vertices[j].x) * temp;
        cy += (vertices[i].y + vertices[j].y) * temp;
    }
    signedArea /= 2;
    cx /= (6 * signedArea);
    cy /= (6 * signedArea);
    return new PVector(cx, cy);
}


public void adjustRigidbodyPosition(PVector[] vertices) {
    PVector newCOM = calculateCentroid(vertices);

    for(PVector vertex : vertices) {
        vertex.sub(newCOM);
    }
}

private boolean doEdgesIntersect(PVector p1, PVector p2, PVector p3, PVector p4) {

    float denominator = (p4.y - p3.y) * (p2.x - p1.x) - (p4.x - p3.x) * (p2.y - p1.y);
    if (denominator == 0) {
        return false; // Lines are parallel
    }

    float ua = ((p4.x - p3.x) * (p1.y - p3.y) - (p4.y - p3.y) * (p1.x - p3.x)) / denominator;
    float ub = ((p2.x - p1.x) * (p1.y - p3.y) - (p2.y - p1.y) * (p1.x - p3.x)) / denominator;

    if (ua >= 0 && ua <= 1 && ub >= 0 && ub <= 1) {
        return true; 
    }

    return false;
}

private boolean validatePolygonVertices(PVector[] vertices) {
    for (int i = 0; i < vertices.length; i++) {
        for (int j = i + 1; j < vertices.length; j++) {
            int nextI = (i + 1) % vertices.length;
            int nextJ = (j + 1) % vertices.length;

            if (nextI != j && i != nextJ) {
                if (doEdgesIntersect(vertices[i], vertices[nextI], vertices[j], vertices[nextJ])) {
                    return false; // Found intersecting edges
                }
            }
        }
    }
    return true;
}


public void updateCircle(float radius) {

    this.Radius = radius;
    this.Area = (float) PI * this.Radius * this.Radius;
    this.Vertices = null;

    this.transformedVertices = null;

    if(this.isStatic) {
      this.Mass = 0f;
      this.InvMass = 0f;
      this.RotationalInertia = 0f;
      this.InvRotationalInertia = 0f;
    } else if(this.isTranslationallyStatic) {
      this.Mass = this.Density * this.Area;
      this.InvMass = 0f;
      this.RotationalInertia = 0.5f * this.Mass * this.Radius * this.Radius;
      this.InvRotationalInertia = 1 / this.RotationalInertia;
    } else if(this.isRotationallyStatic) {
      this.Mass = this.Area * this.Density;
      this.InvMass = this.Mass;
      this.RotationalInertia = 0f;
      this.InvRotationalInertia = 0f;
    }

    this.transformUpdateRequired = true;
    this.aabbUpdateRequired = true;
}
public void updatePolygon(PVector[] newVertices) {

    newVertices = PhysEngMath.OrderVerticesClockwise(newVertices);

    if(!this.validatePolygonVertices(newVertices)){
      System.out.println("Vertices Invalid");
      return;
    }

    this.Vertices = newVertices;
    this.transformedVertices = new PVector[this.Vertices.length];
    PVector newCOM = calculateCentroid(this.Vertices);

    for(int i = 0; i < this.Vertices.length; i++) {
          this.Vertices[i].sub(newCOM);
    }

    float newMass = calculateMass(this.Vertices);
    float newMomentOfInertia = calculateMomentOfInertia(this.Vertices, newMass);

    if(this.isStatic) {
      this.Mass = 0f;
      this.InvMass = 0f;
      this.RotationalInertia = 0f;
      this.InvRotationalInertia = 0f;
    } else if(this.isTranslationallyStatic) {
      this.Mass = newMass;
      this.InvMass = 0f;
      this.RotationalInertia = newMomentOfInertia;
      this.InvRotationalInertia = this.RotationalInertia > 0 ? 1 / this.RotationalInertia : 0;
    } else if(this.isRotationallyStatic) {
      this.Mass = newMass;
      this.InvMass = this.Mass > 0f ? 1 / this.Mass : 0f;
      this.InvRotationalInertia = 0f;
      this.RotationalInertia = newMomentOfInertia;
    } else {
      this.Mass = newMass;
      this.InvMass = this.Mass > 0 ? 1 / this.Mass : 0;
      this.RotationalInertia = newMomentOfInertia;
      this.InvRotationalInertia = this.RotationalInertia > 0 ? 1 / this.RotationalInertia : 0;
    }

    float newArea = calculateArea(this.Vertices);

    this.Area = newArea;

    this.transformUpdateRequired = true;
    this.aabbUpdateRequired = true;
}


public void deserializeRigidbody(String ID, ShapeType ShapeType, PVector position, PVector linearVelocity, float angle, 
                                 float angularVelocity, float Density, float Restitution, float radius, float width, 
                                 float height, float coefficientOfStaticFriction, float coefficientOfKineticFriction,
                                 PVector[] vertices, boolean isStatic, boolean isTranslationallyStatic, boolean isRotationallyStatic,
                                 boolean isCollidable, boolean isVisible, float strokeWeight, PVector strokeColour, PVector fillColour) {
    this.ID = ID; 

    this.position = position;
    this.linearVelocity = linearVelocity;
    this.angle = angle;
    this.angularVelocity = angularVelocity;

    this.Density = Density;
    this.Restitution = Restitution;
    this.ShapeType = ShapeType;

    this.isStatic = isStatic;
    this.isTranslationallyStatic = isTranslationallyStatic;
    this.isRotationallyStatic = isRotationallyStatic;

    this.isCollidable = isCollidable;
    this.isVisible = isVisible;

    this.strokeWeight = strokeWeight;
    this.strokeColour = strokeColour;
    this.fillColour = fillColour;

    this.coefficientOfStaticFriction = coefficientOfStaticFriction;
    this.coefficientOfKineticFriction = coefficientOfKineticFriction;

    if(ShapeType == ShapeType.POLYGON || ShapeType == ShapeType.BOX) {

        this.updatePolygon(vertices);
        this.Width = width;
        this.Height = height;

    } else if(ShapeType == ShapeType.CIRCLE) {
        this.updateCircle(radius);
    }
  }





  /*
  ==================================================================================================
  ==================================METHODS=========================================================
  ==================================================================================================
  */
  public void Move(PVector amount) {
    this.position.add(amount);

    this.transformUpdateRequired = true;
    this.aabbUpdateRequired = true;
  }
  
  public void MoveTo(PVector position) {
    this.position = position;

    this.transformUpdateRequired = true;
    this.aabbUpdateRequired = true;
  }

  public void SetInitialPosition(PVector position) {
    this.position = position;
    this.previousPosition = position;
    this.transformUpdateRequired = true;
    this.aabbUpdateRequired = true;
  }
  
  public void Rotate(float amount) {
    this.angle += amount;

    this.transformUpdateRequired = true;
    this.aabbUpdateRequired = true;
  }

  public void RotateTo(float angle) {
    this.angle = angle;

    this.transformUpdateRequired = true;
    this.aabbUpdateRequired = true;
  }


/*----------------------------- Mouse Detection Stuff ------------------------------------*/
  
public boolean contains(float x, float y) {

    if(this.ShapeType == ShapeType.CIRCLE) {
      return this.containsCircle(x, y);
    } else {
      return this.containsPolygon(x, y);
    }
}

public boolean containsCircle(float x, float y) {
    float distance = PVector.dist(this.position, new PVector(x, y));

    return (distance <= this.Radius);
}


public boolean containsPolygon(float x, float y) {
    boolean inside = false;
    PVector[] vertices = this.transformedVertices;

    for (int i = 0, j = vertices.length - 1; i < vertices.length; j = i++) {
        if ((vertices[i].y > y) != (vertices[j].y > y) &&
            (x < (vertices[j].x - vertices[i].x) * (y - vertices[i].y) / (vertices[j].y - vertices[i].y) + vertices[i].x)) {
            inside = !inside;
        }
    }
    
    return inside;
}



/*-------------------------------------------------------------------------------------*/
  

  /*
  ==================================================================================================
  ==================================UPDATE==========================================================
  ==================================================================================================
  */
  public void update(float dt, int iterations) {
    if(!isPaused) {
          if(isStatic) {
            return;
          }
            this.aabbUpdateRequired = true;
            this.transformUpdateRequired = true;
            dt /= (float)iterations;                
            this.RK4Position(dt);
            this.angularIntegration(dt);
        }
    }


  /*
  ==================================================================================================
  ================================== INTEGRATOR ====================================================
  ==================================================================================================
  */

     public void RK4Position(float dt) {

        /*-------------- RK4 Position And Velocity Integration --------------*/
        PVector k1_v = PVector.mult(calculateAcceleration(this.position), dt);
        PVector k1_r = PVector.mult(this.linearVelocity, dt);

        PVector k2_v = PVector.mult(calculateAcceleration(PVector.add(this.position, PVector.mult(k1_r, 0.5f))), dt);
        PVector k2_r = PVector.mult(PVector.add(this.linearVelocity, PVector.mult(k1_v, 0.5f)), dt);

        PVector k3_v = PVector.mult(calculateAcceleration(PVector.add(this.position, PVector.mult(k2_r, 0.5f))), dt);
        PVector k3_r = PVector.mult(PVector.add(this.linearVelocity, PVector.mult(k2_v, 0.5f)), dt);

        PVector k4_v = PVector.mult(calculateAcceleration(PVector.add(this.position, k3_r)), dt);
        PVector k4_r = PVector.mult(PVector.add(this.linearVelocity, k3_v), dt);
        /*-------------------------------------------------------------------*/


        /*-------------- Reusable Vectors --------------*/
        PVector two_k2_r = PVector.mult(k2_r, 2);
        PVector two_k3_r = PVector.mult(k3_r, 2);

        PVector two_k2_v = PVector.mult(k2_v, 2);
        PVector two_k3_v = PVector.mult(k3_v, 2);
        /*-----------------------------------------------*/


        /*-------------- Final Position and Velocity --------------*/
        PVector finalPosition = PVector.add(this.position, PVector.div(PVector.add(k1_r, PVector.add(two_k2_r, PVector.add(two_k3_r, k4_r))), 6));
        PVector finalVelocity = PVector.add(this.linearVelocity, PVector.div(PVector.add(k1_v, PVector.add(two_k2_v, PVector.add(two_k3_v, k4_v))), 6));
        /*---------------------------------------------------------*/


        /*----------------- Update To New Values -----------------*/
        this.position = finalPosition;
        this.linearVelocity = finalVelocity;
        this.transformUpdateRequired = true;
        /*--------------------------------------------------------*/

  }


  public void angularIntegration(float dt) {

    this.angularVelocity += this.netTorque * this.InvRotationalInertia * dt;
    this.angle += this.angularVelocity*dt;


  }




    public PVector calculateAcceleration(PVector position) {

        /*--------------- Force Reset --------------*/
        this.netForce.set(0,0,0);
        this.netTorque = 0f;
        /*------------------------------------------*/

        /*------------ Net Force Calculation ------------*/
        for (ForceRegistry force : this.forceRegistry) {

            PVector currentForce = force.getForce(this, position);
            this.netForce.add(currentForce);

            PVector leverArm = PVector.sub(force.getApplicationPoint(this, this.position), this.position);
            this.netTorque += leverArm.cross(currentForce).z;

        }
        /*-----------------------------------------------*/

        /*------------ Acceleration Calculation ------------*/
        return this.netForce.mult(this.InvMass);
        /*--------------------------------------------------*/

    }

  
  /*
  ==================================================================================================
  ==================================READ-ONLY FIELDS================================================
  ==================================================================================================
  */
  
  public float getMass() {
    return this.Mass;
  }

  public void setMass(float mass) {
    this.Mass = mass;
    this.InvMass = 1/mass;
    this.RotationalInertia = (this.ShapeType == ShapeType.BOX) ? 0.5f * Mass * width * width + height * height : 0.5f * Mass * this.Radius * this.Radius;
    this.InvRotationalInertia = (this.RotationalInertia > 0) ? 1 / this.RotationalInertia : 0;
  }


  public float getDensity() {
    return this.Density;
  }

  public void setDensity(float density) {
    this.Density = density;
    this.setMass(this.Area * this.Density);
  }
  
  public float getRestitution() {
    return this.Restitution;
  }

  public void setRestitution(float restitution) {
    this.Restitution = restitution;
  }
  
  public void setArea(float area) {
    this.Area = area;
  }

  public float getArea() {
    return this.Area;
  }
  
  public float getRadius() {
    return this.Radius;
  }

  public void setRadius(float radius) {
    this.Radius = radius;
    this.Area = (float) PI * this.Radius * this.Radius;
    setDensity(this.Density);
  }

  public float getWidth() {
    return this.Width;
  }

  public void setWidth(float width) {
    if(this.ShapeType == ShapeType.BOX) {
      this.Width = width;
      this.Area = this.Width*this.Height;
      setDensity(this.Density);
      this.Vertices = CreateBoxVertices(this.Width, this.Height);
      this.transformUpdateRequired = true;
    }
  }

  public float getHeight() {
    return this.Height;
  }
  
  public void setHeight(float height) {
    this.Height = height;
    this.Area = this.Width*this.Height;
    setDensity(this.Density);
    this.Vertices = CreateBoxVertices(this.Width, this.Height);
    this.transformUpdateRequired = true;
  }

  public ShapeType getShapeType() {
    return this.ShapeType;
  }

  public void setShapeType(ShapeType shapeType) {
    this.ShapeType = shapeType;
  }

  public void setVertices(PVector[] vertices) {
    this.Vertices = vertices;
  }

  public PVector[] getVertices() {
    return this.Vertices;
  }

  public void setTransformedVerticesLength(int length) {
    this.transformedVertices = new PVector[length];
  }
  
  public float getInvMass() {
    return this.InvMass;
  }

  public float getRotationalInertia() {
    return this.RotationalInertia;
  }

  public float getInvRotationalInertia() {
    return this.InvRotationalInertia;
  }




  
  /*
  ==================================================================================================
  ==================================GETTERS & SETTERS===============================================
  ==================================================================================================
  */
  public String getID(){
    return this.ID;
  }

  public void setID(String ID) {
    this.ID = ID;
  }

  public boolean getTransformUpdateRequired() {
    return this.transformUpdateRequired;
  }
  
  public void setTransformUpdateRequired(boolean transformUpdateRequired) {
    this.transformUpdateRequired = transformUpdateRequired;
  }

  public boolean getAABBUpdateRequired() {
    return this.aabbUpdateRequired;
  }

  public void setAABBUpdateRequired(boolean aabbUpdateRequired) {
    this.aabbUpdateRequired = aabbUpdateRequired;
  }
  
  public PVector getPosition() {
    return this.position;
  }
  
  public void setPosition(PVector position) {
    this.transformUpdateRequired = true;
    this.aabbUpdateRequired = true;
    this.position = position;
  }
  public PVector getVelocity() {
    return this.linearVelocity;
  }
  
  public void setVelocity(PVector velocity) {
    this.linearVelocity = velocity;
  }
  
  public float getStrokeWeight() {
    return this.strokeWeight;
  }
  
  public void setStrokeWeight(float strokeWeight) {
    this.strokeWeight = strokeWeight;
  }
  
  public PVector getStrokeColour() {
    return this.strokeColour;
  }
  
  public void setStrokeColour(PVector strokeColour) {
    this.strokeColour = strokeColour;
  }
  //Overloaded method for setting stroke colour with 3 floats
  public void setStrokeColour(float r, float g, float b) {
    this.strokeColour = new PVector(r, g, b);
  }
  
  public PVector getFillColour() {
    return this.fillColour;
  }
  
  
  public void setFillColour(PVector fillColour) {
    this.fillColour = fillColour;
  }
  //Overloaded method for setting fill colour with 3 floats
  public void setFillColour(float r, float g, float b) {
    this.fillColour = new PVector(r, g, b);
  }
  
  public ArrayList<ForceRegistry> getForceRegistry() {
    return this.forceRegistry;
  }
  
  public ForceRegistry getForceFromForceRegistry(int index) {
    return this.forceRegistry.get(index);
  }
  
  public int getForceRegistrySize() {
    return this.forceRegistry.size();
  }
  
  public void addForceToForceRegistry(ForceRegistry forceRegistry) {
    this.forceRegistry.add(forceRegistry);
  }

  public void clearForceRegistry() {
    this.forceRegistry.clear();
  }

  public void removeForceFromForceRegistry(ForceRegistry forceRegistry) {
    this.forceRegistry.remove(forceRegistry);
  }
  
  public void removeForceFromForceRegistry(int index) {
    this.forceRegistry.remove(index);
  }
  
  public boolean getIsStatic() {
    return this.isStatic;
  }
  
  public void setIsStatic(boolean isStatic) {
    this.isStatic = isStatic;
    if(isStatic) {
      this.InvMass = 0f;
      this.InvRotationalInertia = 0f;
    }
  }

  public boolean getIsVisible() {
    return this.isVisible;
  }

  public void setIsVisible(boolean isVisible) {
    this.isVisible = isVisible;
  }
    public float getAngle() {
    return this.angle;
  }

  public void setAngle(float angle) {
    this.transformUpdateRequired = true;
    this.angle = angle;
  }

  public void addBodyToCollisionExclusionList(Rigidbody rigidbody) {
    this.collisionExclusionList.add(rigidbody);
  }

  public ArrayList<Rigidbody> getCollisionExclusionList() {
    return this.collisionExclusionList;
  }

  public float getAngularVelocity(){
    return this.angularVelocity;
  }

  public void setAngularVelocity(float angularVelocity) {
    this.angularVelocity = angularVelocity;
  }


public float getCoefficientOfKineticFriction() {
    return this.coefficientOfKineticFriction;
}

public void setCoefficientOfKineticFriction(float coefficientOfKineticFriction) {
    this.coefficientOfKineticFriction = coefficientOfKineticFriction;
}

public float getCoefficientOfStaticFriction() {
    return this.coefficientOfStaticFriction;
}

public void setCoefficientOfStaticFriction(float coefficientOfStaticFriction) {
    this.coefficientOfStaticFriction = coefficientOfStaticFriction;
}

public boolean getIsTranslationallyStatic() {
    return this.isTranslationallyStatic;
}

public void setIsTranslationallyStatic(boolean isTranslationallyStatic) {
    this.isTranslationallyStatic = isTranslationallyStatic;

    if(this.isTranslationallyStatic) {
      this.InvMass = 0f;
    }
}

public boolean getIsRotationallyStatic() {
    return this.isRotationallyStatic;
}

public void setIsRotationallyStatic(boolean isRotationallyStatic) {
    this.isRotationallyStatic = isRotationallyStatic;
    if(this.isRotationallyStatic) {
      this.InvRotationalInertia = 0f;
    }
}

  
public boolean getCollidability() {
    return this.isCollidable;
}

public void setCollidability(boolean isCollidable) {
    this.isCollidable = isCollidable;
}
}
public class Rod implements ForceRegistry {
/*-------------------------------------------------------------------------------------------------*/
    private float length = 0f;
    private float stiffness = 250000.0f;
    private float damping = 1.0f;

    private PVector localAnchorA = new PVector();
    private PVector localAnchorB = new PVector();
    private PVector anchorPoint = new PVector();

    private boolean isTwoBodyRod;
    private boolean isJoint;

    private Rigidbody rigidbodyA;
    private Rigidbody rigidbodyB;


/*-------------------------------------------------------------------------------------------------*/
    private PVector worldAnchorA = new PVector();
    private PVector worldAnchorB = new PVector();

    private PVector drawWorldAnchorA = new PVector();
    private PVector drawWorldAnchorB = new PVector();

    private PVector relativeVelocity = new PVector();

    private PVector velocityA = new PVector();
    private PVector velocityB = new PVector();

    private PVector dampingForce = new PVector();
    private PVector direction = new PVector();
    private PVector rodForce = new PVector();
    private PVector force = new PVector();
    private PVector rigidbodyOrientation = new PVector();

    private float displacement;
    private float dot;
    private float currentRigidbodyAngle;

/*-------------------------------------------------------------------------------------------------*/
//Reusable stuff


    public Rod(Rigidbody rigidbodyA, PVector localAnchorA, PVector anchorPoint) {

        this.rigidbodyA = rigidbodyA;

        this.anchorPoint.set(anchorPoint);
        this.localAnchorA.set(localAnchorA);

        this.isTwoBodyRod = false;

        if(rigidbodyA == null) {
            throw new NullPointerException("Rigidbody A is null");
        }
        
        this.length = PVector.sub(PhysEngMath.Transform(this.localAnchorA, this.rigidbodyA.getPosition(), this.rigidbodyA.getAngle()), 
                                  this.anchorPoint)
                                  .mag();
    }

    public Rod(Rigidbody rigidbodyA, Rigidbody rigidbodyB, PVector localAnchorA, PVector localAnchorB) {

        this.rigidbodyA = rigidbodyA;
        this.rigidbodyB = rigidbodyB;

        this.localAnchorA.set(localAnchorA);
        this.localAnchorB.set(localAnchorB);

        this.isTwoBodyRod = true;

        if(rigidbodyA == null) {
            throw new NullPointerException("Rigidbody A is null");
        } else if(rigidbodyB == null) {
            throw new NullPointerException("Rigidbody B is null");
        }

        this.length = PVector.sub(PhysEngMath.Transform(this.localAnchorB, this.rigidbodyB.getPosition(), this.rigidbodyB.getAngle()), 
                                  PhysEngMath.Transform(this.localAnchorA, this.rigidbodyA.getPosition(), this.rigidbodyA.getAngle()))
                                  .mag();
    }


@Override
public PVector getForce(Rigidbody rigidbody, PVector position) {

    this.force.set(0,0,0);

    if(isTwoBodyRod) {
        if(rigidbody == rigidbodyA) {
                this.worldAnchorA.set(PhysEngMath.Transform(this.localAnchorA, position, this.rigidbodyA.getAngle()));
                this.worldAnchorB.set(PhysEngMath.Transform(this.localAnchorB, this.rigidbodyB.getPosition(), this.rigidbodyB.getAngle()));

                this.velocityA.set(rigidbodyA.getVelocity());
                this.velocityB.set(rigidbodyB.getVelocity());

                this.direction.set(this.worldAnchorB.sub(this.worldAnchorA));

                this.displacement = direction.mag();
                this.direction.normalize();

                this.relativeVelocity.set(PVector.sub(this.velocityB, this.velocityA));

                this.dot = PVector.dot(relativeVelocity, this.direction);
                this.dampingForce.set(PVector.mult(this.direction, damping * dot));

                this.force.add(this.direction.mult(this.stiffness * (displacement - this.length)));
                this.force.add(this.dampingForce);
                
                return this.force;

            } else {
                this.worldAnchorA.set(PhysEngMath.Transform(this.localAnchorA, this.rigidbodyA.getPosition(), this.rigidbodyA.getAngle()));
                this.worldAnchorB.set(PhysEngMath.Transform(this.localAnchorB, position, this.rigidbodyB.getAngle()));

                this.velocityA.set(rigidbodyA.getVelocity());
                this.velocityB.set(rigidbodyB.getVelocity());


                this.direction.set(this.worldAnchorB.sub(this.worldAnchorA));
                this.displacement = direction.mag();
                this.direction.normalize();


                this.relativeVelocity.set(PVector.sub(this.velocityA, this.velocityB));
                this.dot = PVector.dot(relativeVelocity, this.direction);

                this.dampingForce.set(PVector.mult(direction, -damping * dot));

                this.force.add(this.dampingForce);
                this.force.add(this.direction.mult(this.stiffness * (displacement - this.length)));
                
                return this.force.mult(-1);

            } 

    } else {

        this.worldAnchorA.set(PhysEngMath.Transform(this.localAnchorA, position, this.rigidbodyA.getAngle()));
        this.worldAnchorB.set(this.anchorPoint);

        this.velocityA.set(rigidbodyA.getVelocity());
        this.velocityB.set(0,0);    

        this.direction.set(this.worldAnchorB.sub(this.worldAnchorA));
        displacement = direction.mag();
        this.direction.normalize();

        this.relativeVelocity.set(this.velocityB.sub(this.velocityA));
        dot = PVector.dot(relativeVelocity, this.direction);

        this.dampingForce.set(this.direction.copy().mult(-damping * dot));

        this.dampingForce.set(this.direction.copy().mult(-damping * PVector.dot(relativeVelocity, this.direction)));

        this.force.add(this.direction.mult(this.stiffness * (displacement - this.length)));
        this.force.add(this.dampingForce);
        
        return this.force;
                
    }
}



@Override
public void draw() {
    if(isTwoBodyRod){

        this.drawWorldAnchorA.set(PhysEngMath.Transform(this.localAnchorA, this.rigidbodyA.getPosition(), this.rigidbodyA.getAngle()));
        this.drawWorldAnchorB.set(PhysEngMath.Transform(this.localAnchorB, this.rigidbodyB.getPosition(), this.rigidbodyB.getAngle()));

        strokeWeight(0.15f);
        stroke(0);
        line(this.drawWorldAnchorA.x, this.drawWorldAnchorA.y, this.drawWorldAnchorB.x, this.drawWorldAnchorB.y);
        strokeWeight(0.1f);
        stroke(255);
        line(this.drawWorldAnchorA.x, this.drawWorldAnchorA.y, this.drawWorldAnchorB.x, this.drawWorldAnchorB.y);
    } else {

        this.drawWorldAnchorA.set(PhysEngMath.Transform(this.localAnchorA, this.rigidbodyA.getPosition(), this.rigidbodyA.getAngle()));

        strokeWeight(0.15f);
        stroke(0);
        line(this.drawWorldAnchorA.x, this.drawWorldAnchorA.y, this.anchorPoint.x, this.anchorPoint.y);
        strokeWeight(0.1f);
        stroke(255);
        line(this.drawWorldAnchorA.x, this.drawWorldAnchorA.y, this.anchorPoint.x, this.anchorPoint.y);

    }
}  



@Override
public PVector getApplicationPoint(Rigidbody rigidbody, PVector position) {
        if(rigidbody == rigidbodyA) {
            return PhysEngMath.Transform(localAnchorA, rigidbodyA.getPosition(), rigidbody.getAngle());
        } else {
            return PhysEngMath.Transform(localAnchorB, rigidbodyB.getPosition(), rigidbody.getAngle());
        }
}


/*
====================================================================================================
===================================GETTERS AND SETTERS==============================================
====================================================================================================
*/
public void setLength(float length) {
    this.length = length;
  }

public void setAnchorPoint(PVector anchorPoint) {
    this.anchorPoint.set(anchorPoint);
  }

public void setLocalAnchorA(PVector localAnchorA) {
    this.localAnchorA.set(localAnchorA);
  }

public void setLocalAnchorB(PVector localAnchorB) {
    this.localAnchorB.set(localAnchorB);
  }

public void setStiffness(float stiffness) {
    this.stiffness = stiffness;
  }

public void setDamping(float damping) {
    this.damping = damping;
  }

public void setTwoBodyRod(boolean isTwoBodyRod) {
    this.isTwoBodyRod = isTwoBodyRod;
  }

public void setIsJoint(boolean isJoint) {
    this.isJoint = isJoint;

    if(this.isJoint) {
        if(this.isTwoBodyRod){
            this.length = 0f;
            rigidbodyA.addBodyToCollisionExclusionList(rigidbodyB);
            rigidbodyB.addBodyToCollisionExclusionList(rigidbodyA);
        } else {
            this.length = 0f;
        }
    }
}   



public float getLength() {
    return length;
  }

public PVector getAnchorPoint() {
    return anchorPoint;
  }

public PVector getLocalAnchorA() {
    return localAnchorA;
  }

public PVector getLocalAnchorB() {
    return localAnchorB;
  }

public float getStiffness() {
    return stiffness;
  }

public float getDamping() {
    return damping;
  }

public boolean getTwoBodyRod() {
    return isTwoBodyRod;
  }

public boolean getIsJoint() {
    return this.isJoint;
}
@Override
public Rigidbody getRigidbodyA() {
    return rigidbodyA;
  }
@Override
public Rigidbody getRigidbodyB() {
    if(this.isTwoBodyRod) {
        return this.rigidbodyB;
    }
    return this.rigidbodyA;
  }



}



                /*
                if(!this.isHingeable) {
                    float rigidbodyAngle = rigidbodyB.getAngle();
                    this.rigidbodyOrientation.set(cos(rigidbodyAngle), sin(rigidbodyAngle));

                    float angleBetween = PVector.angleBetween(this.direction, this.rigidbodyOrientation);

                    if (this.direction.copy().cross(this.rigidbodyOrientation).z < 0) {
                        angleBetween = -angleBetween;
                    }

                    float angleDifference = angleBetween - this.initialAngleB;
                    //this.netTorque = -angleStiffness * angleDifference - angleDamping * rigidbody.getAngularVelocity();
                    //rigidbodyB.setAngle(rigidbodyB.getAngle()-angleDifference);
                    //force.add(0, 0, correctiveTorque);
                }
                */
  

public class Shape {


  private int opacity = interactivityListener.getOpacity();


  private PVector fill = new PVector();
  private PVector stroke = new PVector();

  public Shape() {
  }
  
  public void draw() {
    background(16, 18, 19);
    pushMatrix();
    translate(-1920/12.5f, -1080/12.5f);
    scale(0.05f);
    shape(background, 0, 0);
    popMatrix();
    
    drawRigidbodies();
  /*---------------------------------Collision Point Debugging--------------------------------------*/
    if(DRAW_AABBS) {
      drawAABB();
    }
    
    if(DRAW_CONTACT_POINTS) {
      drawCollisionPoints();
    }
  /*-----------------------------------------------------------------------------------------------*/
    drawForces();
  }

/*
====================================================================================================
==================================-=== Drawing Methods =============================================
====================================================================================================
*/
  public void drawRigidbodies() {
    boolean inEditMode = editor.getInEditMode();
    Rigidbody selectedRigidbody = editor.getSelectedRigidbody();

    for(int body = 0; body < rigidbodyList.size(); body++) {

      Rigidbody rigidbody = rigidbodyList.get(body);
        if(rigidbody.getIsVisible()) {
          if (rigidbody.getShapeType() == ShapeType.CIRCLE) {
            drawCircle(rigidbody.getPosition(), rigidbody.getRadius(),
                      rigidbody.getAngle(), rigidbody.getStrokeWeight(), rigidbody.getFillColour(),
                       rigidbody.getStrokeColour(), inEditMode);
          }

          if (rigidbody.getShapeType() == ShapeType.BOX) {
            if(rigidbody == selectedRigidbody && inEditMode) {
              drawPolygon(rigidbody.getPosition(), rigidbody.GetTransformedVertices(),
                          rigidbody.getStrokeWeight(), rigidbody.getFillColour(),
                          rigidbody.getStrokeColour(), false);
            } else {
              drawPolygon(rigidbody.getPosition(), rigidbody.GetTransformedVertices(),
                          rigidbody.getStrokeWeight(), rigidbody.getFillColour(),
                          rigidbody.getStrokeColour(), inEditMode);
            }
          }
        }
      }
  }

  public void drawCircle(PVector position, float radius, float angle, float strokeWeight, PVector fillColour,
    PVector strokeColour, boolean inEditMode) {

    float diameter = radius * 2.0f;

    this.stroke.set(strokeColour);
    this.fill.set(fillColour);


    if(inEditMode) {
      fill(this.fill.x, this.fill.y, this.fill.z, this.opacity);
      stroke(this.stroke.x, this.stroke.y, this.stroke.z, this.opacity);
    } else {
      fill(this.fill.x, this.fill.y, this.fill.z);
      stroke(this.stroke.x, this.stroke.y, this.stroke.z);
    }

    strokeWeight(strokeWeight);
    ellipseMode(CENTER);
    ellipse(position.x, position.y,  diameter,  diameter);

    PVector va = new PVector();
    PVector vb = new PVector(radius, 0);
    va = PhysEngMath.Transform(va, position, angle);
    vb = PhysEngMath.Transform(vb, position, angle);
    line(va.x, va.y, vb.x, vb.y);
    }

  public void drawCircle(PVector position, float radius, float angle, float strokeWeight, PVector fillColour,
    PVector strokeColour, float opacity) {

    float diameter = radius * 2.0f;

    this.stroke.set(strokeColour);
    this.fill.set(fillColour);

    fill(this.fill.x, this.fill.y, this.fill.z, opacity);
    stroke(this.stroke.x, this.stroke.y, this.stroke.z, opacity);

    strokeWeight(strokeWeight);
    ellipseMode(CENTER);
    ellipse(position.x, position.y,  diameter,  diameter);

    PVector va = new PVector();
    PVector vb = new PVector(radius, 0);
    va = PhysEngMath.Transform(va, position, angle);
    vb = PhysEngMath.Transform(vb, position, angle);
    line(va.x, va.y, vb.x, vb.y);
  }
  
  public void drawBox(PVector position, float width, float height, float angle, float strokeWeight,
    PVector fillColour, PVector strokeColour, boolean inEditMode) {

    this.stroke.set(strokeColour);
    this.fill.set(fillColour);


    if(inEditMode) {
      fill(this.fill.x, this.fill.y, this.fill.z, this.opacity);
      stroke(this.stroke.x, this.stroke.y, this.stroke.z, this.opacity);
    } else {
      fill(this.fill.x, this.fill.y, this.fill.z);
      stroke(this.stroke.x, this.stroke.y, this.stroke.z);
    }
    strokeWeight(strokeWeight);
    rectMode(CENTER);
    pushMatrix();
    rect(position.x, position.y, width, height);
    popMatrix();
  }

  public void drawBox(PVector position, float width, float height, float angle, float strokeWeight,
    PVector fillColour, PVector strokeColour, int opacity) {

    this.stroke.set(strokeColour);
    this.fill.set(fillColour);


    fill(this.fill.x, this.fill.y, this.fill.z, opacity);
    stroke(this.stroke.x, this.stroke.y, this.stroke.z, opacity);

    strokeWeight(strokeWeight);
    rectMode(CENTER);

    pushMatrix();
    rotate(angle);
    rect(position.x, position.y, width, height);
    popMatrix();
  }
  
  public void drawPolygon(PVector position, PVector[] transformedVertices, float strokeWeight,
    PVector fillColour, PVector strokeColour, boolean inEditMode) {
    
    this.stroke.set(strokeColour);
    this.fill.set(fillColour);

    if(inEditMode) {
      fill(this.fill.x, this.fill.y, this.fill.z, this.opacity);
      stroke(this.stroke.x, this.stroke.y, this.stroke.z, this.opacity);
    } else {
      fill(this.fill.x, this.fill.y, this.fill.z);
      stroke(this.stroke.x, this.stroke.y, this.stroke.z);
    }

    strokeWeight(strokeWeight);

    beginShape();
    for (PVector transformedVertex : transformedVertices) {
      vertex(transformedVertex.x, transformedVertex.y);
    }
    endShape(CLOSE);
  }


public void drawPolygon(PVector position, PVector[] transformedVertices, float strokeWeight,
    PVector fillColour, PVector strokeColour, int opacity) {
    
    this.stroke.set(strokeColour);
    this.fill.set(fillColour);

    fill(this.fill.x, this.fill.y, this.fill.z, opacity);
    stroke(this.stroke.x, this.stroke.y, this.stroke.z, opacity);

    strokeWeight(strokeWeight);

    beginShape();
    for (PVector transformedVertex : transformedVertices) {
      vertex(transformedVertex.x, transformedVertex.y);
    }
    endShape(CLOSE);
  }

  public void drawAABB() {
    for(Rigidbody rigidbody : rigidbodyList) {
        AABB aabb = rigidbody.GetAABB();
        rectMode(CORNERS);
        stroke(255, 0, 0);
        noFill();
        rect(aabb.getMin().x, aabb.getMin().y, aabb.getMax().x, aabb.getMax().y);
    }
  }

/*-----------------------------------------------------------------------------------------------*/
public void drawForces() {
    for(Rigidbody rigidbody : rigidbodyList) {
        for(ForceRegistry force : rigidbody.getForceRegistry()) {
            force.draw();
        }
    }
}
/*---------------------------------Collision Point Debugging--------------------------------------*/
  public void drawCollisionPoints() {
      for(PVector point : pointsOfContactList) {
        stroke(0, 0, 0);
        strokeWeight(0.1f);
        noFill();
        rectMode(CENTER);
        rect(point.x, point.y, 1, 1);
      }
        pointsOfContactList.clear();
    }

  
/*-----------------------------------------------------------------------------------------------*/

}

public enum ShapeType {
  CIRCLE,
  BOX,
  POLYGON,
  SOFTBODY
}
//ID 0: CIRCLE
//ID 1: BOX
//ID 2: POLYGON
//ID 3: SOFTBODY
public class Softbody {

    private PVector initialPosition;

    private float radius;
    private float rectWidth;
    private float rectHeight;

    private float stiffness = 1000;
    private float damping = 1f;

    private int numRowParticles;
    private int numColumnParticles;

    private float particleRadius = 0.5f;

    private ArrayList<Rigidbody> softbodyEntityList = new ArrayList<Rigidbody>();
    private ArrayList<Rigidbody> edgeParticles = new ArrayList<Rigidbody>();
    private Rigidbody[][] softBodyParticles;

    

    public Softbody(PVector initialPosition, float radius, float RectWidth, float RectHeight) {
        this.initialPosition = initialPosition;
        this.radius = radius;

        this.rectWidth = (int)round(RectWidth);
        this.rectHeight = (int)round(RectHeight);

        //Create a way to calculate this later
        this.numRowParticles = (int)round(this.rectWidth/this.particleRadius);
        this.numColumnParticles = (int)round(this.rectHeight/this.particleRadius);
        softBodyParticles = new Rigidbody[numRowParticles][numColumnParticles];

        softbodyList.add(this);
    }


    public void CreateBoxSoftbody() {
        float spacingX = 2f;
        float spacingY = 2f;

        float initialParticlePositionX = this.initialPosition.x - this.rectWidth/2;
        float initialParticlePositionY = this.initialPosition.y - this.rectHeight/2;

        for(int row = 0; row < numRowParticles; row++) {
            for(int column = 0; column < numColumnParticles; column++) {

                PVector currentParticlePosition = new PVector(initialParticlePositionX + row*spacingX, initialParticlePositionY + column*spacingY);

                Rigidbody currentParticle = RigidbodyGenerator.CreateCircleBody(particleRadius, 0.5f, 0.1f, false, true, 0.1f, new PVector(0,0,0), new PVector(255,255,255));
                currentParticle.setPosition(currentParticlePosition);

                softBodyParticles[row][column] = currentParticle;
                //currentParticle.setCollidability(false);
                currentParticle.addForceToForceRegistry(new Gravity(currentParticle));
                currentParticle.setIsVisible(false);
                AddBodyToBodyEntityList(currentParticle);
            }
        }


for(int row = 0; row < numRowParticles; row++) {
    for(int column = 0; column < numColumnParticles; column++) {

        Rigidbody currentParticle = softBodyParticles[row][column];

        // Link to particle below if it exists
        if(row < numRowParticles - 1) {
            Rigidbody particleToLinkTo = softBodyParticles[row+1][column];
            addSpringBetweenParticles(currentParticle, particleToLinkTo);
        }

        // Link to particle to the right if it exists
        if(column < numColumnParticles - 1) {
            Rigidbody particleToLinkTo = softBodyParticles[row][column+1];
            addSpringBetweenParticles(currentParticle, particleToLinkTo);
        }

        // Link to bottom-right diagonal if it exists
        if(row < numRowParticles - 1 && column < numColumnParticles - 1) {
            Rigidbody particleToLinkTo = softBodyParticles[row+1][column+1];
            addSpringBetweenParticles(currentParticle, particleToLinkTo);
        }

        // Link to top-right diagonal if it exists
        if(row > 0 && column < numColumnParticles - 1) {
            Rigidbody particleToLinkTo = softBodyParticles[row-1][column+1];
            addSpringBetweenParticles(currentParticle, particleToLinkTo);
        }
        
    }
}

    }

private void addSpringBetweenParticles(Rigidbody particleA, Rigidbody particleB) {
    Spring spring = new Spring(particleA, particleB, new PVector(), new PVector());
    
    spring.setSpringConstant(this.stiffness);
    spring.setDamping(this.damping);
    spring.drawSpring = false;

    particleA.addForceToForceRegistry(spring);
    particleB.addForceToForceRegistry(spring);
}

    public void updateSoftbody() {
      draw();
    }

    public void draw() {
        
        beginShape();
        for (int column = 0; column < numColumnParticles; column++) {
          PVector pos = softBodyParticles[0][column].getPosition();
          vertex(pos.x, pos.y);
        }
        // Right edge
        for (int row = 0; row < numRowParticles; row++) {
          PVector pos = softBodyParticles[row][numColumnParticles - 1].getPosition();
          vertex(pos.x, pos.y);
        }
        // Bottom edge
        for (int column = numColumnParticles - 1; column >= 0; column--) {
          PVector pos = softBodyParticles[numRowParticles - 1][column].getPosition();
          vertex(pos.x, pos.y);
        }
        // Left edge
        for (int row = numRowParticles - 1; row >= 0; row--) {
          PVector pos = softBodyParticles[row][0].getPosition();
          vertex(pos.x, pos.y);
        }
        endShape(CLOSE);

    }


/*

public void draw() {

    beginShape();
    PVector center = calculateCenter();
    // Top edge
    for (int column = 0; column < numColumnParticles; column++) {
        PVector pos = softBodyParticles[0][column].getPosition();
        PVector offset = pos.copy().sub(center).normalize().mult(particleRadius);
        vertex(pos.x + offset.x, pos.y + offset.y);
    }
    // Right edge
    for (int row = 0; row < numRowParticles; row++) {
        PVector pos = softBodyParticles[row][numColumnParticles - 1].getPosition();
        PVector offset = pos.copy().sub(center).normalize().mult(particleRadius);
        vertex(pos.x + offset.x, pos.y + offset.y);
    }
    // Bottom edge
    for (int column = numColumnParticles - 1; column >= 0; column--) {
        PVector pos = softBodyParticles[numRowParticles - 1][column].getPosition();
        PVector offset = pos.copy().sub(center).normalize().mult(particleRadius);
        vertex(pos.x + offset.x, pos.y + offset.y);
    }
    // Left edge
    for (int row = numRowParticles - 1; row >= 0; row--) {
        PVector pos = softBodyParticles[row][0].getPosition();
        PVector offset = pos.copy().sub(center).normalize().mult(radius);
        vertex(pos.x + offset.x, pos.y + offset.y);
    }

    endShape(CLOSE);
}

private PVector calculateCenter() {
    float totalX = 0;
    float totalY = 0;
    int count = 0;

    for (int row = 0; row < numRowParticles; row++) {
        for (int col = 0; col < numColumnParticles; col++) {
            PVector pos = softBodyParticles[row][col].getPosition();
            totalX += pos.x;
            totalY += pos.y;
            count++;
        }
    }

    if (count == 0) {
        return new PVector(0, 0); // or some default value in case there are no particles
    }

    float centerX = totalX / count;
    float centerY = totalY / count;

    return new PVector(centerX, centerY);
}
*/
}

public class Spring implements ForceRegistry {

    private Rigidbody rigidbodyA;
    private Rigidbody rigidbodyB;

    private PVector anchorPoint = new PVector();
    private PVector localAnchorA = new PVector();
    private PVector localAnchorB = new PVector();
    
    private boolean drawSpring = true;

    //Some default values
    private boolean lockTranslationToXAxis = false;
    private boolean lockTranslationToYAxis = false;
    
    private boolean isPerfectSpring = false;

    private float equilibriumLength = 1f; //Equilibrium length is a percentage of the total magnitude of the length
    private float springConstant = 50;
    private float damping = 0.5f;
    
    private float springLength;

    private boolean isTwoBodySpring;


    /*--------------- Reusable --------------- */
    private PVector worldAnchorA = new PVector();
    private PVector worldAnchorB = new PVector();

    private PVector velocityA = new PVector();
    private PVector velocityB = new PVector();

    private PVector direction = new PVector();



    public Spring(Rigidbody rigidbody, PVector localAnchorA, PVector anchorPoint) {

        this.rigidbodyA = rigidbody;
        this.localAnchorA.set(localAnchorA);
        this.anchorPoint.set(anchorPoint);

        this.springLength = PhysEngMath.Transform(localAnchorA, rigidbodyA.getPosition(), rigidbodyA.getAngle()).sub(anchorPoint).mag();

        this.isTwoBodySpring = false;

    }

    public Spring(Rigidbody rigidbodyA, Rigidbody rigidbodyB, PVector localAnchorA, PVector localAnchorB) {
        
        this.rigidbodyA = rigidbodyA;
        this.rigidbodyB = rigidbodyB;
        
        this.localAnchorA.set(localAnchorA);
        this.localAnchorB.set(localAnchorB);
        
        this.springLength = PhysEngMath.Transform(localAnchorB, rigidbodyB.getPosition(), rigidbodyB.getAngle()).sub(PhysEngMath.Transform(localAnchorA, rigidbodyA.getPosition(), rigidbodyA.getAngle())).mag();

        this.isTwoBodySpring = true;

    }

    @Override
    public PVector getForce(Rigidbody rigidbody, PVector position) {
        float totalForceMagnitude = 0f;
        float displacement = 0f;

        if(isTwoBodySpring) {
            velocityA.set(rigidbodyA.getVelocity());
            velocityB.set(rigidbodyB.getVelocity());
    
            if(rigidbody == rigidbodyA) {
                worldAnchorA.set(PhysEngMath.Transform(this.localAnchorA, position, rigidbodyA.getAngle()));
                worldAnchorB.set(PhysEngMath.Transform(this.localAnchorB, rigidbodyB.getPosition(), rigidbodyB.getAngle()));

                if(lockTranslationToYAxis) rigidbodyA.setVelocity(velocityA.set(0, velocityA.y));
                else if(lockTranslationToXAxis) rigidbodyA.setVelocity(velocityA.set(velocityA.x, 0));

                this.direction.set(worldAnchorB.sub(worldAnchorA));
                displacement = direction.mag();

                if(!isPerfectSpring){                                                                                    
                    totalForceMagnitude = (displacement - this.springLength * this.equilibriumLength) * this.springConstant;
                    direction.normalize();
                    totalForceMagnitude += (direction.dot(velocityB.sub(velocityA)) * this.damping);
                } else {
                    totalForceMagnitude = (displacement - this.springLength * this.equilibriumLength) * this.springConstant;
                }
                return this.direction.mult(totalForceMagnitude);
    
            } else {
                worldAnchorA.set(PhysEngMath.Transform(this.localAnchorA, rigidbodyA.getPosition(), rigidbodyA.getAngle()));
                worldAnchorB.set(PhysEngMath.Transform(this.localAnchorB, position, rigidbodyB.getAngle()));
            
                this.direction.set(worldAnchorB.sub(worldAnchorA));
                displacement = direction.mag();
                direction.normalize();

                if(lockTranslationToYAxis) rigidbodyB.setVelocity(velocityB.set(0, velocityB.y));
                else if(lockTranslationToXAxis) rigidbodyB.setVelocity(velocityB.set(velocityB.x, 0));

                if(!isPerfectSpring){                                                                                    
                    totalForceMagnitude = (displacement - this.springLength * this.equilibriumLength) * this.springConstant;
                    totalForceMagnitude += (direction.dot(velocityB.sub(velocityA)) * this.damping);
                } else {
                    totalForceMagnitude = (displacement - this.springLength * this.equilibriumLength) * this.springConstant;
                }

                return this.direction.mult(-totalForceMagnitude);
            }
        } else {
            worldAnchorA.set(PhysEngMath.Transform(this.localAnchorA, position, rigidbodyA.getAngle()));
            worldAnchorB.set(anchorPoint);
    
            velocityA.set(rigidbodyA.getVelocity());
            velocityB.set(0,0);

            this.direction.set(worldAnchorB.sub(worldAnchorA));
            displacement = direction.mag();
            direction.normalize();

            if(lockTranslationToYAxis) rigidbodyA.setVelocity(velocityA.set(0, velocityA.y));
            else if(lockTranslationToXAxis) rigidbodyA.setVelocity(velocityA.set(velocityA.x, 0));
            
            if(!isPerfectSpring){                                                                                    
                totalForceMagnitude = (displacement - this.springLength * this.equilibriumLength) * this.springConstant;
                direction.normalize();
                totalForceMagnitude += (direction.dot(velocityB.sub(velocityA)) * this.damping);
            } else {
                totalForceMagnitude = (displacement- this.springLength * this.equilibriumLength) * this.springConstant;
            }

            return this.direction.mult(totalForceMagnitude);
        }
    
} 

  

//TODO: IMPLEMENT A WAY TO MAKE THE SPRING SCALE WITH ITS LENGTH, SO THAT VISUALLY A LARGE SPRING
//WILL HAVE THICKER LINES, AND MORE OFFSET, ETC
    @Override
    public void draw() {
        if(this.drawSpring) {
            PVector worldAnchorA;
            PVector worldAnchorB;
            PVector direction;
            float length;

            if(isTwoBodySpring) {
                worldAnchorA = PhysEngMath.Transform(localAnchorA, rigidbodyA.getPosition(), rigidbodyA.getAngle());
                worldAnchorB = PhysEngMath.Transform(localAnchorB, rigidbodyB.getPosition(), rigidbodyB.getAngle());
            } else {
                worldAnchorA = PhysEngMath.Transform(localAnchorA, rigidbodyA.getPosition(), rigidbodyA.getAngle());
                worldAnchorB = this.anchorPoint;
            }

            direction = PVector.sub(worldAnchorA, worldAnchorB);
            length = direction.mag();
            direction.normalize();

            fill(255);

            float segments = 5;
            float segmentLength = length / segments;

            // Set the offset to a constant value
            float offsetMagnitude = 0.5f; // Adjust this value to change the size of the zigzags

            // Draw the rod
            strokeWeight(0.3f);
            stroke(0); // Black
            line(worldAnchorA.x, worldAnchorA.y, worldAnchorB.x, worldAnchorB.y);
            stroke(255); // White
            strokeWeight(0.1f);
            line(worldAnchorA.x, worldAnchorA.y, worldAnchorB.x, worldAnchorB.y);
            
            PVector segmentStart = new PVector();
            PVector segmentEnd = new PVector();
            PVector midPoint = new PVector();
            PVector midPoint1 = new PVector();
            PVector midPoint2 = new PVector();
            PVector directionSegmentLength = PVector.mult(direction, segmentLength);
            PVector offset1 = new PVector();
            PVector offset2 = new PVector();

            for(int i = 0; i < segments; i++) {

                segmentStart.set(PVector.add(worldAnchorB, PVector.mult(directionSegmentLength, i)));
                segmentEnd.set(PVector.add(worldAnchorB, PVector.mult(directionSegmentLength, i + 1)));

                // Calculate the midpoint of the segment
                midPoint.set(PVector.lerp(segmentStart, segmentEnd, 0.5f));

                if(i % 2 == 0) {
                    offset1.set(new PVector(-direction.y, direction.x).mult(offsetMagnitude));
                    offset2.set(new PVector(direction.y, -direction.x).mult(offsetMagnitude));
                } else {
                    offset1.set(new PVector(direction.y, -direction.x).mult(offsetMagnitude));
                    offset2.set(new PVector(-direction.y, direction.x).mult(offsetMagnitude));
                }

                // Add the offsets to the midpoint
                midPoint1.set(PVector.add(midPoint, offset1));
                midPoint2.set(PVector.add(midPoint, offset2));

                // Draw the lines
                strokeWeight(0.2f);
                stroke(0);
                line(segmentStart.x, segmentStart.y, midPoint1.x, midPoint1.y);
                line(midPoint1.x, midPoint1.y, segmentEnd.x, segmentEnd.y);
                line(segmentStart.x, segmentStart.y, midPoint2.x, midPoint2.y);
                line(midPoint2.x, midPoint2.y, segmentEnd.x, segmentEnd.y);
                strokeWeight(0.1f);
                stroke(255);
                line(segmentStart.x, segmentStart.y, midPoint1.x, midPoint1.y);
                line(midPoint1.x, midPoint1.y, segmentEnd.x, segmentEnd.y);
                line(segmentStart.x, segmentStart.y, midPoint2.x, midPoint2.y);
                line(midPoint2.x, midPoint2.y, segmentEnd.x, segmentEnd.y);
            }
        } else {
            return;
        }
    }

    @Override
    public PVector getApplicationPoint(Rigidbody rigidbody, PVector position) {
            if(rigidbody == rigidbodyA) {
                return PhysEngMath.Transform(localAnchorA, position, rigidbodyA.getAngle());
            } else {
                return PhysEngMath.Transform(localAnchorB, position, rigidbodyB.getAngle());
            }
    }

/*
====================================================================================================
================================== Getters & Setters ===============================================
====================================================================================================
*/
    public void setRigidbodyA(Rigidbody rigidbody){
        this.rigidbodyA = rigidbody;
    }
    public void setSpringConstant(float springConstant) {
        this.springConstant = springConstant;
    }

    public void setSpringLength(float springLength) {
        this.springLength = springLength;
    }

    public void setEquilibriumLength(float equilibriumLength) {
        this.equilibriumLength = equilibriumLength;
    }

    public void setDamping(float damping) {
        this.damping = damping;
    }

    public void setLockTranslationToXAxis(boolean lockTranslationToXAxis) {
        this.lockTranslationToXAxis = lockTranslationToXAxis;
    }

    public void setLockTranslationToYAxis(boolean lockTranslationToYAxis) {
        this.lockTranslationToYAxis = lockTranslationToYAxis;
    }

    public void setPerfectSpring(boolean isPerfectSpring) {
        this.isPerfectSpring = isPerfectSpring;
    }
    public void setDrawSpring(boolean drawSpring) {
        this.drawSpring = drawSpring;
    }
    public void setAnchorPoint(PVector anchorPoint) {
        this.anchorPoint.set(anchorPoint);
    }

    public void setAnchorPoint(float x, float y) {
        this.anchorPoint.set(x, y);
    }

    public void setLocalAnchorA(PVector localAnchorA) {
        this.localAnchorA.set(localAnchorA);
    }

    public void setLocalAnchorA(float x, float y) {
        this.localAnchorA.set(x, y);
    }

    public void setLocalAnchorB(PVector localAnchorB) {
        this.localAnchorB.set(localAnchorB);
    }

    public void setLocalAnchorB(float x, float y) {
        this.localAnchorB.set(x, y);
    }

    public float getSpringConstant() {
        return this.springConstant;
    }

    public float getSpringLength() {
        return this.springLength;
    }

    public float getEquilibriumLength() {
        return this.equilibriumLength;
    }

    public float getDamping() {
        return this.damping;
    }

    public boolean getLockTranslationToXAxis() {
        return this.lockTranslationToXAxis;
    }

    public boolean getLockTranslationToYAxis() {
        return this.lockTranslationToYAxis;
    }

    public boolean getPerfectSpring() {
        return this.isPerfectSpring;
    }

    public PVector getAnchorPoint() {
        return this.anchorPoint;
    }

    public PVector getLocalAnchorA() {
        return this.localAnchorA;
    }

    public PVector getLocalAnchorB() {
        return this.localAnchorB;
    }

    public boolean getDrawSpring() {
        return this.drawSpring;
    }
    @Override
    public Rigidbody getRigidbodyA() {
        return this.rigidbodyA;
    }
    @Override
    public Rigidbody getRigidbodyB() {
        if(isTwoBodySpring) {
            return this.rigidbodyB;
        }
        return this.rigidbodyA;
    }

    public boolean getIsTwoBodySpring() {
        return this.isTwoBodySpring;
    }
}


public class Timer {
	private Rigidbody rigidbody;
	private PVector startPosition;

	public Timer(Rigidbody rigidbody) {
		this.rigidbody = rigidbody;
		startPosition = rigidbody.getPosition();
	}

	public void reset() {
		rigidbody.setPosition(startPosition);
	}
}


  public void settings() { size(1500, 1000); }

  static public void main(String[] passedArgs) {
    String[] appletArgs = new String[] { "PhysicsEngine" };
    if (passedArgs != null) {
      PApplet.main(concat(appletArgs, passedArgs));
    } else {
      PApplet.main(appletArgs);
    }
  }
}
