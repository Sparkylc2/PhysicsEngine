/* autogenerated by Processing revision 1293 on 2024-04-16 */
import processing.core.*;
import processing.data.*;
import processing.event.*;
import processing.opengl.*;

import java.util.Iterator;
import java.util.Comparator;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.UUID;
import java.util.Stack;
import java.math.*;
import java.util.Set;
import java.util.Timer;
import java.util.TimerTask;
import java.awt.event.KeyEvent;
import java.awt.event.KeyListener;
import java.lang.Enum;
import processing.data.JSONArray;
import processing.data.JSONObject;
import processing.core.*;
import processing.javafx.*;
import garciadelcastillo.dashedlines.*;

import java.util.HashMap;
import java.util.ArrayList;
import java.io.File;
import java.io.BufferedReader;
import java.io.PrintWriter;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.IOException;

public class PhysicsEngine extends PApplet {

// Softbody softbody = new Softbody(new PVector(10, -20), 0, 2, 2);
// Softbody softbody2 = new Softbody(new PVector(-10, -20), 0, 2, 2);

public void setup() {
    if(System.getProperty("os.name").toLowerCase().contains("mac")) {
        windowMove(0, 22);
    }
    UI_QualitySettings qualitySettings = new UI_QualitySettings();
    if(qualitySettings.settings.getString("TextQuality").equals("High")){
        hint(ENABLE_STROKE_PURE);
    } else {
        hint(DISABLE_STROKE_PURE);
    }

    textFont(createFont(sketchPath() + "/data/fonts/InterDisplay-SemiBold.ttf", 128, true), 10);
    dash = new DashedLines(this);
    dash.pattern(1, 0.5f);
/*--------------------- Timing Utilities ---------------------*/ 
    FrameTimeUtility.init();

    //MAYBE DO SOMETHING TO CHECK WHICH FRAME RATE TO USE
    // frameRate(100);
/*--------------------- Camera Utilities ---------------------*/
    Camera = new Camera();
    playTimeTracker = new UI_QualitySettings();
    playTimeTracker.startPlaytimeTracking();
/*---------------------------- UI ----------------------------*/
    UI_Manager.init();
/*-------------------------- Rigidbodies ------------------------*/
    rigidbodyList = new ArrayList<Rigidbody>();
/*------------------------------------------------------------*/

        // Rigidbody springBody = RigidbodyGenerator.CreateBoxBody(4f, 1f, 1f, 0.5f, false, true, 0.05f, new PVector(0, 0, 0), new PVector(255, 255, 255));
    // springBody.setVelocity(new PVector(0,20));
    // springBody.SetInitialPosition(new PVector(-10, -5));

    // Spring springLeft = new Spring(springBody, new PVector(2,0), new PVector(-8, -10));
    // Spring springRight = new Spring(springBody, new PVector(-2,0), new PVector(-12, -10));

    // springBody.addForceToForceRegistry(springLeft);
    // springBody.addForceToForceRegistry(springRight);

    // springBody.addForceToForceRegistry(new Gravity(springBody));

    // AddBodyToBodyEntityList(springBody);






    Rigidbody floor = RigidbodyGenerator.CreateBoxBody(1000f, 5f, 1f, 0.5f, true, true, 0.05f, new PVector(0,0,0), new PVector(255,255,255));

    floor.SetInitialPosition(new PVector(0, 10));
   
    AddBodyToBodyEntityList(floor);

    // Rigidbody circle = RigidbodyGenerator.CreateCircleBody(1f, 1f, 0.5f, false, true, 0.05f, new PVector(0,0,0), new PVector(255,255,255));
    // circle.SetInitialPosition(new PVector(18, 0));
    // circle.setVelocity(new PVector(0, 60));


    // Spring spring1 = new Spring(circle, new PVector(0, 0), new PVector(0, -20));
    // spring1.setPerfectSpring(true);
    // spring1.setSpringConstant(10);
    // spring1.setEquilibriumLength(0);
    // Spring spring2 = new Spring(circle, new PVector(0, 0), new PVector(0, 20));
    // spring2.setPerfectSpring(true);
    // spring2.setSpringConstant(10);
    // spring2.setEquilibriumLength(0);
    // Spring spring3 = new Spring(circle, new PVector(0, 0), new PVector(-20, 0));
    // spring3.setPerfectSpring(true);
    // spring3.setSpringConstant(10);
    // spring3.setEquilibriumLength(0);
    // Spring spring4 = new Spring(circle, new PVector(0, 0), new PVector(20, 0));
    // spring4.setPerfectSpring(true);
    // spring4.setSpringConstant(10);
    // spring4.setEquilibriumLength(0);

    // circle.addForceToForceRegistry(spring1);
    // circle.addForceToForceRegistry(spring2);
    // circle.addForceToForceRegistry(spring3);
    // circle.addForceToForceRegistry(spring4);



    // AddBodyToBodyEntityList(circle);



}



public void draw() {
    FrameTimeUtility.calculateFrameTime();
        Camera.onFrameStart();
            /*--------------------- Main Methods ---------------------*/
            UI_Manager.interactionDraw();
            
            Step(FrameTimeUtility.DT, SUB_STEP_COUNT);
            /*--------------------------------------------------------*/
    
        Camera.onFrameEnd();
        UI_Manager.draw();
    
    FrameTimeUtility.displayTimings();
    FrameTimeUtility.updateFrameTime();
}


public class AABB {

  private final PVector Min;
  private final PVector Max;

/*
====================================================================================================
========================================== Constructors ============================================
====================================================================================================
*/

  public AABB(PVector min, PVector max) {
      this.Min = min;
      this.Max = max;
  }
  
  
/*-------------------------------------Overloaded Constructor-------------------------------------*/
  public AABB(float minX, float minY, float maxX, float maxY) {
      this.Min = new PVector(minX, maxY);
      this.Max = new PVector(maxX, maxY);
  }
  
  public AABB(PVector vec1, PVector vec2, boolean autoFix) {
      this.Min = new PVector(min(vec1.x, vec2.x), min(vec1.y, vec2.y));
      this.Max = new PVector(max(vec1.x, vec2.x), max(vec1.y, vec2.y));
  
  }
  
  public void drawAABB() {
    rectMode(CORNERS);
    dash.rect(Min.x, Min.y, Max.x, Max.y);
  }
  

  
  public void shiftAABB(PVector amount) {
    this.Min.add(amount);
    this.Max.add(amount);
  }


  public float calculateArea() {
    return abs((Max.x - Min.x) * (Max.y - Min.y));
  }

  public void recalculateMaxAndMin(ArrayList<Rigidbody> rigidbodies) {
    float minX = Float.MAX_VALUE;
    float minY = Float.MAX_VALUE;
    float maxX = -Float.MAX_VALUE;
    float maxY = -Float.MAX_VALUE;


    float prcnt = 0.125f;

    for (Rigidbody rb : rigidbodies) {
      PVector rbMin = rb.GetAABB().getMin();
      PVector rbMax = rb.GetAABB().getMax();

      if (rbMin.x < minX) {
        minX = rbMin.x;
      }
      if (rbMin.y < minY) {
        minY = rbMin.y;
      }
      if (rbMax.x > maxX) {
        maxX = rbMax.x;
      }
      if (rbMax.y > maxY) {
        maxY = rbMax.y;
      }
    }

    float prcntPad = max(abs(maxX - minX) * prcnt, abs(maxY - minY) * prcnt);
    
    Min.x = minX - prcntPad;
    Min.y = minY - prcntPad;
    Max.x = maxX + prcntPad;
    Max.y = maxY + prcntPad;
  }


  public PVector calculateCenter() {
    return new PVector((Max.x + Min.x) / 2, (Max.y + Min.y) / 2);
  }



/*
====================================================================================================
==============================================GETTERS & SETTERS=====================================
====================================================================================================
*/
    public PVector getMin() {
      return Min;
    }
  
    public PVector getMax() {
      return Max;
    }
  
}


public class Camera {

    public PVector position;
    public PVector targetPosition;
    public float zoom;
    public float targetZoom;
    float easing = 0.05f;
  

    public Camera() {
        position = new PVector(0, -20);
        targetPosition = new PVector(0, -20);
        zoom = 10f;
        targetZoom = 10f;

    }

    public void updateCamera() {
        position.x = lerp(position.x, targetPosition.x, easing);
        position.y = lerp(position.y, targetPosition.y, easing);

        zoom = lerp(zoom, targetZoom, easing);
    }
    
    public void zoom(float amount, float mouseX, float mouseY) {
        PVector mouseBeforeZoom = screenToWorld(mouseX, mouseY);
        targetZoom *= amount;
        PVector mouseAfterZoom = screenToWorld(mouseX, mouseY);
        PVector shift = PVector.sub(mouseBeforeZoom, mouseAfterZoom);
        targetPosition.add(shift);
    }


    public void applyTransform() {
        pushMatrix();
        translate(width/2, height/2);
        scale(zoom);
        translate(-position.x, -position.y);
    }

    public void resetTransform() {
        popMatrix();
    }
  
    public PVector screenToWorld(float x, float y) {
        float worldX = (x - width/2) / zoom + position.x;
        float worldY = (y - height/2) / zoom + position.y;

        return new PVector(worldX, worldY);
    }

    public PVector screenToWorld(){
        return new PVector((mouseX - width / 2) / zoom + position.x, (mouseY - height / 2) / zoom + position.y);
    }

    public void move(float dx, float dy) {
        targetPosition.x += dx / zoom;
        targetPosition.y += dy / zoom;
    }

    public float[] getCameraExtents(float padding) {
        float left = screenToWorld(padding, padding).x;
        float right = screenToWorld(width - padding, padding).x;
        float top = screenToWorld(padding, padding).y;
        float bottom = screenToWorld(width - padding, height - padding).y;  

        return new float[] {left, right, top, bottom};
    }

    public PVector[] getWorldBoundsWithPadding(float padding) {
        PVector topLeft = screenToWorld(padding, padding);
        PVector topRight = screenToWorld(width - padding, padding);
        PVector bottomLeft = screenToWorld(padding, height - padding);
        PVector bottomRight = screenToWorld(width - padding, height - padding);

        return new PVector[] {topLeft, topRight, bottomLeft, bottomRight};
    }
    
    public void onFrameStart() {
        Mouse.updateMouse();
        this.updateCamera();
        this.applyTransform();
        Render.draw();
        Mouse.drawCursor(); 
    }

    public void onFrameEnd() {
        popMatrix();
    }
}
public class Cloth {

    private PVector initialLeftCornerPosition;
    private PVector initialRightCornerPosition;

    private float clothWidth;
    private float clothHeight;

    private float stiffness = 300f;
    private float damping = 1f;

    private int numRowParticles;
    private int numColumnParticles;
    private int spacing = 2;
    private float particleRadius = 0.5f;

    private Rigidbody[][] clothBodyParticles;

    public Cloth(PVector initialLeftCornerPosition, PVector initialRightCornerPosition, float length) {

        this.initialLeftCornerPosition = initialLeftCornerPosition;
        this.initialRightCornerPosition = initialRightCornerPosition;
        this.clothWidth = (int)round(PVector.sub(initialLeftCornerPosition, initialRightCornerPosition).mag() / 5.0f) * 5;
        this.clothHeight = (int)round(length / spacing) * spacing;

        this.numRowParticles = (int)clothWidth/spacing;
        this.numColumnParticles = (int)clothHeight/spacing;
        clothBodyParticles = new Rigidbody[numRowParticles][numColumnParticles];
    }


    public void CreateCloth() {
        float initialParticlePositionX = this.initialLeftCornerPosition.x;
        float initialParticlePositionY = this.initialLeftCornerPosition.y;

        for(int row = 0; row < numRowParticles; row++) {
            for(int column = 0; column < numColumnParticles; column++) {

                PVector currentParticlePosition = new PVector(initialParticlePositionX + row*spacing, initialParticlePositionY + column*spacing);

                Rigidbody currentParticle = RigidbodyGenerator.CreateCircleBody(particleRadius, 0.5f, 0.02f, false, true, 0.1f, new PVector(0,0,0), new PVector(255,255,255));
                currentParticle.setPosition(currentParticlePosition);
                currentParticle.previousPosition = currentParticlePosition.copy();

                clothBodyParticles[row][column] = currentParticle;

                currentParticle.addForceToForceRegistry(new Gravity(currentParticle));
                currentParticle.setIsVisible(false);
                AddBodyToBodyEntityList(currentParticle);
            }
        }

        clothBodyParticles[0][0].setIsVisible(true);
        clothBodyParticles[numRowParticles - 1][0].setIsVisible(true);

        clothBodyParticles[0][0].setIsStatic(true);
        clothBodyParticles[numRowParticles - 1][0].setIsStatic(true);


        for(int row = 0; row < numRowParticles; row++) {
            for(int column = 0; column < numColumnParticles; column++) {
            
                Rigidbody currentParticle = clothBodyParticles[row][column];

                // Link to particle below if it exists
                if(row < numRowParticles - 1) {
                    Rigidbody particleToLinkTo = clothBodyParticles[row+1][column];
                    addSpringBetweenParticles(currentParticle, particleToLinkTo);
                }

                // Link to particle to the right if it exists
                if(column < numColumnParticles - 1) {
                    Rigidbody particleToLinkTo = clothBodyParticles[row][column+1];
                    addSpringBetweenParticles(currentParticle, particleToLinkTo);
                }

                if (row == 0 || row == numRowParticles - 1 || column == 0 || column == numColumnParticles - 1) {
                    // If the particle is on the edge, set its collidability to true
                    currentParticle.setCollidability(true);
                } else {
                    // If the particle is not on the edge, set its collidability to false
                    currentParticle.setCollidability(false);
                }
                
            }
        }
    }

    private void addSpringBetweenParticles(Rigidbody particleA, Rigidbody particleB) {
        Spring spring = new Spring(particleA, particleB, new PVector(), new PVector());
        spring.setSpringLength(PVector.dist(particleA.getPosition(), particleB.getPosition()));
        spring.setSpringConstant(this.stiffness);
        spring.setDamping(this.damping);
        spring.drawSpring = false;

        particleA.addForceToForceRegistry(spring);
        particleB.addForceToForceRegistry(spring);
    }

    public void updateCloth() {
      draw();
    }




    public void draw() {
beginShape(LINES);
for (int row = 0; row < numRowParticles; row++) {
    for (int column = 0; column < numColumnParticles - 1; column++) {
        PVector pos = clothBodyParticles[row][column].getPosition();
        PVector rightPos = clothBodyParticles[row][column + 1].getPosition();
        vertex(pos.x, pos.y);
        vertex(rightPos.x, rightPos.y);
    }
}
endShape();

// Draw vertical lines
beginShape(LINES);
for (int column = 0; column < numColumnParticles; column++) {
    for (int row = 0; row < numRowParticles - 1; row++) {
        PVector pos = clothBodyParticles[row][column].getPosition();
        PVector bottomPos = clothBodyParticles[row + 1][column].getPosition();
        vertex(pos.x, pos.y);
        vertex(bottomPos.x, bottomPos.y);
    }
}
endShape();


    }


}

public class CollisionManifold {

    private final Rigidbody RigidbodyA;
    private final Rigidbody RigidbodyB;
    private final PVector Normal;
    private final float Depth;

    private final PVector[] PointsOfContact;
    private final int ContactCount;

    public CollisionManifold(Rigidbody rigidbodyA, Rigidbody rigidbodyB,
                             CollisionResult collisionResult) {

        this.RigidbodyA = rigidbodyA;
        this.RigidbodyB = rigidbodyB;
        this.Normal = collisionResult.getNormal();
        this.Depth = collisionResult.getDepth();
        this.PointsOfContact = collisionResult.getPointsOfContact();
        this.ContactCount = collisionResult.getContactCount();
    }
    

    public Rigidbody getRigidbodyA() {
        return RigidbodyA;
    }

    public Rigidbody getRigidbodyB() {
        return RigidbodyB;
    }

    public PVector getNormal() {
        return Normal;
    }

    public float getDepth() {
        return Depth;
    }

    public PVector[] getPointsOfContact() {
        return PointsOfContact;
    }

    public int getContactCount() {
        return ContactCount;
    }


}
public class CollisionResult {
 
  private boolean isColliding;
  private PVector normal = new PVector();
  private float depth;

  private float distanceSquared;

  private PVector[] pointsOfContact;

  private int contactCount;

  


/*
====================================================================================================
================================ PointSegmentDistance Constructor ==================================
====================================================================================================
*/

//Default constructor for no collision
  public CollisionResult(){

    this.isColliding = false;
    this.normal.set(0,0,0);
    this.depth = 0f;
    this.pointsOfContact = null;
    this.contactCount = 0;
  }


  public CollisionResult(float distanceSquared, PVector pointOfContact) {


    this.distanceSquared = distanceSquared;

    this.pointsOfContact = new PVector[] {pointOfContact};
  }



  public CollisionResult(PVector[] pointsOfContact) {
    this.isColliding = true;

    this.pointsOfContact = pointsOfContact;
    this.contactCount = pointsOfContact.length;
  }

  public CollisionResult(boolean isColliding, PVector normal, float depth, PVector[] pointsOfContact) {
    this.isColliding = isColliding;
    this.normal = normal;
    this.depth = depth;

    this.pointsOfContact = pointsOfContact;
    this.contactCount = pointsOfContact.length;
  }

  
  public CollisionResult(boolean isColliding, PVector normal, float depth) {
    this.isColliding = isColliding;
    this.normal = normal;
    this.depth = depth;
    this.pointsOfContact = null;
    this.contactCount = 0;
  }
 
  /*
  =====================================================================================================
  =========================================== Getters/Setters =========================================
  =====================================================================================================
  */

  public boolean getIsColliding() {
    return isColliding;
  }
  
  public PVector getNormal() {
    return normal;
  }

  public float getDepth() {
    return depth;
  }

  public PVector[] getPointsOfContact() {
    return pointsOfContact;
  }

  public int getContactCount() {
    return contactCount;
  }
  
  public float getDistanceSquared() {
    return distanceSquared;
  }


  public void setIsColliding(boolean isColliding) {
    this.isColliding = isColliding;
  }

  public void setNormal(PVector normal) {
    this.normal = normal;
  }

  public void setDepth(float depth) {
    this.depth = depth;
  }
  public void setDistanceSquared(float distanceSquared) {
    this.distanceSquared = distanceSquared;
  }

  //Overloaded Methods
  public void setPointsOfContact(PVector[] pointsOfContact) {
    this.pointsOfContact = pointsOfContact;
  }
  
  public void setPointsOfContact(PVector pointOfContact) {
    this.pointsOfContact = new PVector[] {pointOfContact};
  }

  public void setPointsOfContact(PVector pointOfContactA, PVector pointOfContactB) {
    this.pointsOfContact = new PVector[] {pointOfContactA, pointOfContactB};
  }

  public void setContactCount(int contactCount) {
    this.contactCount = contactCount;
  }

}
public static class Collisions {
  CollisionResult collisionResult;

  //This is required as there is no enclosing instance of physics class for collisionResult
  public static PhysicsEngine physicsEngine = new PhysicsEngine();




  /*------------------- Reusable  ------------------- */
  public static PVector ZeroNormal = new PVector();
/*
====================================================================================================
===================================== COLLIDE INFO =================================================
====================================================================================================
*/

/*optimizied*/
public static CollisionResult Collide(Rigidbody rigidbodyA, Rigidbody rigidbodyB) {

    ShapeType shapeTypeA = rigidbodyA.getShapeType();
    ShapeType shapeTypeB = rigidbodyB.getShapeType();

    if(shapeTypeA == ShapeType.BOX) {

      if(shapeTypeB == ShapeType.BOX) {

        return IntersectPolygon(rigidbodyA.getPosition(),
                                           rigidbodyA.GetTransformedVertices(),
                                           rigidbodyB.getPosition(),
                                           rigidbodyB.GetTransformedVertices());

      } else if(shapeTypeB == ShapeType.CIRCLE) {
        CollisionResult result = Collisions.IntersectCirclePolygon(rigidbodyB.getPosition(),
                                                                   rigidbodyB.getRadius(),
                                                                   rigidbodyA.getPosition(),
                                                                   rigidbodyA.GetTransformedVertices()
                                                                   );
        result.setNormal(result.getNormal().mult(-1));
        return result;

      }

    }
  if (shapeTypeA == ShapeType.CIRCLE) {
        
        if(shapeTypeB == ShapeType.BOX) {

          return IntersectCirclePolygon(rigidbodyA.getPosition(), 
                                                   rigidbodyA.getRadius(), 
                                                   rigidbodyB.getPosition(), 
                                                   rigidbodyB.GetTransformedVertices());

        } else if(shapeTypeB == ShapeType.CIRCLE) {

          return IntersectCircle(rigidbodyA.getPosition(), rigidbodyB.getPosition(), rigidbodyA.getRadius(), rigidbodyB.getRadius());

        }
      }

    return physicsEngine.new CollisionResult();
  }


/*
====================================================================================================
===================================== CONTACT-POINTS COLLISIONS ====================================
======================================= COLLISION-RESULT ===========================================
*/

/*optimized*/

public static void FindCollisionPoints(Rigidbody rigidbodyA, Rigidbody rigidbodyB,
                                                  CollisionResult collisionResult) {
    int contactCount = 0;

    ShapeType shapeTypeA = rigidbodyA.getShapeType();
    ShapeType shapeTypeB = rigidbodyB.getShapeType();

    if(shapeTypeA == ShapeType.BOX) {

      if(shapeTypeB == ShapeType.BOX) {
        PVector[] pointsOfContact = FindPolygonsCollisionPoints(rigidbodyA.GetTransformedVertices(),
                                                                rigidbodyB.GetTransformedVertices());
        collisionResult.setPointsOfContact(pointsOfContact);
        collisionResult.setContactCount(pointsOfContact.length);
        return;

      } else if(shapeTypeB == ShapeType.CIRCLE) {
        PVector[] pointsOfContact = FindCirclePolygonCollisionPoint(rigidbodyB.getPosition(),
                                                                    rigidbodyB.getRadius(),
                                                                    rigidbodyA.getPosition(),
                                                                    rigidbodyA.GetTransformedVertices());
        collisionResult.setPointsOfContact(pointsOfContact);
        collisionResult.setContactCount(1);
        return;
      }

    }
  if (shapeTypeA == ShapeType.CIRCLE) {
        
        if(shapeTypeB == ShapeType.BOX) {
          PVector[] pointsOfContact = FindCirclePolygonCollisionPoint(rigidbodyA.getPosition(),
                                                                      rigidbodyA.getRadius(),
                                                                      rigidbodyB.getPosition(),
                                                                      rigidbodyB.GetTransformedVertices());
          collisionResult.setPointsOfContact(pointsOfContact);
          collisionResult.setContactCount(1);
          return;

        } else if(shapeTypeB == ShapeType.CIRCLE) {
           PVector[] pointsOfContact = FindCirclesCollisionPoint(rigidbodyA.getPosition(),
                                                                 rigidbodyA.getRadius(),
                                                                 rigidbodyB.getPosition(),
                                                                 rigidbodyB.getRadius());
            collisionResult.setPointsOfContact(pointsOfContact);
            collisionResult.setContactCount(1);
            return;
        }
      }

    /*
    For displaying the points of contact
        for(PVector point : pointsOfContact) {
             //pointsOfContactList.add(point);
        }
   */

}
/*
====================================================================================================
============================== CIRCLE-CIRCLE COLLISION CONTACT POINT ===============================
======================================= COLLISION-RESULT ===========================================
====================================================================================================
*/
 private static PVector[] FindCirclesCollisionPoint(PVector centerA, float radiusA,
                                                         PVector centerB, float radiusB) {
    

    return new PVector[] {PVector.add(centerA, PVector.sub(centerB, centerA).normalize().mult(radiusA))};
    }
/*
====================================================================================================
=============================POLYGON-POLYGON COLLISION CONTACT POINT ===============================
======================================= COLLISION-RESULT ===========================================
====================================================================================================
*/


private static PVector[] FindPolygonsCollisionPoints(PVector[] transformedVerticesA,
                                                           PVector[] transformedVerticesB) {
  PVector contactPointA = new PVector();
  PVector contactPointB = new PVector();

  PVector vertexA = new PVector();
  PVector vertexB = new PVector();
  
  PVector point = new PVector();
  int contactCount = 0;

  float minDistanceSquared = Float.MAX_VALUE;

  for(int i = 0; i < transformedVerticesA.length; i++) {

      point.set(transformedVerticesA[i]);

      for(int j = 0; j < transformedVerticesB.length; j++) {
        
        CollisionResult pointSegmentDistanceResult = PointSegmentDistance(point, transformedVerticesB[j], transformedVerticesB[(j + 1) % transformedVerticesB.length]);

        if(PhysEngMath.Equals(pointSegmentDistanceResult.getDistanceSquared(),minDistanceSquared)) {

            if(!PhysEngMath.Equals(pointSegmentDistanceResult.getPointsOfContact()[0], contactPointA)) {

              contactPointB.set(pointSegmentDistanceResult.getPointsOfContact()[0]);
              contactCount = 2;

            }
            
        } else if(pointSegmentDistanceResult.getDistanceSquared() < minDistanceSquared) {

            minDistanceSquared = pointSegmentDistanceResult.getDistanceSquared();
            contactPointA.set(pointSegmentDistanceResult.getPointsOfContact()[0]);
            contactCount = 1;
        }
      }
    }


  for(int i = 0; i < transformedVerticesB.length; i++) {

      point.set(transformedVerticesB[i]);

      for(int j = 0; j < transformedVerticesA.length; j++) {
          
          vertexA.set(transformedVerticesA[j]);
          vertexB.set(transformedVerticesA[(j + 1) % transformedVerticesA.length]);
  
          CollisionResult pointSegmentDistanceResult = PointSegmentDistance(point, transformedVerticesA[j], transformedVerticesA[(j + 1) % transformedVerticesA.length]);

        if(PhysEngMath.Equals(pointSegmentDistanceResult.getDistanceSquared(),minDistanceSquared)) {

            if(!PhysEngMath.Equals(pointSegmentDistanceResult.getPointsOfContact()[0], contactPointA)) {
              contactPointB.set(pointSegmentDistanceResult.getPointsOfContact()[0]);
              contactCount = 2;
            }

        } else if(pointSegmentDistanceResult.getDistanceSquared() < minDistanceSquared) {
            minDistanceSquared = pointSegmentDistanceResult.getDistanceSquared();
            contactPointA.set(pointSegmentDistanceResult.getPointsOfContact()[0]);
            contactCount = 1;
        }
      }
    }

    if(contactCount == 1){
      return new PVector[] {contactPointA};
    }
    
    return new PVector[] {contactPointA, contactPointB};
  
}

/*
====================================================================================================
=============================CIRCLE-POLYGON COLLISION CONTACT POINT ===============================
======================================= COLLISION-RESULT ===========================================
====================================================================================================
*/

/*Somewhat optimized */

private static PVector[] FindCirclePolygonCollisionPoint(PVector circleCenter,
                                                         float circleRadius,
                                                         PVector polygonCenter,
                                                         PVector[] transformedVertices) {

    float minDistanceSquared = Float.MAX_VALUE;
    PVector contactPoint = new PVector();

    for(int i = 0; i < transformedVertices.length; i++) {

        CollisionResult pointSegmentDistanceResult = PointSegmentDistance(circleCenter, transformedVertices[i], transformedVertices[(i + 1) % transformedVertices.length]); 

        if(pointSegmentDistanceResult.getDistanceSquared() < minDistanceSquared) {

            minDistanceSquared = pointSegmentDistanceResult.getDistanceSquared();
            contactPoint.set(pointSegmentDistanceResult.getPointsOfContact()[0]);
        }
    }

    return new PVector[] {contactPoint};
  }


/*
====================================================================================================
===================================== AABB-AABB Collisions =========================================
====================================================================================================
*/
public static boolean IntersectAABB (AABB aabbA, AABB aabbB) {

  if(aabbA.getMax().x <= aabbB.getMin().x || aabbB.getMax().x <= aabbA.getMin().x
    || aabbA.getMax().y <= aabbB.getMin().y || aabbB.getMax().y <= aabbA.getMin().y) {

    return false;
  }

  return true;
}

/*
====================================================================================================
===================================== AABB-AABB Point Collision ====================================
====================================================================================================
*/
public static boolean IntersectAABBWithPoint(AABB aabb, PVector point) {
    if (point.x >= aabb.getMin().x && point.x <= aabb.getMax().x &&
        point.y >= aabb.getMin().y && point.y <= aabb.getMax().y) {
        return true; // The point is within the AABB
    }
    return false; // The point is outside the AABB
  }

/*
====================================================================================================
===================================== CIRCLE-CIRCLE COLLISIONS =====================================
======================================= COLLISION-RESULT ===========================================
====================================================================================================
*/
/*somewhat Optimized*/
  public static CollisionResult IntersectCircle(PVector centerA, PVector centerB,
                                                float radiusA, float radiusB) {

    PVector direction = PVector.sub(centerB, centerA);
    float distance = direction.mag();
    float radiusSum = (radiusA + radiusB);
    
    if(distance < radiusSum) {
      return physicsEngine.new CollisionResult(true, direction.normalize(), radiusSum - distance);
    } else {
      return physicsEngine.new CollisionResult();
    }
  }
  
                                             

/*
====================================================================================================
===================================== POLYGON-POLYGON COLLISIONS ===================================
======================================= COLLISION-RESULT============================================
====================================================================================================
*/

/*Optimized somewhat*/
public static CollisionResult IntersectPolygon(PVector centerA,
                                               PVector[] transformedVerticesA,
                                               PVector centerB,
                                               PVector[] transformedVerticesB) {

    float depth = Float.MAX_VALUE;

    PVector axis = new PVector();
    PVector normal = new PVector();
    PVector edge = new PVector();

    PVector transformedVertexA = new PVector();
    PVector transformedVertexB = new PVector();

    PVector secondTransformedVertexA = new PVector();
    PVector secondTransformedVertexB = new PVector();


    for(int vertexIndexA = 0; vertexIndexA < transformedVerticesA.length; vertexIndexA++) {
 

      //Gets the transformed vertices in polygon A, when at the end of the list, loops back to the start
      transformedVertexA.set(transformedVerticesA[vertexIndexA]);
      transformedVertexB.set(transformedVerticesA[(vertexIndexA + 1) % transformedVerticesA.length]);

      //Finds the edge between the two vertices,
      edge.set(PVector.sub(transformedVertexB, transformedVertexA));

      //Finds the normal or "axis" from the edge vector
      axis.set(-edge.y, edge.x);
      axis.normalize();

      //Projects the vertices of polygon A onto the axis. Format is [min, max]
      float[] minMaxA = ProjectVertices(transformedVerticesA, axis);
      float[] minMaxB = ProjectVertices(transformedVerticesB, axis);

      if(minMaxA[0] >= minMaxB[1] || minMaxB[0] >= minMaxA[1]) {
        return physicsEngine.new CollisionResult();
      }

      float axisDepth = min(minMaxB[1]-minMaxA[0], minMaxA[1]-minMaxB[0]);

      if(axisDepth < depth) {
        depth = axisDepth;
        normal.set(axis);
      }
    }

    for(int vertexIndexB = 0; vertexIndexB < transformedVerticesB.length; vertexIndexB++) {
      //!!!ALL OF THIS ASSUMES A CLOCKWISE WINDING ORDER!!!

      //Gets the transformed vertices in polygon A, when at the end of the list, loops back to the start
      secondTransformedVertexA.set(transformedVerticesB[vertexIndexB]);
      secondTransformedVertexB.set(transformedVerticesB[(vertexIndexB + 1) % transformedVerticesB.length]);

      //Finds the edge between the two vertices, 
      edge.set(PVector.sub(secondTransformedVertexB, secondTransformedVertexA));

      //Finds the normal or "axis" from the edge vector
      axis.set(-edge.y, edge.x);
      axis.normalize();

      //Projects the vertices of polygon A onto the axis. Format is [min, max]
      float[] minMaxA = ProjectVertices(transformedVerticesA, axis);
      float[] minMaxB = ProjectVertices(transformedVerticesB, axis);

      if(minMaxA[0] >= minMaxB[1] || minMaxB[0] >= minMaxA[1]) {        
        return physicsEngine.new CollisionResult();
      }

      float axisDepth = min(minMaxB[1]-minMaxA[0], minMaxA[1]-minMaxB[0]);
      
      if(axisDepth < depth) {
        depth = axisDepth;
        normal.set(axis);
      }
    }

    //This is correction code so that the normal points in the correct direction
    //If its not pointing in the correct direction, flip the normal
  
    if(PVector.dot(PVector.sub(centerB, centerA), normal) < 0) {
      normal.mult(-1);
    }

    return physicsEngine.new CollisionResult(true, normal, depth);
  }

//The overloaded method is used when the center of the polygon is not known


/*
====================================================================================================
===================================== CIRCLE-POLYGON COLLISIONS ====================================
======================================= COLLISION-RESULT ===========================================
====================================================================================================
*/


public static CollisionResult IntersectCirclePolygon(PVector circleCenter, float circleRadius,
                                                     PVector polygonCenter,
                                                     PVector[] transformedVertices){
    boolean isColliding;
    float depth = Float.MAX_VALUE;
    PVector normal = new PVector();

    PVector edge = new PVector();
    PVector axis = new PVector();

    float axisDepth = 0f;

    for(int vertexIndex = 0; vertexIndex < transformedVertices.length; vertexIndex++) {
      //!!!ALL OF THIS ASSUMES A CLOCKWISE WINDING ORDER!!!

      //Finds the edge between the two vertices,
      edge.set(PVector.sub(transformedVertices[(vertexIndex + 1) % transformedVertices.length], transformedVertices[vertexIndex]));
      
      //Finds the normal or "axis" from the edge vector
       axis.set(-edge.y, edge.x);
       axis.normalize();

      //Projects the vertices of polygon A onto the axis. Format is [min, max]
      float[] minMaxA = ProjectVertices(transformedVertices, axis);

      //Projects the circle onto the axis. Format is [min, max]
      float[] minMaxB = ProjectCircle(circleCenter, axis, circleRadius);

      if(minMaxA[0] >= minMaxB[1] || minMaxB[0] >= minMaxA[1]) {

        return physicsEngine.new CollisionResult();
      }

       axisDepth = min(minMaxB[1]-minMaxA[0], minMaxA[1]-minMaxB[0]);
        if(axisDepth < depth) {
            depth = axisDepth;
            normal.set(axis);
        }
  }

    int index = FindClosestPointOnPolygon(circleCenter, transformedVertices);
    
    if(index == -1) {
      return physicsEngine.new CollisionResult();
    }
    axis.set(PVector.sub(transformedVertices[index], circleCenter).normalize());

     //Projects the vertices of polygon A onto the axis. Format is [min, max]
      float[] minMaxA = ProjectVertices(transformedVertices, axis);
      //Projects the circle onto the axis. Format is [min, max]
      float[] minMaxB = ProjectCircle(circleCenter, axis, circleRadius);


      if(minMaxA[0] >= minMaxB[1] || minMaxB[0] >= minMaxA[1]) {
        
        return physicsEngine.new CollisionResult();
      }

      axisDepth = min(minMaxB[1]-minMaxA[0], minMaxA[1]-minMaxB[0]);

      if(axisDepth < depth) {
        depth = axisDepth;
        normal.set(axis);
      }

        if(PVector.dot(PVector.sub(polygonCenter, circleCenter), normal) < 0) {
          normal.mult(-1);
        }
  
        isColliding = true;

        return physicsEngine.new CollisionResult(isColliding, normal, depth);
}




/*
====================================================================================================
========================================= HELPER-METHODS ===========================================
====================================================================================================
*/

//Returns an array with array = [min, max]
private static float[] ProjectVertices(PVector[] vertices, PVector axis){

  float min = Float.MAX_VALUE;
  float max = Float.MIN_VALUE;

  for(PVector vertex : vertices) {

    float projectedVertex = PVector.dot(vertex, axis);

    if(projectedVertex < min) {
      min = projectedVertex;
    }

    if(projectedVertex > max) {
      max = projectedVertex;
    }

  }
  return new float[] {min, max};
}

private static float[] ProjectCircle(PVector center, PVector axis, float radius) {
  
  PVector directionAndRadius = PVector.mult(axis, radius);

  float min = PVector.dot(PVector.add(center, directionAndRadius), axis);
  float max = PVector.dot(PVector.sub(center, directionAndRadius), axis);
   
  if(min > max){
    float temp = min;
    min = max;
    max = temp;
  }

  return new float[] {min, max};
}

private static int FindClosestPointOnPolygon(PVector circleCenter, PVector[] transformedVertices) {
    int result = -1;
    float minDistanceSq = Float.MAX_VALUE;

    // Check for null or empty input
    if (transformedVertices == null || transformedVertices.length == 0 || circleCenter == null) {
        System.out.println("Input is null or empty");
        return result; // Return -1 to indicate error
    }

    for (int vertexIndex = 0; vertexIndex < transformedVertices.length; vertexIndex++) {
        // Additional check for null vertices, if necessary
        if (transformedVertices[vertexIndex] == null) {
            continue; // Skip this iteration
        }

        float distanceSq = PVector.sub(circleCenter, transformedVertices[vertexIndex]).magSq();

        if (distanceSq < minDistanceSq) {
            minDistanceSq = distanceSq;
            result = vertexIndex;
        }
    }

    return result;
}



public static CollisionResult PointSegmentDistance(PVector point, PVector lineSegmentStart, PVector lineSegmentEnd) {
    //PVector.sub(point, lineSegmentStart) is equivalent to pointToLineSegment

    PVector lineSegment = new PVector();
    lineSegment.set(PVector.sub(lineSegmentEnd, lineSegmentStart));

    float projection = PVector.dot(PVector.sub(point, lineSegmentStart), lineSegment);
    float lineSegmentLengthSquared = lineSegment.magSq();

    float distance = projection / lineSegmentLengthSquared;

    PVector closestPoint = new PVector();

    if (distance <= 0f) {
        closestPoint.set(lineSegmentStart);
    } else if (distance >= 1f) {
        closestPoint.set(lineSegmentEnd);
    } else {
        closestPoint.set(PVector.add(lineSegmentStart, PVector.mult(lineSegment, distance)));
    }

    float distanceSquared = PVector.sub(point, closestPoint).magSq();

    return physicsEngine.new CollisionResult(distanceSquared, closestPoint);
    }

/*
====================================================================================================
========================================= LINE INTERSECTION ========================================
====================================================================================================
*/

    public static PVector CalculateLineIntersection(PVector p1, PVector p2, PVector p3, PVector p4) {
        float denominator = (p1.x - p2.x) * (p3.y - p4.y) - (p1.y - p2.y) * (p3.x - p4.x);

        if (denominator == 0) {
            return null; // The lines are parallel
        }

        float intersectX = ((p1.x * p2.y - p1.y * p2.x) * (p3.x - p4.x) - (p1.x - p2.x) * (p3.x * p4.y - p3.y * p4.x)) / denominator;
        float intersectY = ((p1.x * p2.y - p1.y * p2.x) * (p3.y - p4.y) - (p1.y - p2.y) * (p3.x * p4.y - p3.y * p4.x)) / denominator;

        return new PVector(intersectX, intersectY);
    }

    public static boolean IsPointInLineSegment(PVector point, PVector lineStart, PVector lineEnd) {
        float lineLength = PVector.dist(lineStart, lineEnd);
        float totalDist = PVector.dist(lineStart, point) + PVector.dist(point, lineEnd);

        // Allow for a small error due to floating point precision
        float epsilon = 0.0001f;

        return Math.abs(totalDist - lineLength) < epsilon;
    }
} 
public class ComplexGravity implements ForceRegistry {

    private Rigidbody rigidbody;



    public ComplexGravity(Rigidbody rigidbody) {
        this.rigidbody = rigidbody;
    }


    @Override
    public PVector getForce(Rigidbody rigidbody, PVector position) {
        PVector force = new PVector(0, 0);
        for(Rigidbody otherRigidbody : rigidbodyList) {
            force.add(PVector.mult(PVector.sub(otherRigidbody.getPosition(), position), otherRigidbody.getMass()));
        }
        return force;
    }

    @Override
    public void draw() {
        //Do nothing
    }
    
    @Override
    public PVector getApplicationPoint(Rigidbody rigidbody, PVector position) {
        return position;
    }

    @Override
    public Rigidbody getRigidbodyA() {
        return this.rigidbody;
    }

    @Override
    public Rigidbody getRigidbodyB() {
        return this.rigidbody;
    }
}

public interface ForceRegistry {
    public PVector getForce(Rigidbody rigidbody, PVector position);
    public void draw();
    public PVector getApplicationPoint(Rigidbody rigidbody, PVector position);
    public Rigidbody getRigidbodyA();
    public Rigidbody getRigidbodyB();
}

public enum ForceType {
  SPRING,
  ROD,
  MOTOR
}
public class FrameTimeUtility {

    private int simulationStartTime;
    private int currentFrameTime;
    private int lastFrameTime;


    private long totalWorldStepTimeStart;
    private long subWorldStepTimeStart;

    private long totalWorldStepTime;
    private long subWorldStepTime;

    private int totalBodyCount;
    private double systemTime;

    private int totalSampleCount;
    private int subSampleCount;

    private String totalStepTime;
    private String subStepTime;
    private int bodyCount;

    private String totalStepTimeUnit;
    private String subStepTimeUnit;

    public float DT = 0.0f;
    private float fps;
    private float displayTimeStep;



    public void displayTimings() {
        if(!DRAW_STATS) {
            return;
        }
        
        if(millis() - systemTime >= 200) {
            this.totalStepTime = calculateAverageTime(this.totalWorldStepTime, this.totalSampleCount);
            this.subStepTime = calculateAverageTime(this.subWorldStepTime, this.subSampleCount);
            this.bodyCount = rigidbodyList.size();

            //updates the counter and resets values
            this.totalWorldStepTime = 0;
            this.subWorldStepTime = 0;
            this.totalSampleCount = 0;
            this.subSampleCount = 0;
            this.systemTime = millis();

            this.fps = frameRate;
            this.displayTimeStep = this.DT;
        }

        textFont(UI_Constants.INTER_REGULAR);
        textSize(15);
        textAlign(LEFT, CENTER);
        stroke(255);
        fill(255);
        text("Total Step Time: " + totalStepTime, 10, 40);
        text("Sub Step Time: " + subStepTime, 10, 60);
        text("Body Count: " + bodyCount, 10, 80);
        text("FPS: " + fps, 10, 100);
        text("dt: " + displayTimeStep, 10, 120);
        text("Simulation Length: " + (float)(millis() - this.simulationStartTime) / 1000, 10, 140);
    }


    public void startTotalWorldStepTime() {
        if(!DRAW_STATS) {
            return;
        }
        this.totalWorldStepTimeStart = System.nanoTime();
    }
    public void updateTotalWorldStepTime() {
        if(!DRAW_STATS) {
            return;
        }
        this.totalSampleCount++;
        this.totalWorldStepTime += System.nanoTime() - totalWorldStepTimeStart;
    }
    
    public void startSubWorldStepTime() {
        if(!DRAW_STATS) {
            return;
        }
        this.subWorldStepTimeStart = System.nanoTime();
    }

    public void updateSubWorldStepTime() {
        if(!DRAW_STATS) {
            return;
        }
        this.subSampleCount++;
        this.subWorldStepTime += System.nanoTime() - subWorldStepTimeStart;
    }

    private String calculateAverageTime(long totalTime, int sampleCount) {
        double averageTime = ((double)totalTime) / sampleCount;
        String timeUnit = "ns";

        if(averageTime > 1000) {
            averageTime /= 1000;
            timeUnit = "Î¼s";
        }
        if (averageTime > 1000) {
            averageTime /= 1000;
            timeUnit = "ms";
        }

        averageTime = new BigDecimal(averageTime).setScale(3, RoundingMode.HALF_UP).doubleValue();
        return averageTime + timeUnit;
    }

    public void init() {
        this.simulationStartTime = millis();
        this.lastFrameTime = millis();
    }

    public void calculateFrameTime() {
        this.currentFrameTime = millis();
        this.DT = (float)(this.currentFrameTime - this.lastFrameTime) / 1000.0F;
    }

    public void updateFrameTime() {
        this.lastFrameTime = this.currentFrameTime;
    }
}
public class Gravity implements ForceRegistry {
  private final Rigidbody rigidbody;

  public Gravity(Rigidbody rigidbody) {
    this.rigidbody = rigidbody;
  }

  @Override
  public PVector getForce(Rigidbody rigidbody, PVector position) {
    return GRAVITY_VECTOR.copy();
  }

  @Override
  public void draw() {
    // Do nothing
  }

    @Override
    public PVector getApplicationPoint(Rigidbody rigidbody, PVector position) {
      return rigidbody.getPosition();
    }
    @Override
    public Rigidbody getRigidbodyA() {
      return this.rigidbody;
    }
    @Override
    public Rigidbody getRigidbodyB(){
      return this.rigidbody;
    }
}
public class KeyHandler {

    private boolean[] keyDownCache = new boolean[256];




/*-------------------------------------- Rigidbody Tab -------------------------------------------*/

/*
====================================================================================================
====================================== Key & Mouse Listeners =======================================
====================================================================================================
*/
    public void onKeyPressed(int keyCode) {
        if(keyCode < keyDownCache.length) {
            keyDownCache[keyCode] = true;
        }
    }

    public void onKeyReleased(int keyCode) {
        if(keyCode < keyDownCache.length) {
            keyDownCache[keyCode] = false;
        }
    }

    public boolean isKeyDown(int keyCode) {
        if(keyCode < keyDownCache.length) {
            return keyDownCache[keyCode];
        }
        return false;
    }

    public boolean isKeyUp(int keyCode) {
        if(keyCode < keyDownCache.length) {
            return !keyDownCache[keyCode];
        }
        return false;
    }

/*
====================================================================================================
====================================== Getters and Setters =========================================
====================================================================================================
*/    
}
@Override
public void exit() {
    java.lang.System.exit(0);
}

public void keyPressed() {
    KeyHandler.onKeyPressed(keyCode);


    UI_Manager.onKeyPress(keyCode);
    UI_Manager.getPropertiesEditorWindow().onKeyPress(keyCode);
    
    if(UI_Manager.getTabBar().getActiveTabID() == 2) {
        if(IS_TEXTFIELD_ACTIVE && UI_Manager.getCreationWindow().getTextField() != null) {
            UI_Manager.getCreationWindow().getTextField().keyPress(key, keyCode);
            return;
        } else if (IS_TEXTFIELD_ACTIVE && UI_Manager.getCreationWindow().getFileButtonToRenameTextField() != null) {
            UI_Manager.getCreationWindow().getFileButtonToRenameTextField().keyPress(key, keyCode);
            return;
        }
    }

    if(KeyHandler.isKeyDown(KeyEvent.VK_Q)) {
        UI_Manager.getTabBar().onQPressed();
        return;
    }
    
    if(KeyHandler.isKeyDown(KeyEvent.VK_E)) {
        UI_Manager.getTabBar().onEPressed();
        return;
    }

    if(KeyHandler.isKeyDown(KeyEvent.VK_1)) {
        UI_Manager.getHotBar().setActiveSlotID(0);
        UI_Manager.getTabBar().setActiveTabID(1);
        return;
    }

    if(KeyHandler.isKeyDown(KeyEvent.VK_2)) {
        UI_Manager.getHotBar().setActiveSlotID(1);
        UI_Manager.getTabBar().setActiveTabID(1);
        return;
    }

    if(KeyHandler.isKeyDown(KeyEvent.VK_3)) {
        UI_Manager.getHotBar().setActiveSlotID(2);
        UI_Manager.getTabBar().setActiveTabID(1);
        return;
    }

    if(KeyHandler.isKeyDown(KeyEvent.VK_4)) {
        UI_Manager.getHotBar().setActiveSlotID(3);
        UI_Manager.getTabBar().setActiveTabID(1);
        return;
    }

    if(KeyHandler.isKeyDown(KeyEvent.VK_5)) {
        UI_Manager.getHotBar().setActiveSlotID(4);
        UI_Manager.getTabBar().setActiveTabID(1);
        return;
    }


    if(KeyHandler.isKeyDown(KeyEvent.VK_6)) {
        UI_Manager.getHotBar().setActiveSlotID(5);
        UI_Manager.getTabBar().setActiveTabID(1);
        return;
    }

    if(KeyHandler.isKeyDown(KeyEvent.VK_7)) {
        UI_Manager.getHotBar().setActiveSlotID(6);
        UI_Manager.getTabBar().setActiveTabID(1);
        return;
    }

    if(keyCode == ESC) {
        exit();
        return;
    }
    
    if(keyCode == ENTER) {
        Mouse.getMouseObjectResults().clear();
        return;
    }

    if(keyCode == TAB) {
        Mouse.setSnappingEnabled(!Mouse.getSnappingEnabled());
        return;
    }

    if(key == ' ') {
        if(!IS_PAUSED_LOCK) {
            IS_PAUSED = !IS_PAUSED;
        }
                UI_Manager.getPropertiesEditorWindow().PAUSE_STATE_ON_OPEN = IS_PAUSED;
        return;
    }

    if(key == 'r') {
        rigidbodyList.clear();
        ALL_FORCES_ARRAYLIST.clear();
        softbodyList.clear();
        return;
    }
}

public void keyReleased() {  
    KeyHandler.onKeyReleased(keyCode);

    if(!KeyHandler.isKeyDown(KeyEvent.VK_Q)) {
        UI_Manager.getTabBar().onQReleased();
    }

    if(!KeyHandler.isKeyDown(KeyEvent.VK_E)) {
        UI_Manager.getTabBar().onEReleased();
    }
}

// import java.util.*;



















public class Motor implements ForceRegistry {

    private final Rigidbody rigidbody;
    private PVector localAnchor;

    private float targetAngularVelocity;

    private boolean drawMotorForce;
    private boolean drawMotor;


    public Motor(Rigidbody rigidbody) {
        this.rigidbody = rigidbody;
        this.localAnchor = new PVector(this.rigidbody.getRadius(), 0);
        this.drawMotorForce = true;
    }

    public Motor(Rigidbody rigidbody, float targetAngularVelocity) {
        this.rigidbody = rigidbody;
        this.targetAngularVelocity = targetAngularVelocity;
        this.localAnchor = new PVector(this.rigidbody.getRadius(), 0);
        this.drawMotorForce = true;
    }


@Override
public PVector getForce(Rigidbody rigidbody, PVector position) {

    if(this.rigidbody != rigidbody) {
        throw new IllegalArgumentException("Rigidbody is not the same as the one this force is applied to");
    }

    this.rigidbody.setAngularVelocity(targetAngularVelocity);
    
    return new PVector(0, 0);
    
    
}

@Override
public void draw() {

    if(!drawMotorForce) {
        return;
    }
    if(PhysEngMath.Equals(this.targetAngularVelocity, 0)) {
        return;
    }
    PVector position = this.rigidbody.getPosition();
    boolean isClockwise = targetAngularVelocity > 0;

    float size = this.rigidbody.getRadius() * 0.5f;
    float arrowSize = size * 0.15f;
    float startAngle = 0;
    float endAngle = 3 * PI/2;// Change this to control the curvature of the arrow

    // Draw the curved part of the arrow
    pushMatrix();
    translate(position.x, position.y);
    rotate(this.rigidbody.getAngle() + PI/6);
    noFill();
    stroke(255, 0, 0); // Red color
    arc(0, 0, size, size, startAngle, endAngle);

    // Calculate the start and end of the arc
    float startX =  size * cos(startAngle)/2;
    float startY = size * sin(startAngle)/2;
    float endX = size * cos(endAngle)/2;
    float endY = size * sin(endAngle)/2;

    fill(255, 0, 0); // Red color
    noStroke();
    
    if(isClockwise) {
        triangle(endX, endY-arrowSize, endX, endY+arrowSize, endX+arrowSize*2, endY);
    } else {
        triangle(startX-arrowSize, startY, startX + arrowSize, startY, startX, startY - 2 * arrowSize);
    }

    popMatrix();

}
@Override
public PVector getApplicationPoint(Rigidbody rigidbody, PVector position) {
    return PhysEngMath.Transform(localAnchor, position, rigidbody.getAngle());
}


/*
====================================================================================================
======================================== Getters and Setters ========================================
====================================================================================================
*/
    public void setTargetAngularVelocity(float targetAngularVelocity) {
        this.targetAngularVelocity = targetAngularVelocity;
    }

    public void setLocalAnchor(PVector localAnchor) {
        this.localAnchor = localAnchor;
    } 
    public void setDrawMotor(boolean drawMotor) {
        this.drawMotor = drawMotor;
    }

    public boolean getDrawMotor() {
        return drawMotor;
    }


    public boolean getDrawMotorForce() {
        return drawMotorForce;
    }

    public void setDrawMotorForce(boolean drawMotorForce) {
        this.drawMotorForce = drawMotorForce;
    }

    public float getTargetAngularVelocity() {
        return targetAngularVelocity;
    }

    public PVector getLocalAnchor() {
        return localAnchor;
    }
    @Override
    public Rigidbody getRigidbodyA(){
        return this.rigidbody;
    }
    @Override
    public Rigidbody getRigidbodyB(){
        return this.rigidbody;
    }



}

public void mousePressed(){
    if(mouseButton == LEFT){
        Mouse.updateMouseDownCoordinates();
        UI_Manager.onMousePress();
        return;
    }
}

public void mouseReleased() {
    if(mouseButton == LEFT) {
        Mouse.updateMouseUpCoordinates();
        UI_Manager.onMouseRelease();
        return;
    }

}

public void mouseClicked() {
    if(mouseButton == LEFT) {
        UI_Manager.onMouseClick();
        return;
    }
} 

public void mouseWheel(MouseEvent event) {
    if(UI_Manager.getIsOverWindows()) {
        return;
    }
    
    float e = -event.getCount();
    Camera.zoom(pow(SCROLL_SENSITIVITY, e), mouseX, mouseY);
}

public void mouseDragged() {
    if(!UI_Manager.getIsOverWindows() && mouseButton == RIGHT) {
        Camera.move(pmouseX - mouseX, pmouseY - mouseY);
        return;
    }

    if(mouseButton == LEFT) {
        UI_Manager.onMouseDrag();
        return;
    }
}

public void mouseMoved() {
    //editor.dragSnap();
}


public class MouseObject {

	private ArrayList<MouseObjectResult> interactionResults = new ArrayList<MouseObjectResult>();

	private PVector mouseCoordinates = new PVector();
    private PVector previousMouseCoordinates = new PVector();


    private Rigidbody initialSelectedRigidbody = null;
    private float easing = 0.175f;
    private boolean mLeft, mRight, mCenter;
    private boolean isMouseDown = false;
    private boolean mouseDownLeft = false;
    private boolean mouseDownRight = false;
    private PVector mouseDownCoordinates = new PVector();
    private boolean isMouseUp = false;
    private PVector mouseUpCoordinates = new PVector();


    private boolean isMouseOverUI = false;
    private boolean wasMousePressedOverWindow = false;

	private Rigidbody currentRigidbodyUnderMouse;

  	private boolean showCursorTrail = true;
  	private ArrayList<PVector> cursorTrailArrayList = new ArrayList<PVector>();


    private boolean snappingEnabled = true;


	public MouseObject() {
        //do nothing
	}


    public void updateMouse() {
        this.updateMouseCoordinates();
        this.currentRigidbodyUnderMouse = this.getRigidbodyUnderMouse();
    }

	public Rigidbody getRigidbodyUnderMouse() {
        PVector mouseCoordinates = Camera.screenToWorld();
    	for (Rigidbody rigidbody : rigidbodyList) {
            if(this.initialSelectedRigidbody == rigidbody) {
                continue;
            }

            if(!Collisions.IntersectAABBWithPoint(rigidbody.GetAABB(), mouseCoordinates)) {
           		continue;
            }
            if(rigidbody.contains(mouseCoordinates.x, mouseCoordinates.y)) {
                if(this.initialSelectedRigidbody != null) {
                    rigidbodyList.remove(this.initialSelectedRigidbody);
                    rigidbodyList.add(0, this.initialSelectedRigidbody);
                }
           		return rigidbody;
            }
    	}

    	return null;
	}	

	public void addSelectedRigidbody() {
		if(this.interactionResults.size() > 2) {
            this.interactionResults.clear();
            this.initialSelectedRigidbody = null;
		}

		this.interactionResults.add(new MouseObjectResult(this.currentRigidbodyUnderMouse, this.mouseCoordinates));
        this.initialSelectedRigidbody = this.currentRigidbodyUnderMouse;
        
        if(this.interactionResults.size() == 2) {
            if(this.interactionResults.get(0).getSelectedRigidbody() == null && this.interactionResults.get(1).getSelectedRigidbody() == null) {
                this.interactionResults.clear();
                this.initialSelectedRigidbody = null;
            }
        }

	}

	public void updateMouseCoordinates() {
        PVector snappedMouseCoordinates = PhysEngMath.WorldSnapController(this, this.currentRigidbodyUnderMouse, Camera.screenToWorld());
        this.previousMouseCoordinates.set(this.mouseCoordinates);
        this.mouseCoordinates.x = lerp(this.mouseCoordinates.x, snappedMouseCoordinates.x, this.easing);
        this.mouseCoordinates.y = lerp(this.mouseCoordinates.y, snappedMouseCoordinates.y, this.easing);
	}

    public void updateMouseDownCoordinates() {
        this.isMouseDown = true;
        this.isMouseUp = false;

        if(mouseButton == LEFT) {
            this.mouseDownLeft = true;
        }
        this.mouseDownCoordinates.set(PhysEngMath.WorldSnapController(this, this.currentRigidbodyUnderMouse, Camera.screenToWorld()));
    }

    public void updateMouseUpCoordinates() {
        this.isMouseUp = true;
        this.isMouseDown = false;
        this.addSelectedRigidbody();

        if(this.mouseDownLeft) {
            this.mouseDownLeft = false;
        }

        this.mouseUpCoordinates.set(PhysEngMath.WorldSnapController(this, this.currentRigidbodyUnderMouse, Camera.screenToWorld()));
    }
    
    public void drawCursor() {
        if(!showCursorTrail) {
            return;
        }
        fill(255, 255, 255, 121);
        stroke(0, 0, 0, 180);
        strokeWeight(0.025f);

        ellipse(Camera.screenToWorld().x, Camera.screenToWorld().y, 0.175f, 0.175f);
        fill(255, 0, 0);
        strokeWeight(0.1f);
        stroke(255, 0, 0);
        ellipse(this.mouseCoordinates.x, this.mouseCoordinates.y, 0.1f, 0.1f);


        if(cursorTrailArrayList.size() < 20) {
            cursorTrailArrayList.add(new PVector(mouseCoordinates.x, mouseCoordinates.y));
        } else {
            cursorTrailArrayList.add(cursorTrailArrayList.get(0).set(this.mouseCoordinates.x, this.mouseCoordinates.y));
            cursorTrailArrayList.remove(0);
        }
        noFill();
        beginShape();
            // Add the first point twice to guide the beginning of the curve
            curveVertex(cursorTrailArrayList.get(0).x, cursorTrailArrayList.get(0).y);
            for(PVector cursorTrailVertex : cursorTrailArrayList) {
                curveVertex(cursorTrailVertex.x, cursorTrailVertex.y);
            }
            // Add the last point twice to guide the end of the curve
            curveVertex(cursorTrailArrayList.get(cursorTrailArrayList.size() - 1).x, cursorTrailArrayList.get(cursorTrailArrayList.size() - 1).y);
        endShape();
    }

    public void setMouseCoordinates(PVector mouseCoordinates) {
        this.mouseCoordinates.set(mouseCoordinates);
    }

	public PVector getMouseCoordinates() {
		return this.mouseCoordinates;
	}

    public PVector getPreviousMouseCoordinates() {
        return this.previousMouseCoordinates;
    }
    
    public boolean getIsMouseDown() {
        return this.isMouseDown;
    }

    public PVector getMouseDownCoordinates() {
        return this.mouseDownCoordinates;
    }

    public boolean getIsMouseUp() {
        return this.isMouseUp;
    }
    public PVector getMouseUpCoordinates() {
        return this.mouseUpCoordinates;
    }

    public Rigidbody getCurrentRigidbodyUnderMouse() {
        return this.currentRigidbodyUnderMouse;
    }

    public ArrayList<MouseObjectResult> getMouseObjectResults() {
        return this.interactionResults;
    }

    public void clearMouseObjectResults() {
        this.interactionResults.clear();
    }
    
    public void setSnappingEnabled(boolean snappingEnabled) {
        this.snappingEnabled = snappingEnabled;
    }

    public boolean getSnappingEnabled() {
        return this.snappingEnabled;
    }

    public boolean getIsMouseDownLeft() {
        return this.mouseDownLeft;
    }
}
public class MouseObjectResult {
	private Rigidbody SelectedRigidbody;
	private PVector SelectedRigidbodyPosition = new PVector();
	private PVector Coordinate = new PVector();
    private PVector LocalCoordinate = new PVector();


	public MouseObjectResult(Rigidbody selectedRigidbody, PVector coordinate) {

		this.SelectedRigidbody = selectedRigidbody;
        
		if(this.SelectedRigidbody != null) {
			this.SelectedRigidbodyPosition.set(selectedRigidbody.getPosition());
            //this.LocalCoordinate.set(PVector.sub(coordinate, this.SelectedRigidbody.getPosition()));
            this.LocalCoordinate.set(PhysEngMath.Transform(PVector.sub(coordinate, this.SelectedRigidbodyPosition), -this.SelectedRigidbody.getAngle()));
		}
		this.Coordinate.set(coordinate);
	}


	public Rigidbody getSelectedRigidbody() {
		return this.SelectedRigidbody;
	}

	public PVector getWorldCoordinate() {
		return this.Coordinate.copy();
	}

    public PVector getTransformedLocalCoordinate() {
        if(this.SelectedRigidbody == null) {
            return this.Coordinate.copy();
        }
        
        return this.LocalCoordinate.copy();
    }

	public String toString() {
		return "MouseObjectResult: " + SelectedRigidbody + ", " + Coordinate;
	}


}

public static class PhysEngMath {

    private static final PVector emptyVector = new PVector(0, 0);
    
    //Precision for float comparison, equal to 0.00005 meters
    public static final float precision = 0.0001f;

    public static float Clamp(float value, float min, float max) {
        if (min == max) {
            return min;
        } else if (min > max) {
            throw new IllegalArgumentException("min must be less than max");
        } else if (value < min) {
            return min;
        } else if (value > max) {
            return max;
        } else {
            return value;
        }
  }


public static float fastInverseSq(PVector vector) {
    return fastInverseSq(vector.x * vector.x + vector.y * vector.y);
}


public static float fastInverseSq (float number) {
    float x = number;
    float xhalf = 0.5f * x;
    int i = Float.floatToIntBits(x);
    i = 0x5f3759df - (i >> 1);
    x = Float.intBitsToFloat(i);
    for (int it = 0; it < 2; it++) { // Reduced iterations for float
        x = x * (1.5f - xhalf * x * x);
    }
    x *= number;
    return x;
}

public static PVector[] OrderVerticesClockwise(PVector[] vertices) {
  // Calculate the centroid
  PVector centroid = new PVector(0, 0);
  for (PVector v : vertices) {
    centroid.add(v);
  }
  centroid.div(vertices.length);

  // Calculate angle for each vertex
  float[] angles = new float[vertices.length];
  for (int i = 0; i < vertices.length; i++) {
    angles[i] = PVector.sub(vertices[i], centroid).heading();
  }

  // Sort vertices based on angles
  for (int i = 0; i < angles.length; i++) {
    for (int j = i + 1; j < angles.length; j++) {
      if (angles[i] > angles[j]) {
        // Swap angles
        float tempAngle = angles[i];
        angles[i] = angles[j];
        angles[j] = tempAngle;
        // Swap vertices
        PVector tempVertex = vertices[i];
        vertices[i] = vertices[j];
        vertices[j] = tempVertex;
      }
    }
  }

  // Return ordered vertices
  return vertices;
}

public static PVector MouseVelocityCalculationAndClamp(PVector initial, PVector current, float min, float max) {

    float dx = current.x - initial.x;
    float dy = current.y - initial.y;

    float magnitude = fastInverseSq(dx * dx + dy * dy);  

    if (Equals(magnitude, 0f)) { // To avoid division by zero
        dx = 0f;
        dy = 0f;
    } else {
        dx /= magnitude;
        dy /= magnitude;
    }

    magnitude = constrain(magnitude, min, max);

    dx *= magnitude;
    dy *= magnitude;

    return new PVector(dx, dy);
}


public static PVector SquareVelocity(PVector vector) {
    float x = vector.x;
    float y = vector.y;

    float magSq = x * x + y * y;
    float mag = fastInverseSq(magSq);

    if(Equals(mag, 0f)) {
        x = 0f;
        y = 0f;
    } else {
        x /= mag;
        y /= mag;
    }

    return new PVector(x * magSq, y * magSq);
}

public static PVector Clamp(PVector vector, float min, float max) {

    float dx = vector.x;
    float dy = vector.y;

    float mag = fastInverseSq(dx * dx + dy * dy);

    if (Equals(mag, 0f)) { // To avoid division by zero
        dx = 0f;
        dy = 0f;
    } else {
        dx /= mag;
        dy /= mag;
    }

    mag = constrain(mag, min, max);

    dx *= mag;
    dy *= mag;

    return new PVector(dx, dy);
  }

  public static int Clamp(int value, int min, int max) {
    if (min == max) {
      return min;
    } else if (min > max) {
      throw new IllegalArgumentException("min must be less than max");
    } else if (value < min) {
      return min;
    } else if (value > max) {
      return max;
    } else {
      return value;
    }
  }
  

  public static PVector Transform(PVector vertex, float angle) {
    float sin = sin(angle);
    float cos = cos(angle);

    return new PVector(vertex.x * cos - vertex.y * sin, vertex.x * sin + vertex.y * cos);
  }
  
  public static PVector Transform(PVector vertex, PVector position, float angle){
    float sin = sin(angle);
    float cos = cos(angle);
    
    return new PVector(vertex.x * cos - vertex.y * sin + position.x, vertex.x * sin + vertex.y * cos + position.y);
  }

  public static PVector ReverseTransform(PVector vertex, PVector position, float angle){
  PVector translatedVertex = new PVector(vertex.x + position.x, vertex.y + position.y);


  float sin = sin(angle); 
  float cos = cos(angle);

  // Rotate the translated vertex
  return new PVector(
    translatedVertex.x * cos - translatedVertex.y * sin, // Rotate x
    translatedVertex.x * sin + translatedVertex.y * cos  // Rotate y
  );
}

  
  //Overloaded method for Transform
    public static PVector Transform(float x, float y, float angle) {
        float sin = sin(angle);
        float cos = cos(angle);
    
        return new PVector(x * cos - y * sin + x, x * sin + y * cos + y);
  }

  

  public static PVector zeroTransform = Transform(0, 0, 0);



    public static boolean Equals(float a, float b) {
        return Math.abs(a - b) < precision;
    }

public static boolean Equals(PVector a, PVector b) {
    return PVector.sub(a, b).magSq() < precision * precision; //magSq is faster than mag
  }

    

public static PVector SnapController(MouseObject Mouse, Rigidbody rigidbody, PVector point) {
    if(rigidbody == null) {
        return point;
    }
    
    if(Mouse.getSnappingEnabled()) {
        if(rigidbody.getShapeType() == ShapeType.BOX) {
            PVector[] vertices = rigidbody.GetTransformedVertices();

            for(int i = 0; i < vertices.length; i++) {
                if(PVector.sub(vertices[i], point).magSq() < VERTEX_SNAP_RADIUS) {
                    return PVector.sub(vertices[i], rigidbody.getPosition());
                }
            }

            PVector closestPoint = new PVector();
            float minDistanceSq = Float.MAX_VALUE;

            for (int i = 0; i < vertices.length; i++) {
                PVector start = vertices[i];
                PVector end = vertices[(i + 1) % vertices.length]; // Loop back to the first vertex

                PVector closestOnEdge = getClosestPointOnLine(start, end, point);
                float distanceSq = PVector.dist(closestOnEdge, point);

                if (distanceSq < minDistanceSq) {
                    minDistanceSq = distanceSq;
                    closestPoint = closestOnEdge;
                }
            }

            if(PVector.sub(closestPoint, rigidbody.getPosition()).magSq() / 2 > PVector.sub(point, rigidbody.getPosition()).magSq()) {
                return new PVector();
            } else {
                return PVector.sub(closestPoint, rigidbody.getPosition());
            }

        } else if(rigidbody.getShapeType() == ShapeType.CIRCLE) {
            if(PVector.sub(point, rigidbody.getPosition()).magSq() < rigidbody.getRadius() / 2) {
                return new PVector();
            } else {
                return point.sub(rigidbody.getPosition()).normalize().mult(rigidbody.getRadius()).copy();
            }
        } else {
            throw new IllegalArgumentException("Rigidbody is not a circle or box");
        }
    } else {
        return PVector.sub(point, rigidbody.getPosition());
    }
}

public static PVector WorldSnapController(MouseObject Mouse, Rigidbody rigidbody, PVector point) {
    if(rigidbody == null) {
        return point;
    }

    if(Mouse.getSnappingEnabled()) {
        if(rigidbody.getShapeType() == ShapeType.BOX) {
            PVector[] vertices = rigidbody.GetTransformedVertices();

            for(int i = 0; i < vertices.length; i++) {
                if(PVector.sub(vertices[i], point).magSq() < VERTEX_SNAP_RADIUS) {
                    return vertices[i];
                }
            }

            PVector closestPoint = new PVector();
            float minDistanceSq = Float.MAX_VALUE;

            for (int i = 0; i < vertices.length; i++) {
                PVector start = vertices[i];
                PVector end = vertices[(i + 1) % vertices.length]; // Loop back to the first vertex

                PVector closestOnEdge = getClosestPointOnLine(start, end, point);
                float distanceSq = PVector.dist(closestOnEdge, point);

                if (distanceSq < minDistanceSq) {
                    minDistanceSq = distanceSq;
                    closestPoint = closestOnEdge;
                }
            }

            if(PVector.sub(closestPoint, rigidbody.getPosition()).magSq() / 2 > PVector.sub(point, rigidbody.getPosition()).magSq()) {
                return rigidbody.getPosition();
            } else {
                return closestPoint;
            }

        } else if(rigidbody.getShapeType() == ShapeType.CIRCLE) {
            if(PVector.sub(point, rigidbody.getPosition()).magSq() < rigidbody.getRadius()/2) {
                return rigidbody.getPosition();
            } else {
                return point.sub(rigidbody.getPosition()).normalize().mult(rigidbody.getRadius()).add(rigidbody.getPosition());
            }
        } else {
            throw new IllegalArgumentException("Rigidbody is not a circle or box");
        }
    } else {
        return point;
    }
}


    public static PVector[] reverseVertices(PVector[] vertices) {
        PVector[] reversedVertices = new PVector[vertices.length];

        for (int i = 0; i < vertices.length; i++) {
            reversedVertices[i] = vertices[vertices.length - 1 - i];
        }
        return reversedVertices;
    }

    private static PVector getClosestPointOnLine(PVector start, PVector end, PVector point) {
        PVector line = PVector.sub(end, start);
        float len = line.mag();
        line.normalize();
        PVector v = PVector.sub(point, start);
        float d = PVector.dot(v, line);
        d = constrain(d, 0, len);
        return PVector.add(start, line.mult(d));
    }

}

public void settings() {
    String os = System.getProperty("os.name").toLowerCase();
    UI_QualitySettings qualitySettings = new UI_QualitySettings(true);

    if(os.contains("mac")) {
        size(displayWidth, displayHeight - 125, FX2D);
        pixelDensity(qualitySettings.getPixelDensity());
    } else if(os.contains("windows")) {
        fullScreen(FX2D);
        pixelDensity(qualitySettings.getPixelDensity());
    } else {
        throw new RuntimeException("OS not supported");
    }
}
    

/*
====================================================================================================
===================================  PHYSICS ENGINE OBJECTS  =======================================
====================================================================================================
*/
/*------------------------------------ NEVER CHANGE THIS -----------------------------------------*/

public static boolean IS_TEXTFIELD_ACTIVE = false;

public static boolean IS_PAUSED = false;
public static boolean IS_PAUSED_LOCK = false;

public static ArrayList<PVector> pointsOfContactList = new ArrayList<PVector>();

public static ArrayList<Rigidbody> rigidbodyList = new ArrayList<Rigidbody>();
public static ArrayList<Softbody> softbodyList = new ArrayList<Softbody>();

public ArrayList<ArrayList<Integer>> collisionPairs = new ArrayList<ArrayList<Integer>>();
    

public PVector[] contactList = new PVector[0];
public PVector[] impulseList = new PVector[2];
public PVector[] raList = new PVector[2]; 
public PVector[] rbList = new PVector[2];
public PVector[] frictionImpulseList = new PVector[2];
public float[] jList = new float[2];

/*
====================================================================================================
===================================  PHYSICS ENGINE CONSTANTS  =====================================
====================================================================================================
*/

public final float MIN_BODY_AREA = 0.001f * 0.001f; // m^2
public final float MAX_BODY_AREA = 300f * 300f; // m^2

public final float MIN_BODY_DENSITY = 0.01f; //g/cm^3
public final float MAX_BODY_DENSITY = 300.0f; //g/cm^3

public final float MIN_BODY_WIDTH = 0.01f; // m
public final float MAX_BODY_WIDTH = 300; // m

public final float MIN_BODY_HEIGHT = 0.01f; // m
public final float MAX_BODY_HEIGHT = 300.0f; // m

public final float MIN_BODY_RADIUS = 0.01f;
public final float MAX_BODY_RADIUS = 300.0f;

public final float MIN_MOUSE_VELOCITY_MAG = 0.0f;
public final float MAX_MOUSE_VELOCITY_MAG = 15.0f;

public final int MIN_ITERATIONS = 1;
public final int MAX_ITERATIONS = 1024;

public PVector BACKGROUND_COLOUR = new PVector(16, 18, 19);

public static int SUB_STEP_COUNT = 128;
public float SCROLL_SENSITIVITY = 1.1f;


public boolean DRAW_CONTACT_POINTS = false;
public boolean DRAW_AABBS = false;
public boolean DRAW_STATS = false;
public boolean TEXT_SMOOTHING = false;


public PVector GRAVITY_VECTOR = new PVector(0, 9.81f);
public float GRAVITY_MAG = 9.81f;

public float COEFFICIENT_OF_STATIC_FRICTION = 0.8f;
public float COEFFICIENT_OF_KINETIC_FRICTION = 0.3f;





public ArrayList<ForceRegistry> ALL_FORCES_ARRAYLIST = new ArrayList<ForceRegistry>();


public static float VERTEX_SNAP_RADIUS = 0.25f;



/*
====================================================================================================
===================================  PHYSICS ENGINE METHODS  =======================================
====================================================================================================
*/

//Iterations for substeps for each frame
public void Step(float dt, int totalIterations) {
    
    
    /*-----------------Related to Timekeeping Debugging -----------------*/
    FrameTimeUtility.startTotalWorldStepTime();
    /*-------------------------------------------------------------------*/
    
    
    totalIterations = PhysEngMath.Clamp(totalIterations, MIN_ITERATIONS, MAX_ITERATIONS);
    
    for (int currentIteration = 0; currentIteration < totalIterations; currentIteration++) {
        
        /*-----------------Related to Timekeeping Debugging -----------------*/
        FrameTimeUtility.startSubWorldStepTime();
        /*-------------------------------------------------------------------*/
        
        this.collisionPairs.clear();

        StepBodies(dt, totalIterations);
        BroadPhaseStep();
        NarrowPhaseStep();
        
        /*-----------------Related to Timekeeping Debugging -----------------*/
        FrameTimeUtility.updateSubWorldStepTime();
        /*-------------------------------------------------------------------*/
    }
    /*-----------------Related to Timekeeping Debugging -----------------*/
    FrameTimeUtility.updateTotalWorldStepTime();
    /*-------------------------------------------------------------------*/
}


/*
====================================================================================================
=================================== Collision Resolution Methods ===================================
====================================================================================================
*/

public void SeperateBodies(Rigidbody rigidbodyA, Rigidbody rigidbodyB, PVector minimumTranslationVector) {
    if(IS_PAUSED) {
        return;
    }

    if (rigidbodyA.getIsStatic() || rigidbodyA.getIsTranslationallyStatic()) {
        
        rigidbodyB.Move(minimumTranslationVector);
        
    } else if (rigidbodyB.getIsStatic() || rigidbodyB.getIsTranslationallyStatic()) {
        
        rigidbodyA.Move(PVector.mult(minimumTranslationVector, -1.0f));
        
    } else {
        
        rigidbodyA.Move(PVector.mult(minimumTranslationVector, -0.5f));
        rigidbodyB.Move(PVector.mult(minimumTranslationVector, 0.5f));
    }
}


public void ResolveCollisionLinear(CollisionManifold collisionManifold) {
    
    Rigidbody rigidbodyA = collisionManifold.getRigidbodyA();
    Rigidbody rigidbodyB = collisionManifold.getRigidbodyB();
    PVector normal = collisionManifold.getNormal();
    float depth = collisionManifold.getDepth();
    
    
    PVector velocityA = rigidbodyA.getVelocity().copy();
    PVector velocityB = rigidbodyB.getVelocity().copy();
    float restitution = min(rigidbodyA.getRestitution(), rigidbodyB.getRestitution());
    PVector relativeVelocity = PVector.sub(velocityB, velocityA);
    
    if (PVector.dot(relativeVelocity, normal) > 0.0f) {
        return;
    }
    
    float invMassA = rigidbodyA.getInvMass();
    float invMassB = rigidbodyB.getInvMass();
    
    float j = -(1f + restitution) * PVector.dot(relativeVelocity, normal) / (invMassA + invMassB);
    
    PVector impulse = PVector.mult(normal, j);
    
    
    velocityA = PVector.add(velocityA, PVector.mult(PVector.mult(impulse, -1), invMassA));
    velocityB = PVector.add(velocityB, PVector.mult(impulse, invMassB));
    
    rigidbodyA.setVelocity(velocityA);
    rigidbodyB.setVelocity(velocityB);
    
}

public void ResolveCollisionRotation(CollisionManifold contact) {
    
    Rigidbody rigidbodyA = contact.getRigidbodyA();
    Rigidbody rigidbodyB = contact.getRigidbodyB();
    float invMassA = rigidbodyA.getInvMass();
    float invMassB = rigidbodyB.getInvMass();
    float invRotationalInertiaA = rigidbodyA.getInvRotationalInertia();
    float invRotationalInertiaB = rigidbodyB.getInvRotationalInertia();
    PVector normal = contact.getNormal();
    PVector velocityA = rigidbodyA.getVelocity();
    PVector velocityB = rigidbodyB.getVelocity();
    float angularVelocityA = rigidbodyA.getAngularVelocity();
    float angularVelocityB = rigidbodyB.getAngularVelocity();

    int contactCount = contact.getContactCount();
    contactList = contact.getPointsOfContact();

    float e = min(rigidbodyA.getRestitution(), rigidbodyB.getRestitution());


    for(int i = 0; i < contactCount; i++) {
        this.impulseList[i] = new PVector();
        this.raList[i] = new PVector();
        this.rbList[i] = new PVector();
    }

    for (int i = 0; i < contactCount; i++) {
        PVector ra = PVector.sub(contactList[i], rigidbodyA.getPosition());
        PVector rb = PVector.sub(contactList[i], rigidbodyB.getPosition());

        raList[i] = ra;
        rbList[i] = rb;

        PVector raPerp = new PVector(-ra.y, ra.x);
        PVector rbPerp = new PVector(-rb.y, rb.x);

        PVector angularLinearVelocityA = PVector.mult(raPerp, angularVelocityA);
        PVector angularLinearVelocityB = PVector.mult(rbPerp, angularVelocityB);

        PVector relativeVelocity = PVector.sub(PVector.add(velocityB, angularLinearVelocityB),
                                               PVector.add(velocityA, angularLinearVelocityA));

        float contactVelocityMag = relativeVelocity.dot(normal);

        if (contactVelocityMag > 0f) {
            continue;
        }

        float raPerpDotN = raPerp.dot(normal);
        float rbPerpDotN = rbPerp.dot(normal);

        float denom = (invMassA + invMassB) +
            ((raPerpDotN * raPerpDotN) * invRotationalInertiaA) +
            ((rbPerpDotN * rbPerpDotN) * invRotationalInertiaB);

        float j = -(1f + e) * contactVelocityMag;
        j /= denom;
        j /= (float)contactCount;

        PVector impulse = PVector.mult(normal, j);
        impulseList[i] = impulse;
    }

    for(int i = 0; i < contactCount; i++) {
        PVector impulse = impulseList[i];
        PVector ra = raList[i];
        PVector rb = rbList[i];

        //float raCrossImpulse = ra.x * impulse.y - ra.y * impulse.x;
        //float rbCrossImpulse = rb.x * impulse.y - rb.y * impulse.x;

        velocityA.add(PVector.mult(impulse, -invMassA));
        velocityB.add(PVector.mult(impulse, invMassB));

        angularVelocityA += ra.cross(impulse).z * -1 * invRotationalInertiaA;
        angularVelocityB += rb.cross(impulse).z * invRotationalInertiaB;

        rigidbodyA.setVelocity(velocityA);
        rigidbodyB.setVelocity(velocityB);
        rigidbodyA.setAngularVelocity(angularVelocityA);
        rigidbodyB.setAngularVelocity(angularVelocityB);
    }
}


public void ResolveCollisionRotationAndFriction(CollisionManifold contact) {

    Rigidbody rigidbodyA = contact.getRigidbodyA();
    Rigidbody rigidbodyB = contact.getRigidbodyB();

    float invMassA = rigidbodyA.getInvMass();
    float invMassB = rigidbodyB.getInvMass();

    float invRotationalInertiaA = rigidbodyA.getInvRotationalInertia();
    float invRotationalInertiaB = rigidbodyB.getInvRotationalInertia();

    PVector positionA = rigidbodyA.getPosition();
    PVector positionB = rigidbodyB.getPosition();

    PVector velocityA = rigidbodyA.getVelocity();
    PVector velocityB = rigidbodyB.getVelocity();

    float angularVelocityA = rigidbodyA.getAngularVelocity();
    float angularVelocityB = rigidbodyB.getAngularVelocity();

    PVector normal = contact.getNormal();
    int contactCount = contact.getContactCount();
    contactList = contact.getPointsOfContact();



    float restitution = min(rigidbodyA.getRestitution(), rigidbodyB.getRestitution());

    float coefficientOfStaticFriction = (rigidbodyA.getCoefficientOfStaticFriction()
                                        + rigidbodyB.getCoefficientOfStaticFriction()) * 0.5f;
    float coefficientOfKineticFriction = (rigidbodyA.getCoefficientOfKineticFriction()
                                         + rigidbodyB.getCoefficientOfKineticFriction()) * 0.5f;
    
    for(int i = 0; i < contactCount; i++) {
        this.impulseList[i] = new PVector();
        this.raList[i] = new PVector();
        this.rbList[i] = new PVector();
        this.frictionImpulseList[i] = new PVector();
        this.jList[i] = 0f;
    }

    for(int i = 0; i < contactCount; i++) {

        PVector ra = PVector.sub(contactList[i], positionA);
        PVector rb = PVector.sub(contactList[i], positionB);

        raList[i] = ra;
        rbList[i] = rb;

        PVector raPerp = new PVector(-ra.y, ra.x);
        PVector rbPerp = new PVector(-rb.y, rb.x);

        PVector angularLinearVelocityA = PVector.mult(raPerp, angularVelocityA);
        PVector angularLinearVelocityB = PVector.mult(rbPerp, angularVelocityB);

        PVector relativeVelocity = PVector.sub(PVector.add(velocityB, angularLinearVelocityB),
                                               PVector.add(velocityA, angularLinearVelocityA));

        float contactVelocityMagnitude = relativeVelocity.dot(normal);
        
        if(contactVelocityMagnitude > 0f) {
            continue;
        }
        
        float raPerpendicularDotN = raPerp.dot(normal);
        float rbPerpendicularDotN = rbPerp.dot(normal);

        float denom = invMassA + invMassB
                    + (raPerpendicularDotN * raPerpendicularDotN) * invRotationalInertiaA
                    + (rbPerpendicularDotN * rbPerpendicularDotN) * invRotationalInertiaB;

        float j = -(1f + restitution) * contactVelocityMagnitude;
        j /= denom;
        j /= (float)contactCount;

        jList[i] = j;

        PVector impulse = PVector.mult(normal, j);
        impulseList[i] = impulse;
    }

    for(int i = 0; i < contactCount; i++) {

        PVector impulse = impulseList[i];
        PVector ra = raList[i];
        PVector rb = rbList[i];

        velocityA.add(PVector.mult(impulse, -invMassA));
        velocityB.add(PVector.mult(impulse, invMassB));

        angularVelocityA += -ra.cross(impulse).z * invRotationalInertiaA;
        angularVelocityB += rb.cross(impulse).z * invRotationalInertiaB;

    }

    for(int i = 0; i < contactCount; i++) {
        PVector ra = PVector.sub(contactList[i], positionA);
        PVector rb = PVector.sub(contactList[i], positionB);

        raList[i] = ra;
        rbList[i] = rb;

        PVector raPerp = new PVector(-ra.y, ra.x);
        PVector rbPerp = new PVector(-rb.y, rb.x);

        PVector angularLinearVelocityA = PVector.mult(raPerp, angularVelocityA);
        PVector angularLinearVelocityB = PVector.mult(rbPerp, angularVelocityB);

        PVector relativeVelocity = PVector.sub(PVector.add(velocityB, angularLinearVelocityB),
                                               PVector.add(velocityA, angularLinearVelocityA));
        PVector tangent = PVector.sub(relativeVelocity, PVector.mult(normal, relativeVelocity.dot(normal)));

        if(PhysEngMath.Equals(tangent, new PVector())) {
            continue;
        } else {
            tangent.normalize();
        }

        float raPerpDotT = raPerp.dot(tangent);
        float rbPerpDotT = rb.dot(tangent);

        float denom = invMassA + invMassB
                    + (raPerpDotT * raPerpDotT) * invRotationalInertiaA
                    + (rbPerpDotT * rbPerpDotT) * invRotationalInertiaB;

        float jt = -relativeVelocity.dot(tangent);
        jt /= denom;
        jt /= (float)contactCount;

        PVector frictionImpulse;
        float j = jList[i];

        if(abs(jt) <= j * coefficientOfStaticFriction) {
            frictionImpulse = PVector.mult(tangent, jt);
        } else {
            frictionImpulse = PVector.mult(tangent, -j * coefficientOfKineticFriction);
        }
        
        this.frictionImpulseList[i] = frictionImpulse;
    }
        for(int i = 0; i < contactCount; i++) {
            PVector frictionImpulse = frictionImpulseList[i];
            PVector ra = raList[i];
            PVector rb = rbList[i];

            velocityA.add(PVector.mult(frictionImpulse, -invMassA));
            velocityB.add(PVector.mult(frictionImpulse, invMassB));

            angularVelocityA += -ra.cross(frictionImpulse).z * invRotationalInertiaA;
            angularVelocityB += rb.cross(frictionImpulse).z * invRotationalInertiaB;

            rigidbodyA.setVelocity(velocityA);
            rigidbodyB.setVelocity(velocityB);

            rigidbodyA.setAngularVelocity(angularVelocityA);
            rigidbodyB.setAngularVelocity(angularVelocityB);
        }

    }

/*
====================================================================================================
============================ Broad & Narrow - Phase Collision Methods ==============================
====================================================================================================
*/

public void BroadPhaseStep() {
    for (int i = 0; i < rigidbodyList.size() - 1; i++) {
        
        Rigidbody rigidbodyA = rigidbodyList.get(i);
        ArrayList<Rigidbody> rigidbodyACollisionExclusionList = rigidbodyA.getCollisionExclusionList();
        AABB rigidbodyA_AABB = rigidbodyA.GetAABB();
        
        
        for (int j = i + 1; j < rigidbodyList.size(); j++) {
            Rigidbody rigidbodyB = rigidbodyList.get(j);
            AABB rigidbodyB_AABB = rigidbodyB.GetAABB();

            if(rigidbodyACollisionExclusionList.contains(rigidbodyB)) {
                continue;
            }

            if ((rigidbodyA.getIsStatic() && rigidbodyB.getIsStatic())) {
                continue;
            }
            

            //Remove if shit breaks
            if(!rigidbodyA.getCollidability() || !rigidbodyB.getCollidability()) {
                continue;
            }
            
            if (!Collisions.IntersectAABB(rigidbodyA_AABB, rigidbodyB_AABB)) {
                continue;
            }

            ArrayList<Integer> pair = new ArrayList<Integer>(Arrays.asList(i, j));
            collisionPairs.add(pair);
        }
    }
}

public void NarrowPhaseStep() {
    for (int i = 0; i < collisionPairs.size(); i++) {
        ArrayList<Integer> pair = collisionPairs.get(i);

        Rigidbody rigidbodyA = rigidbodyList.get(pair.get(0));
        Rigidbody rigidbodyB = rigidbodyList.get(pair.get(1));
        
        CollisionResult collisionResult = Collisions.Collide(rigidbodyA, rigidbodyB);
            
        if (collisionResult.getIsColliding()) {
            
            PVector minimumTranslationVector = PVector.mult(collisionResult.getNormal(), collisionResult.getDepth());
            
            SeperateBodies(rigidbodyA, rigidbodyB, minimumTranslationVector);
            Collisions.FindCollisionPoints(rigidbodyA, rigidbodyB, collisionResult);
            CollisionManifold collisionManifold = new CollisionManifold(rigidbodyA, rigidbodyB, collisionResult);
            this.ResolveCollisionRotationAndFriction(collisionManifold);

            for(PVector contact : collisionResult.getPointsOfContact()) {
                pointsOfContactList.add(contact);
            }
        }
    }
}
    

public void StepBodies(float dt, int totalIterations) {
    if(IS_PAUSED) {
        return;
    }
    
    for(Rigidbody rigidbody : rigidbodyList) {
        if(rigidbody.getIsStatic() ) {
            continue;
        }

        rigidbody.update(dt, totalIterations);
    }
}
            
/*
==================================================================================================
======================================== Helper Methods  =========================================
==================================================================================================
*/
public void AddBodyToBodyEntityList(Rigidbody body) {
    rigidbodyList.add(body);
}

public void RemoveBodyFromBodyEntityList(Rigidbody body) {
     rigidbodyList.remove(body);
}
        
public void RemoveBodyFromBodyEntityList(int index) {
   
   if(index < 0 || index >= rigidbodyList.size()) {
        throw new IndexOutOfBoundsException("Index: " + index + ", Size: " + rigidbodyList.size());
    }

    rigidbodyList.remove(index);
}

public Rigidbody GetBodyFromBodyEntityList(int index) {

    if(index < 0 || index >= rigidbodyList.size()) {
        throw new IndexOutOfBoundsException("Index: " + index + ", Size: " + rigidbodyList.size());
    }

    return rigidbodyList.get(index);
}
                        
public void ClearBodyEntityList() {
    rigidbodyList.clear();
}



    
                                        
                                        
public KeyHandler KeyHandler = new KeyHandler();

public DashedLines dash;
// public Camera Camera = new Camera();
public Camera Camera;
public MouseObject Mouse = new MouseObject();
public FrameTimeUtility FrameTimeUtility = new FrameTimeUtility();
public UI_QualitySettings playTimeTracker;


public Rigidbody RigidbodyGenerator = new Rigidbody();
public Shape Render = new Shape();
	
public UI_Constants UI_Constants;
public UI_Manager UI_Manager = new UI_Manager();




public class Rigidbody {

  //Capital letter denotes read only
  private String ID;
  private PVector position = new PVector();
  private PVector previousPosition = new PVector();
  private PVector linearVelocity = new PVector();
  private float angle;
  private float angularVelocity;
    
  private ShapeType ShapeType;
  private float Mass;
  private float InvMass;
  private float Density;
  private float Restitution;
  private float Area;
  private float RotationalInertia;
  private float InvRotationalInertia;
  private float Radius;
  private float Width;
  private float Height;
  private float coefficientOfStaticFriction;
  private float coefficientOfKineticFriction;
  

  private PVector[] Vertices = new PVector[0];
  private AABB aabb;
  private PVector[] transformedVertices = new PVector[0];

  private ArrayList<Rigidbody> collisionExclusionList = new ArrayList<Rigidbody>();

  private float strokeWeight;
  private PVector strokeColour = new PVector();
  private PVector fillColour = new PVector();
  
  private boolean transformUpdateRequired;
  private boolean aabbUpdateRequired;
  
  private boolean isStatic;
  private boolean isTranslationallyStatic;
  private boolean isRotationallyStatic;
  private boolean isVisible;
  private boolean isCollidable;


  
  private float netTorque = 0f;
  private PVector netForce = new PVector();
  
  private ArrayList<ForceRegistry> forceRegistry = new ArrayList<ForceRegistry>();
  
  
  
  
  
  
  /*
  ==================================================================================================
  ==================================CONSTRUCTORS====================================================
  ==================================================================================================
  */
  public Rigidbody() {
      //this.aabbUpdateRequired = true;
      //this.transformUpdateRequired = true;
  }
  
  private Rigidbody(float density, float mass, float rotationalIntertia, float restitution,
    float area, float radius, float width, float height, PVector[] vertices, boolean isStatic,
    boolean isCollidable, float strokeWeight, PVector strokeColour, PVector fillColour, ShapeType shapeType)
  {
    this.ID = UUID.randomUUID().toString();
    this.Mass = mass;
    this.RotationalInertia = rotationalIntertia;
    this.InvMass = mass > 0 ? 1 / mass : 0;
    this.InvRotationalInertia = rotationalIntertia > 0 ? 1 / rotationalIntertia : 0;


    this.Density = density;
    this.Restitution = restitution;
    this.Area = area;
    this.Radius = radius;
    this.Width = width;
    this.Height = height;

    this.coefficientOfStaticFriction = COEFFICIENT_OF_STATIC_FRICTION;
    this.coefficientOfKineticFriction = COEFFICIENT_OF_KINETIC_FRICTION;
  

    this.ShapeType = shapeType;
    this.strokeWeight = strokeWeight;
    this.strokeColour = strokeColour;
    this.fillColour = fillColour;


    this.isStatic = isStatic;
    this.isCollidable = true;
    this.isVisible = true;

    this.position = new PVector();
    this.linearVelocity = new PVector();
    this.angle = 0f;
    this.angularVelocity = 0f;
    
    
    if (shapeType == ShapeType.BOX) {

        this.Vertices = vertices;
        this.transformedVertices = new PVector[this.Vertices.length];
        this.transformUpdateRequired = true;
    } else {
        this.Vertices = null;
        this.transformedVertices = null;
    }
    
    //Sets InvMass for static objects to 0
    this.aabbUpdateRequired = true;
  }





  
  
  
  /*
  ==================================================================================================
  ========================== BODY & COLLIDER GEOMETRY METHODS ======================================
  ==================================================================================================
  */
  private PVector[] CreateBoxVertices(float width, float height) {
    float left = -width / 2;
    float right = width / 2;
    float top = height / 2;
    float bottom = -height / 2;
    
    PVector[] vertices = new PVector[4];
    vertices[0] = new PVector(left, top);
    vertices[1] = new PVector(right, top);
    vertices[2] = new PVector(right, bottom);
    vertices[3] = new PVector(left, bottom);


    return PhysEngMath.OrderVerticesClockwise(vertices);
  }
  
  public PVector[] GetTransformedVertices() {
    if(this.ShapeType == ShapeType.CIRCLE) {
        return this.transformedVertices;
    }

    if (this.transformUpdateRequired) {

      for (int i = 0; i < this.Vertices.length; i++) {

        PVector vertex = this.Vertices[i];

        this.transformedVertices[i] = PhysEngMath.Transform(vertex, this.position, this.angle);
      }
    }
    
    /*
    The way this transform system works, is that it caches the transformed vertices,
    and only transforms them once a change has been made. This means that,
    if no change is made is made, cached vertices are returned.
    if the transform is updated, the vertices are transformed, and the cache is updated.
    */
    this.aabbUpdateRequired = true;
    this.transformUpdateRequired = false;
    return this.transformedVertices;
  }
  
  
  public Rigidbody CreateCircleBody(float radius, float density,
    float restitution, boolean isStatic, boolean isCollidable, float strokeWeight,
    PVector strokeColour, PVector fillColour) {

    Rigidbody rigidbody;
    
    float area = (float) PI * radius * radius;
    

    if (area < MIN_BODY_AREA || area > MAX_BODY_AREA) {

      throw new IllegalArgumentException("Body area is too small or large");
    }

    if (density < MIN_BODY_DENSITY || density > MAX_BODY_DENSITY) {

      throw new IllegalArgumentException("Density is too small or large");
    } 

    restitution = PhysEngMath.Clamp(restitution, 0, 1);


    float mass = 0f;
    float rotationalIntertia = 0f;

    if(!isStatic) {
      mass = area * density;
      rotationalIntertia =  abs(0.5f * mass * radius * radius);
    }
    


    rigidbody = new Rigidbody(density, mass, rotationalIntertia, restitution, area, radius, 0, 0,
                              null, isStatic, isCollidable, strokeWeight,
                              strokeColour, fillColour, ShapeType.CIRCLE);
    
    return rigidbody;
  }
  


  public Rigidbody CreateBoxBody(float width, float height, float density,
    float restitution, boolean isStatic, boolean isCollidable, float strokeWeight,
    PVector strokeColour, PVector fillColour) {
    Rigidbody rigidbody;
    
    float area = width * height;
    
    //Argument exceptions for area and density
    if (area < MIN_BODY_AREA || area > MAX_BODY_AREA) {

      throw new IllegalArgumentException("Body area is too small or large");
    }

    if (density < MIN_BODY_DENSITY || density > MAX_BODY_DENSITY) {

      throw new IllegalArgumentException("Density is too small or large");
    } 
    
    //Clamps restitution between 0 and 1
    restitution = PhysEngMath.Clamp(restitution, 0, 1);
    
    //calculates mass from density and area
    float mass = 0f;
    float rotationalIntertia = 0f;

    if(!isStatic) {
      mass = area * density;
      rotationalIntertia = 0.5f * mass * width * width + height * height;
    }

    PVector[] vertices = CreateBoxVertices(width, height);
    
    rigidbody = new Rigidbody(density, mass, rotationalIntertia, restitution, area, 0, width,
                              height, vertices, isStatic, isCollidable, strokeWeight, strokeColour,
                              fillColour, ShapeType.BOX);
    
    return rigidbody;
  }


  public Rigidbody CreatePolygon(PVector[] vertices, float density,
    float restitution, boolean isStatic, boolean isTranslationallyStatic,
    boolean isRotationallyStatic, boolean isCollidable, float strokeWeight,
    PVector strokeColour, PVector fillColour) {

    Rigidbody rigidbody;

    float area = this.calculateArea(vertices);
    
    //Argument exceptions for area and density
    if (area < MIN_BODY_AREA || area > MAX_BODY_AREA) {

      throw new IllegalArgumentException("Body area is too small or large");
    }

    if (density < MIN_BODY_DENSITY || density > MAX_BODY_DENSITY) {

      throw new IllegalArgumentException("Density is too small or large");
    } 
    
    //Clamps restitution between 0 and 1
    restitution = PhysEngMath.Clamp(restitution, 0, 1);
    
    //calculates mass from density and area
    float mass = 0f;
    float rotationalIntertia = 0f;

    if(isStatic) {
      mass = 0f;
      rotationalIntertia = 0f;
    } else if(isTranslationallyStatic) {
      mass = 0f;
      rotationalIntertia = calculateMomentOfInertia(vertices, mass);
    } else if(isRotationallyStatic) {
      mass = area * density;
      rotationalIntertia = 0f;
    } else {
      mass = area * density;
      rotationalIntertia = calculateMomentOfInertia(vertices, mass);
    }

    
    rigidbody = new Rigidbody(density, mass, rotationalIntertia, restitution, area, 0, width,
                              height, vertices, isStatic, isCollidable, strokeWeight, strokeColour,
                              fillColour, ShapeType.BOX);
    
    return rigidbody;
  }


  public AABB GetAABB() {
    if(this.aabbUpdateRequired) {

    float minX = Float.MAX_VALUE;
    float minY = Float.MAX_VALUE;

    float maxX = -Float.MAX_VALUE;
    float maxY = -Float.MAX_VALUE;
    
    if(this.ShapeType == ShapeType.CIRCLE) {
      
      minX = this.position.x - this.Radius;
      minY = this.position.y - this.Radius;
      maxX = this.position.x + this.Radius;
      maxY = this.position.y + this.Radius;

    } else if (this.ShapeType == ShapeType.BOX) {

      PVector[] vertices = this.GetTransformedVertices();
      for (PVector vertex : vertices) {
        if (vertex.x < minX) {
            minX = vertex.x;
          }
          if (vertex.x > maxX) {
            maxX = vertex.x;
          }
          if (vertex.y < minY) {
            minY = vertex.y;
          }
          if (vertex.y > maxY) {
            maxY = vertex.y;
          }
        }
    }

    this.aabb = new AABB(new PVector(minX, minY), new PVector(maxX, maxY));
    this.aabbUpdateRequired = false;

  }
  return this.aabb;
}


public float calculateArea(PVector[] vertices) {
  float area = 0;
  int n = vertices.length;

  for (int i = 0, j = n - 1; i < n; j = i++) {
    area += vertices[i].x * vertices[j].y - vertices[j].x * vertices[i].y;
  }
  return Math.abs(area / 2.0f);
}


public float calculateMass(PVector[] vertices) {
  float area = calculateArea(vertices);
  return area * this.Density;
}


public float calculateMomentOfInertia(PVector[] vertices, float mass) {
  float I = 0;
  float area = calculateArea(vertices);
  int n = vertices.length;
  PVector centroid = calculateCentroid(vertices);

  for (int i = 0, j = n - 1; i < n; j = i++) {
    float xi = vertices[i].x - centroid.x, yi = vertices[i].y - centroid.y;
    float xj = vertices[j].x - centroid.x, yj = vertices[j].y - centroid.y;
    float cross = Math.abs(xi * yj - xj * yi);
    I += cross * (xi * xi + yi * yi + xi * xj + yi * yj + xj * xj + yj * yj);
  }
  I *= mass / (6 * area);
  return I;
}


public PVector calculateCentroid(PVector[] vertices) {
    float signedArea = 0;
    float cx = 0;
    float cy = 0;
    for (int i = 0, j = vertices.length - 1; i < vertices.length; j = i++) {
        float temp = (vertices[i].x * vertices[j].y) - (vertices[j].x * vertices[i].y);
        signedArea += temp;
        cx += (vertices[i].x + vertices[j].x) * temp;
        cy += (vertices[i].y + vertices[j].y) * temp;
    }
    signedArea /= 2;
    cx /= (6 * signedArea);
    cy /= (6 * signedArea);
    return new PVector(cx, cy);
}

//Overloaded method which works on the current rigidbody vertices
public PVector calculateCentroid() {
    float signedArea = 0;
    float cx = 0;
    float cy = 0;
    for (int i = 0, j = this.Vertices.length - 1; i < this.Vertices.length; j = i++) {
        float temp = (this.Vertices[i].x * this.Vertices[j].y) - (this.Vertices[j].x * this.Vertices[i].y);
        signedArea += temp;
        cx += (this.Vertices[i].x + this.Vertices[j].x) * temp;
        cy += (this.Vertices[i].y + this.Vertices[j].y) * temp;
    }
    signedArea /= 2;
    cx /= (6 * signedArea);
    cy /= (6 * signedArea);
    return new PVector(cx, cy);
}



public void adjustRigidbodyPosition(PVector[] vertices) {
    PVector newCOM = calculateCentroid(vertices);

    for(PVector vertex : vertices) {
        vertex.sub(newCOM);
    }
}

private boolean doEdgesIntersect(PVector p1, PVector p2, PVector p3, PVector p4) {

    float denominator = (p4.y - p3.y) * (p2.x - p1.x) - (p4.x - p3.x) * (p2.y - p1.y);
    if (denominator == 0) {
        return false; 
    }

    float ua = ((p4.x - p3.x) * (p1.y - p3.y) - (p4.y - p3.y) * (p1.x - p3.x)) / denominator;
    float ub = ((p2.x - p1.x) * (p1.y - p3.y) - (p2.y - p1.y) * (p1.x - p3.x)) / denominator;

    if (ua >= 0 && ua <= 1 && ub >= 0 && ub <= 1) {
        return true; 
    }

    return false;
}

private boolean validatePolygonVertices(PVector[] vertices) {
    for (int i = 0; i < vertices.length; i++) {
        for (int j = i + 1; j < vertices.length; j++) {
            int nextI = (i + 1) % vertices.length;
            int nextJ = (j + 1) % vertices.length;

            if (nextI != j && i != nextJ) {
                if (doEdgesIntersect(vertices[i], vertices[nextI], vertices[j], vertices[nextJ])) {
                    return false; 
                }
            }
        }
    }
    return true;
}

public void updateRigidbody() {
    if(this.ShapeType == ShapeType.BOX) {
      this.updatePolygon(this.Vertices);
    } else if(this.ShapeType == ShapeType.CIRCLE) {
      this.updateCircle(this.Radius);
    }
}

public void updateCircle(float radius) {

    this.Radius = radius;
    this.Area = (float) PI * this.Radius * this.Radius;
    this.Vertices = null;

    this.transformedVertices = null;

    if(this.isStatic) {
      this.Mass = 0f;
      this.InvMass = 0f;
      this.RotationalInertia = 0f;
      this.InvRotationalInertia = 0f;
    } else if(this.isTranslationallyStatic) {
      this.Mass = this.Density * this.Area;
      this.InvMass = 0f;
      this.RotationalInertia = 0.5f * this.Mass * this.Radius * this.Radius;
      this.InvRotationalInertia = 1 / this.RotationalInertia;
    } else if(this.isRotationallyStatic) {
      this.Mass = this.Area * this.Density;
      this.InvMass = this.Mass;
      this.RotationalInertia = 0f;
      this.InvRotationalInertia = 0f;
    } else {
        this.Mass = this.Area * this.Density;
        this.InvMass = this.Mass > 0 ? 1 / this.Mass : 0;
        this.RotationalInertia = 0.5f * this.Mass * this.Radius * this.Radius;
        this.InvRotationalInertia = this.RotationalInertia > 0 ? 1 / this.RotationalInertia : 0;
    }



    this.transformUpdateRequired = true;
    this.aabbUpdateRequired = true;
}

public void updatePolygon(PVector[] newVertices) {

    newVertices = PhysEngMath.OrderVerticesClockwise(newVertices);

    this.Vertices = newVertices;
    this.transformedVertices = new PVector[this.Vertices.length];
    PVector newCOM = calculateCentroid(this.Vertices);

    for(int i = 0; i < this.Vertices.length; i++) {
          this.Vertices[i].sub(newCOM);
    }

    float newMass = calculateMass(this.Vertices);
    float newMomentOfInertia = calculateMomentOfInertia(this.Vertices, newMass);

    if(this.isStatic) {
      this.Mass = 0f;
      this.InvMass = 0f;
      this.RotationalInertia = 0f;
      this.InvRotationalInertia = 0f;
    } else if(this.isTranslationallyStatic) {
      this.Mass = newMass;
      this.InvMass = 0f;
      this.RotationalInertia = newMomentOfInertia;
      this.InvRotationalInertia = this.RotationalInertia > 0 ? 1 / this.RotationalInertia : 0;
    } else if(this.isRotationallyStatic) {
      this.Mass = newMass;
      this.InvMass = this.Mass > 0f ? 1 / this.Mass : 0f;
      this.InvRotationalInertia = 0f;
      this.RotationalInertia = newMomentOfInertia;
    } else {
      this.Mass = newMass;
      this.InvMass = this.Mass > 0 ? 1 / this.Mass : 0;
      this.RotationalInertia = newMomentOfInertia;
      this.InvRotationalInertia = this.RotationalInertia > 0 ? 1 / this.RotationalInertia : 0;
    }

    float newArea = calculateArea(this.Vertices);

    this.Area = newArea;

    this.transformUpdateRequired = true;
    this.aabbUpdateRequired = true;
}


public void deserializeRigidbody(String ID, ShapeType ShapeType, PVector position, PVector linearVelocity, float angle, 
                                 float angularVelocity, float Density, float Restitution, float radius, float width, 
                                 float height, float coefficientOfStaticFriction, float coefficientOfKineticFriction,
                                 PVector[] vertices, boolean isStatic, boolean isTranslationallyStatic, boolean isRotationallyStatic,
                                 boolean isCollidable, boolean isVisible, float strokeWeight, PVector strokeColour, PVector fillColour) {
    this.ID = ID; 

    this.position.set(position);
    this.linearVelocity.set(linearVelocity);
    this.angle = angle;
    this.angularVelocity = angularVelocity;

    this.Density = Density;
    this.Restitution = Restitution;
    this.ShapeType = ShapeType;

    this.isStatic = isStatic;
    this.isTranslationallyStatic = isTranslationallyStatic;
    this.isRotationallyStatic = isRotationallyStatic;

    this.isCollidable = isCollidable;
    this.isVisible = isVisible;

    this.strokeWeight = strokeWeight;
    this.strokeColour = strokeColour;
    this.fillColour = fillColour;

    this.coefficientOfStaticFriction = coefficientOfStaticFriction;
    this.coefficientOfKineticFriction = coefficientOfKineticFriction;

    this.updateRigidbody();
  }





  /*
  ==================================================================================================
  ==================================METHODS=========================================================
  ==================================================================================================
  */
  public void Move(PVector amount) {
    this.position.add(amount);

    this.transformUpdateRequired = true;
    this.aabbUpdateRequired = true;
  }
  
  public void MoveTo(PVector position) {
    this.position = position;

    this.transformUpdateRequired = true;
    this.aabbUpdateRequired = true;
  }

  public void SetInitialPosition(PVector position) {
    this.position.set(position);
    this.previousPosition.set(position);
    this.transformUpdateRequired = true;
    this.aabbUpdateRequired = true;
  }
  
  public void Rotate(float amount) {
    this.angle += amount;

    this.transformUpdateRequired = true;
    this.aabbUpdateRequired = true;
  }

  public void RotateTo(float angle) {
    this.angle = angle;

    this.transformUpdateRequired = true;
    this.aabbUpdateRequired = true;
  }


/*----------------------------- Mouse Detection Stuff ------------------------------------*/
  
public boolean contains(float x, float y) {

    if(this.ShapeType == ShapeType.CIRCLE) {
      return this.containsCircle(x, y);
    } else {
      return this.containsPolygon(x, y);
    }
}

public boolean containsCircle(float x, float y) {
    float distance = PVector.dist(this.position, new PVector(x, y));

    return (distance <= this.Radius);
}


public boolean containsPolygon(float x, float y) {
    boolean inside = false;
    PVector[] vertices = this.transformedVertices;

    for (int i = 0, j = vertices.length - 1; i < vertices.length; j = i++) {
        if ((vertices[i].y > y) != (vertices[j].y > y) &&
            (x < (vertices[j].x - vertices[i].x) * (y - vertices[i].y) / (vertices[j].y - vertices[i].y) + vertices[i].x)) {
            inside = !inside;
        }
    }
    
    return inside;
}



/*-------------------------------------------------------------------------------------*/
  

  /*
  ==================================================================================================
  ==================================UPDATE==========================================================
  ==================================================================================================
  */
  public void update(float dt, int iterations) {
    if(IS_PAUSED) {
      return;
    }
    if(isStatic) {
        return;
    }

    this.aabbUpdateRequired = true;
    this.transformUpdateRequired = true;
    dt /= (float)iterations;                
    this.RK4Position(dt);
    this.angularIntegration(dt);
    }

  /*
  ==================================================================================================
  ================================== INTEGRATOR ====================================================
  ==================================================================================================
  */

     public void RK4Position(float dt) {

        /*-------------- RK4 Position And Velocity Integration --------------*/
        PVector k1_v = PVector.mult(calculateAcceleration(this.position), dt);
        PVector k1_r = PVector.mult(this.linearVelocity, dt);

        PVector k2_v = PVector.mult(calculateAcceleration(PVector.add(this.position, PVector.mult(k1_r, 0.5f))), dt);
        PVector k2_r = PVector.mult(PVector.add(this.linearVelocity, PVector.mult(k1_v, 0.5f)), dt);

        PVector k3_v = PVector.mult(calculateAcceleration(PVector.add(this.position, PVector.mult(k2_r, 0.5f))), dt);
        PVector k3_r = PVector.mult(PVector.add(this.linearVelocity, PVector.mult(k2_v, 0.5f)), dt);

        PVector k4_v = PVector.mult(calculateAcceleration(PVector.add(this.position, k3_r)), dt);
        PVector k4_r = PVector.mult(PVector.add(this.linearVelocity, k3_v), dt);
        /*-------------------------------------------------------------------*/


        /*-------------- Reusable Vectors --------------*/
        PVector two_k2_r = PVector.mult(k2_r, 2);
        PVector two_k3_r = PVector.mult(k3_r, 2);

        PVector two_k2_v = PVector.mult(k2_v, 2);
        PVector two_k3_v = PVector.mult(k3_v, 2);
        /*-----------------------------------------------*/


        /*-------------- Final Position and Velocity --------------*/
        PVector finalPosition = PVector.add(this.position, PVector.div(PVector.add(k1_r, PVector.add(two_k2_r, PVector.add(two_k3_r, k4_r))), 6));
        PVector finalVelocity = PVector.add(this.linearVelocity, PVector.div(PVector.add(k1_v, PVector.add(two_k2_v, PVector.add(two_k3_v, k4_v))), 6));
        /*---------------------------------------------------------*/


        /*----------------- Update To New Values -----------------*/
        this.position = finalPosition;
        this.linearVelocity = finalVelocity;
        this.transformUpdateRequired = true;
        /*--------------------------------------------------------*/

  }


  public void angularIntegration(float dt) {

    this.angularVelocity += this.netTorque * this.InvRotationalInertia * dt;
    this.angle += this.angularVelocity*dt;


  }

    public PVector calculateAcceleration(PVector position) {

        /*--------------- Force Reset --------------*/
        this.netForce.set(0,0,0);
        this.netTorque = 0f;
        /*------------------------------------------*/

        /*------------ Net Force Calculation ------------*/
        for (ForceRegistry force : this.forceRegistry) {

            PVector currentForce = force.getForce(this, position).mult(this.Mass);
            this.netForce.add(currentForce);

            PVector leverArm = PVector.sub(force.getApplicationPoint(this, this.position), this.position);
            this.netTorque += leverArm.cross(currentForce).z;

        }
        /*-----------------------------------------------*/

        /*------------ Acceleration Calculation ------------*/
        return this.netForce.mult(this.InvMass);
        /*--------------------------------------------------*/

    }



  /*
  ============================================= Methods =======================================================
  */

  public void delete() {
    for(ForceRegistry force : this.forceRegistry) {
      Rigidbody rigidbodyA = force.getRigidbodyA();
      Rigidbody rigidbodyB = force.getRigidbodyB();
      ALL_FORCES_ARRAYLIST.remove(force);

      if((rigidbodyA != null && rigidbodyA != this)) {
        rigidbodyA.removeForceFromForceRegistry(force);
      } else if(rigidbodyB != null && rigidbodyB != this) {
        rigidbodyB.removeForceFromForceRegistry(force);
      } 
    }
    rigidbodyList.remove(this);
  }

  public void copy(Rigidbody rigidbody) {
    this.ID = UUID.randomUUID().toString();

    this.position.set(rigidbody.position);
    this.linearVelocity.set(rigidbody.linearVelocity);
    this.angle = rigidbody.angle;
    this.angularVelocity = rigidbody.angularVelocity;

    this.ShapeType = rigidbody.ShapeType;
    this.Density = rigidbody.Density;
    this.Restitution = rigidbody.Restitution;
    this.Radius = rigidbody.Radius;

    this.coefficientOfStaticFriction = rigidbody.coefficientOfStaticFriction;
    this.coefficientOfKineticFriction = rigidbody.coefficientOfKineticFriction;

    if(this.ShapeType == ShapeType.BOX || this.ShapeType == ShapeType.POLYGON) {
        this.Vertices = new PVector[rigidbody.Vertices.length];
        for(int i = 0; i < rigidbody.Vertices.length; i++) {
            this.Vertices[i] = rigidbody.Vertices[i].copy();
        }
    } else {
        this.Vertices = null;
    }

    this.strokeWeight = rigidbody.strokeWeight;
    this.strokeColour = rigidbody.strokeColour.copy();
    this.fillColour = rigidbody.fillColour.copy();

    this.isStatic = rigidbody.isStatic;
    this.isTranslationallyStatic = rigidbody.isTranslationallyStatic;
    this.isRotationallyStatic = rigidbody.isRotationallyStatic;

    this.isVisible = rigidbody.isVisible;
    this.isCollidable = rigidbody.isCollidable;

    this.addForceToForceRegistry(new Gravity(this));

    this.updateRigidbody();
    this.aabbUpdateRequired = true;
    this.transformUpdateRequired = true;

  }



  public float getMass() {
    return this.Mass;
  }

  public void setMass(float mass) {
    this.Mass = mass;
    this.InvMass = 1/mass;
    this.RotationalInertia = (this.ShapeType == ShapeType.BOX) ? 0.5f * Mass * width * width + height * height : 0.5f * Mass * this.Radius * this.Radius;
    this.InvRotationalInertia = (this.RotationalInertia > 0) ? 1 / this.RotationalInertia : 0;
  }


  public float getDensity() {
    return this.Density;
  }

  public void setDensity(float density) {
    this.Density = density;
    this.setMass(this.Area * this.Density);
  }
  
  public float getRestitution() {
    return this.Restitution;
  }

  public void setRestitution(float restitution) {
    this.Restitution = restitution;
  }
  
  public void setArea(float area) {
    this.Area = area;
  }

  public float getArea() {
    return this.Area;
  }
  
  public float getRadius() {
    return this.Radius;
  }

  public void setRadius(float radius) {
    this.Radius = radius;
    this.Area = (float) PI * this.Radius * this.Radius;
    setDensity(this.Density);
  }

  public float getWidth() {
    return this.Width;
  }

  public void setWidth(float width) {
    if(this.ShapeType == ShapeType.BOX) {
      this.Width = width;
      this.Area = this.Width*this.Height;
      setDensity(this.Density);
      this.Vertices = CreateBoxVertices(this.Width, this.Height);
      this.transformUpdateRequired = true;
    }
  }

  public float getHeight() {
    return this.Height;
  }
  
  public void setHeight(float height) {
    this.Height = height;
    this.Area = this.Width*this.Height;
    setDensity(this.Density);
    this.Vertices = CreateBoxVertices(this.Width, this.Height);
    this.transformUpdateRequired = true;
  }

  public ShapeType getShapeType() {
    return this.ShapeType;
  }

  public void setShapeType(ShapeType shapeType) {
    this.ShapeType = shapeType;
  }

  public void setVertices(PVector[] vertices) {
    this.Vertices = vertices;
  }

  public PVector[] getVertices() {
    return this.Vertices;
  }

  public void setTransformedVerticesLength(int length) {
    this.transformedVertices = new PVector[length];
  }
  
  public float getInvMass() {
    return this.InvMass;
  }

  public float getRotationalInertia() {
    return this.RotationalInertia;
  }

  public float getInvRotationalInertia() {
    return this.InvRotationalInertia;
  }




  
/*
==================================================================================================
==================================GETTERS & SETTERS===============================================
==================================================================================================
*/
    public String getID(){
      return this.ID;
    }
    
    public void setID(String ID) {
      this.ID = ID;
    }
    
    public boolean getTransformUpdateRequired() {
      return this.transformUpdateRequired;
    }
    
    public void setTransformUpdateRequired(boolean transformUpdateRequired) {
      this.transformUpdateRequired = transformUpdateRequired;
    }
    
    public boolean getAABBUpdateRequired() {
      return this.aabbUpdateRequired;
    }
    
    public void setAABBUpdateRequired(boolean aabbUpdateRequired) {
      this.aabbUpdateRequired = aabbUpdateRequired;
    }
    
    public PVector getPosition() {
      return this.position;
    }
    
    public void setPosition(PVector position) {
      this.transformUpdateRequired = true;
      this.aabbUpdateRequired = true;
      this.position.set(position);
    }

    public void addPosition(PVector difference) {
      this.transformUpdateRequired = true;
      this.aabbUpdateRequired = true;
      this.position.add(difference);
    }

    public void addPosition(float x, float y) {
      this.transformUpdateRequired = true;
      this.aabbUpdateRequired = true;
      this.position.add(x, y);
    }

    public PVector getVelocity() {
      return this.linearVelocity;
    }
    
    public void setVelocity(PVector velocity) {
      this.linearVelocity = velocity;
    }
    
    public float getStrokeWeight() {
      return this.strokeWeight;
    }
    
    public void setStrokeWeight(float strokeWeight) {
      this.strokeWeight = strokeWeight;
    }
    
    public PVector getStrokeColour() {
      return this.strokeColour;
    }
    
    public void setStrokeColour(PVector strokeColour) {
      this.strokeColour = strokeColour;
    }
    //Overloaded method for setting stroke colour with 3 floats
    public void setStrokeColour(float r, float g, float b) {
      this.strokeColour = new PVector(r, g, b);
    }
    
    public PVector getFillColour() {
      return this.fillColour;
    }
    
    
    public void setFillColour(PVector fillColour) {
      this.fillColour = fillColour;
    }
    //Overloaded method for setting fill colour with 3 floats
    public void setFillColour(float r, float g, float b) {
      this.fillColour = new PVector(r, g, b);
    }
    
    public ArrayList<ForceRegistry> getForceRegistry() {
      return this.forceRegistry;
    }
    
    public ForceRegistry getForceFromForceRegistry(int index) {
      return this.forceRegistry.get(index);
    }
    
    public int getForceRegistrySize() {
      return this.forceRegistry.size();
    }
    
    public void addForceToForceRegistry(ForceRegistry forceRegistry) {
      this.forceRegistry.add(forceRegistry);
    }
    
    public void clearForceRegistry() {
      this.forceRegistry.clear();
    }
    
    public void removeForceFromForceRegistry(ForceRegistry forceRegistry) {
      this.forceRegistry.remove(forceRegistry);
    }
    
    public void removeForceFromForceRegistry(int index) {
      this.forceRegistry.remove(index);
    }
    
    public boolean getIsStatic() {
      return this.isStatic;
    }
    
    public void setIsStatic(boolean isStatic) {
        this.isStatic = isStatic;

        if(isStatic) {
            this.InvMass = 0f;
            this.InvRotationalInertia = 0f;
        }
    }
    
    public boolean getIsVisible() {
      return this.isVisible;
    }
    
    public void setIsVisible(boolean isVisible) {
      this.isVisible = isVisible;
    }
      public float getAngle() {
      return this.angle;
    }
    
    public void setAngle(float angle) {
      this.transformUpdateRequired = true;
      this.angle = angle;
    }
    
    public void addBodyToCollisionExclusionList(Rigidbody rigidbody) {
      this.collisionExclusionList.add(rigidbody);
    }
    
    public ArrayList<Rigidbody> getCollisionExclusionList() {
      return this.collisionExclusionList;
    }
    
    public float getAngularVelocity(){
      return this.angularVelocity;
    }
    
    public void setAngularVelocity(float angularVelocity) {
      this.angularVelocity = angularVelocity;
    }


    public float getCoefficientOfKineticFriction() {
        return this.coefficientOfKineticFriction;
    }

    public void setCoefficientOfKineticFriction(float coefficientOfKineticFriction) {
        this.coefficientOfKineticFriction = coefficientOfKineticFriction;
    }

    public float getCoefficientOfStaticFriction() {
        return this.coefficientOfStaticFriction;
    }

    public void setCoefficientOfStaticFriction(float coefficientOfStaticFriction) {
        this.coefficientOfStaticFriction = coefficientOfStaticFriction;
    }

    public boolean getIsTranslationallyStatic() {
        return this.isTranslationallyStatic;
    }

    public void setIsTranslationallyStatic(boolean isTranslationallyStatic) {
        this.isTranslationallyStatic = isTranslationallyStatic;
        
        if(this.isTranslationallyStatic) {
          this.InvMass = 0f;
        }
    }

    public boolean getIsRotationallyStatic() {
        return this.isRotationallyStatic;
    }

    public void setIsRotationallyStatic(boolean isRotationallyStatic) {
        this.isRotationallyStatic = isRotationallyStatic;
        if(this.isRotationallyStatic) {
          this.InvRotationalInertia = 0f;
        }
    }

    
    public boolean getCollidability() {
        return this.isCollidable;
    }

    public void setCollidability(boolean isCollidable) {
        this.isCollidable = isCollidable;
    }

    public void setTransformedVertices(PVector[] transformedVertices) {
        this.transformedVertices = transformedVertices;
    }


    @Override
    public String toString() {
        System.out.println("Radius: " + this.Radius);
        System.out.println("Width: " + this.Width);
        System.out.println("Height: " + this.Height);
        System.out.println("Area: " + this.Area);
        System.out.println("Density: " + this.Density);
        System.out.println("Restitution: " + this.Restitution);
        System.out.println("Mass: " + this.Mass);
        System.out.println("Rotational Inertia: " + this.RotationalInertia);
        System.out.println("InvMass: " + this.InvMass);
        System.out.println("InvRotationalInertia: " + this.InvRotationalInertia);
        System.out.println("ShapeType: " + this.ShapeType);
        System.out.println("StrokeWeight: " + this.strokeWeight);
        System.out.println("StrokeColour: " + this.strokeColour);
        System.out.println("FillColour: " + this.fillColour);
        System.out.println("IsStatic: " + this.isStatic);
        System.out.println("IsRotationallyStatic:" + this.isRotationallyStatic);
        System.out.println("IsTranslationallyStatic:" + this.isTranslationallyStatic);
        System.out.println("IsCollidable: " + this.isCollidable);
        System.out.println("IsVisible: " + this.isVisible);
        System.out.println("Position: " + this.position);
        System.out.println("LinearVelocity: " + this.linearVelocity);
        System.out.println("Angle: " + this.angle);
        System.out.println("AngularVelocity: " + this.angularVelocity);
        System.out.println("Vertices: " + this.Vertices);
        System.out.println("TransformedVertices: " + this.transformedVertices);
        System.out.println("TransformUpdateRequired: " + this.transformUpdateRequired);
        System.out.println("AABBUpdateRequired: " + this.aabbUpdateRequired);
        System.out.println();
        System.out.println();
        System.out.println();
        return " ";
    }
}
public class Rod implements ForceRegistry {
/*-------------------------------------------------------------------------------------------------*/
    private float length = 0f;
    private float stiffness = 250000.0f;
    private float damping = 1.0f;

    private PVector localAnchorA = new PVector();
    private PVector localAnchorB = new PVector();
    private PVector anchorPoint = new PVector();

    private boolean isTwoBodyRod;
    private boolean isJoint;

    private Rigidbody rigidbodyA;
    private Rigidbody rigidbodyB;


/*-------------------------------------------------------------------------------------------------*/
    private PVector worldAnchorA = new PVector();
    private PVector worldAnchorB = new PVector();

    private PVector drawWorldAnchorA = new PVector();
    private PVector drawWorldAnchorB = new PVector();

    private PVector relativeVelocity = new PVector();

    private PVector velocityA = new PVector();
    private PVector velocityB = new PVector();

    private PVector dampingForce = new PVector();
    private PVector direction = new PVector();
    private PVector rodForce = new PVector();
    private PVector force = new PVector();
    private PVector rigidbodyOrientation = new PVector();

    private float displacement;
    private float dot;
    private float currentRigidbodyAngle;

/*-------------------------------------------------------------------------------------------------*/
//Reusable stuff


    public Rod(Rigidbody rigidbodyA, PVector localAnchorA, PVector anchorPoint) {

        this.rigidbodyA = rigidbodyA;

        this.anchorPoint.set(anchorPoint);
        this.localAnchorA.set(localAnchorA);

        this.isTwoBodyRod = false;

        if(rigidbodyA == null) {
            throw new NullPointerException("Rigidbody A is null");
        }
        
        this.length = PVector.sub(PhysEngMath.Transform(this.localAnchorA, this.rigidbodyA.getPosition(), this.rigidbodyA.getAngle()), 
                                  this.anchorPoint)
                                  .mag();
    }

    public Rod(Rigidbody rigidbodyA, Rigidbody rigidbodyB, PVector localAnchorA, PVector localAnchorB) {

        this.rigidbodyA = rigidbodyA;
        this.rigidbodyB = rigidbodyB;

        this.localAnchorA.set(localAnchorA);
        this.localAnchorB.set(localAnchorB);

        this.isTwoBodyRod = true;

        if(rigidbodyA == null) {
            throw new NullPointerException("Rigidbody A is null");
        } else if(rigidbodyB == null) {
            throw new NullPointerException("Rigidbody B is null");
        }

        this.length = PVector.sub(PhysEngMath.Transform(this.localAnchorB, this.rigidbodyB.getPosition(), this.rigidbodyB.getAngle()), 
                                  PhysEngMath.Transform(this.localAnchorA, this.rigidbodyA.getPosition(), this.rigidbodyA.getAngle()))
                                  .mag();
    }


@Override
public PVector getForce(Rigidbody rigidbody, PVector position) {

    this.force.set(0,0,0);

    if(isTwoBodyRod) {
        if(rigidbody == rigidbodyA) {
                this.worldAnchorA.set(PhysEngMath.Transform(this.localAnchorA, position, this.rigidbodyA.getAngle()));
                this.worldAnchorB.set(PhysEngMath.Transform(this.localAnchorB, this.rigidbodyB.getPosition(), this.rigidbodyB.getAngle()));

                this.velocityA.set(rigidbodyA.getVelocity());
                this.velocityB.set(rigidbodyB.getVelocity());

                this.direction.set(this.worldAnchorB.sub(this.worldAnchorA));
                
                this.displacement = direction.mag();
                this.direction.normalize();

                this.relativeVelocity.set(PVector.sub(this.velocityB, this.velocityA));

                this.dot = PVector.dot(relativeVelocity, this.direction);
                this.dampingForce.set(PVector.mult(this.direction, damping * dot));

                this.force.add(this.direction.mult(this.stiffness * (displacement - this.length)));
                this.force.add(this.dampingForce);
                
                return this.force;

            } else {
                this.worldAnchorA.set(PhysEngMath.Transform(this.localAnchorA, this.rigidbodyA.getPosition(), this.rigidbodyA.getAngle()));
                this.worldAnchorB.set(PhysEngMath.Transform(this.localAnchorB, position, this.rigidbodyB.getAngle()));

                this.velocityA.set(rigidbodyA.getVelocity());
                this.velocityB.set(rigidbodyB.getVelocity());


                this.direction.set(this.worldAnchorB.sub(this.worldAnchorA));
                this.displacement = direction.mag();
                this.direction.normalize();


                this.relativeVelocity.set(PVector.sub(this.velocityA, this.velocityB));
                this.dot = PVector.dot(relativeVelocity, this.direction);

                this.dampingForce.set(PVector.mult(direction, -damping * dot));

                this.force.add(this.dampingForce);
                this.force.add(this.direction.mult(this.stiffness * (displacement - this.length)));

                return this.force.mult(-1);
            } 

    } else {

        this.worldAnchorA.set(PhysEngMath.Transform(this.localAnchorA, position, this.rigidbodyA.getAngle()));
        this.worldAnchorB.set(this.anchorPoint);

        this.velocityA.set(rigidbodyA.getVelocity());
        this.velocityB.set(0,0);    

        this.direction.set(this.worldAnchorB.sub(this.worldAnchorA));
        this.displacement = direction.mag();
        this.direction.normalize();

        this.relativeVelocity.set(this.velocityB.sub(this.velocityA));
        this.dot = PVector.dot(relativeVelocity, this.direction);

        this.dampingForce.set(this.direction.copy().mult(-damping * dot));

        this.force.add(this.direction.mult(this.stiffness * (displacement - this.length)));
        this.force.add(this.dampingForce);
        
        return this.force;
                
    }
}



@Override
public void draw() {
    if(isTwoBodyRod){

        this.drawWorldAnchorA.set(PhysEngMath.Transform(this.localAnchorA, this.rigidbodyA.getPosition(), this.rigidbodyA.getAngle()));
        this.drawWorldAnchorB.set(PhysEngMath.Transform(this.localAnchorB, this.rigidbodyB.getPosition(), this.rigidbodyB.getAngle()));

        strokeWeight(0.15f);
        stroke(0);
        line(this.drawWorldAnchorA.x, this.drawWorldAnchorA.y, this.drawWorldAnchorB.x, this.drawWorldAnchorB.y);
        strokeWeight(0.1f);
        stroke(255);
        line(this.drawWorldAnchorA.x, this.drawWorldAnchorA.y, this.drawWorldAnchorB.x, this.drawWorldAnchorB.y);
    } else {

        this.drawWorldAnchorA.set(PhysEngMath.Transform(this.localAnchorA, this.rigidbodyA.getPosition(), this.rigidbodyA.getAngle()));

        strokeWeight(0.15f);
        stroke(0);
        line(this.drawWorldAnchorA.x, this.drawWorldAnchorA.y, this.anchorPoint.x, this.anchorPoint.y);
        strokeWeight(0.1f);
        stroke(255);
        line(this.drawWorldAnchorA.x, this.drawWorldAnchorA.y, this.anchorPoint.x, this.anchorPoint.y);

    }
}  



@Override
public PVector getApplicationPoint(Rigidbody rigidbody, PVector position) {
        if(rigidbody == rigidbodyA) {
            return PhysEngMath.Transform(localAnchorA, rigidbodyA.getPosition(), rigidbody.getAngle());
        } else {
            return PhysEngMath.Transform(localAnchorB, rigidbodyB.getPosition(), rigidbody.getAngle());
        }
}


/*
====================================================================================================
===================================GETTERS AND SETTERS==============================================
====================================================================================================
*/
public void setLength(float length) {
    this.length = length;
  }

public void setAnchorPoint(PVector anchorPoint) {
    this.anchorPoint.set(anchorPoint);
  }

public void setLocalAnchorA(PVector localAnchorA) {
    this.localAnchorA.set(localAnchorA);
  }

public void setLocalAnchorB(PVector localAnchorB) {
    this.localAnchorB.set(localAnchorB);
  }

public void setStiffness(float stiffness) {
    this.stiffness = stiffness;
  }

public void setDamping(float damping) {
    this.damping = damping;
  }

public void setTwoBodyRod(boolean isTwoBodyRod) {
    this.isTwoBodyRod = isTwoBodyRod;
  }

public void setIsJoint(boolean isJoint) {
    this.isJoint = isJoint;

    if(this.isJoint) {
        if(this.isTwoBodyRod){
            this.length = 0f;
            rigidbodyA.addBodyToCollisionExclusionList(rigidbodyB);
            rigidbodyB.addBodyToCollisionExclusionList(rigidbodyA);
        } else {
            this.length = 0f;
        }
    }
}   



public float getLength() {
    return length;
  }

public PVector getAnchorPoint() {
    return anchorPoint;
  }

public PVector getLocalAnchorA() {
    return localAnchorA;
  }

public PVector getLocalAnchorB() {
    return localAnchorB;
  }

public float getStiffness() {
    return stiffness;
  }

public float getDamping() {
    return damping;
  }

public boolean getTwoBodyRod() {
    return isTwoBodyRod;
  }

public boolean getIsJoint() {
    return this.isJoint;
}
@Override
public Rigidbody getRigidbodyA() {
    return rigidbodyA;
  }
@Override
public Rigidbody getRigidbodyB() {
    if(this.isTwoBodyRod) {
        return this.rigidbodyB;
    }
    return this.rigidbodyA;
  }



}



                /*
                if(!this.isHingeable) {
                    float rigidbodyAngle = rigidbodyB.getAngle();
                    this.rigidbodyOrientation.set(cos(rigidbodyAngle), sin(rigidbodyAngle));

                    float angleBetween = PVector.angleBetween(this.direction, this.rigidbodyOrientation);

                    if (this.direction.copy().cross(this.rigidbodyOrientation).z < 0) {
                        angleBetween = -angleBetween;
                    }

                    float angleDifference = angleBetween - this.initialAngleB;
                    //this.netTorque = -angleStiffness * angleDifference - angleDamping * rigidbody.getAngularVelocity();
                    //rigidbodyB.setAngle(rigidbodyB.getAngle()-angleDifference);
                    //force.add(0, 0, correctiveTorque);
                }
                */
  
public class Shape {


  private int opacity = 166;


  private PVector fill = new PVector();
  private PVector stroke = new PVector();

  public Shape() {
  }
  
  public void draw() {
    
    background(16, 18, 19);
    drawRigidbodies();
  /*---------------------------------Collision Point Debugging--------------------------------------*/
    if(DRAW_AABBS) {
      drawAABB();
    }
    
    if(DRAW_CONTACT_POINTS) {
      drawCollisionPoints();
    }
  /*-----------------------------------------------------------------------------------------------*/
    drawForces();
  }

/*
====================================================================================================
====================================== Drawing Methods =============================================
====================================================================================================
*/
  public void drawRigidbodies() {

    for(int body = 0; body < rigidbodyList.size(); body++) {

      Rigidbody rigidbody = rigidbodyList.get(body);
        if(rigidbody.getIsVisible()) {
          if (rigidbody.getShapeType() == ShapeType.CIRCLE) {
            drawCircle(rigidbody.getPosition(), rigidbody.getRadius(),
                      rigidbody.getAngle(), rigidbody.getStrokeWeight(), rigidbody.getFillColour(),
                       rigidbody.getStrokeColour(), false);
          }

          if (rigidbody.getShapeType() == ShapeType.BOX) {
            
              drawPolygon(rigidbody.getPosition(), rigidbody.GetTransformedVertices(),
                          rigidbody.getStrokeWeight(), rigidbody.getFillColour(),
                          rigidbody.getStrokeColour(), false);
          }
        }
      }
  }

  public void drawCircle(PVector position, float radius, float angle, float strokeWeight, PVector fillColour,
    PVector strokeColour, boolean inEditMode) {

    float diameter = radius * 2.0f;

    this.stroke.set(strokeColour);
    this.fill.set(fillColour);


    if(inEditMode) {
      fill(this.fill.x, this.fill.y, this.fill.z, this.opacity);
      stroke(this.stroke.x, this.stroke.y, this.stroke.z, this.opacity);
    } else {
      fill(this.fill.x, this.fill.y, this.fill.z);
      stroke(this.stroke.x, this.stroke.y, this.stroke.z);
    }

    strokeWeight(strokeWeight);
    ellipseMode(CENTER);
    ellipse(position.x, position.y,  diameter,  diameter);

    PVector va = new PVector();
    PVector vb = new PVector(radius, 0);
    va = PhysEngMath.Transform(va, position, angle);
    vb = PhysEngMath.Transform(vb, position, angle);
    line(va.x, va.y, vb.x, vb.y);
    }

  public void drawCircle(PVector position, float radius, float angle, float strokeWeight, PVector fillColour,
    PVector strokeColour, float opacity) {

    float diameter = radius * 2.0f;

    this.stroke.set(strokeColour);
    this.fill.set(fillColour);

    fill(this.fill.x, this.fill.y, this.fill.z, opacity);
    stroke(this.stroke.x, this.stroke.y, this.stroke.z, opacity);

    strokeWeight(strokeWeight);
    ellipseMode(CENTER);
    ellipse(position.x, position.y,  diameter,  diameter);

    PVector va = new PVector();
    PVector vb = new PVector(radius, 0);
    va = PhysEngMath.Transform(va, position, angle);
    vb = PhysEngMath.Transform(vb, position, angle);
    line(va.x, va.y, vb.x, vb.y);
  }
  

  public void drawBox(PVector position, float width, float height, float angle, float strokeWeight,
    PVector fillColour, PVector strokeColour, boolean inEditMode) {

    this.stroke.set(strokeColour);
    this.fill.set(fillColour);


    if(inEditMode) {
      fill(this.fill.x, this.fill.y, this.fill.z, this.opacity);
      stroke(this.stroke.x, this.stroke.y, this.stroke.z, this.opacity);
    } else {
      fill(this.fill.x, this.fill.y, this.fill.z);
      stroke(this.stroke.x, this.stroke.y, this.stroke.z);
    }
    strokeWeight(strokeWeight);
    rectMode(CENTER);
    pushMatrix();
    rect(position.x, position.y, width, height);
    popMatrix();
  }

  public void drawBox(PVector position, float width, float height, float angle, float strokeWeight,
    PVector fillColour, PVector strokeColour, int opacity) {

    this.stroke.set(strokeColour);
    this.fill.set(fillColour);


    fill(this.fill.x, this.fill.y, this.fill.z, opacity);
    stroke(this.stroke.x, this.stroke.y, this.stroke.z, opacity);

    strokeWeight(strokeWeight);
    rectMode(CENTER);

    pushMatrix();
    rotate(angle);
    rect(position.x, position.y, width, height);
    popMatrix();
  }

  
  public void drawPolygon(PVector position, PVector[] transformedVertices, float strokeWeight,
    PVector fillColour, PVector strokeColour, boolean inEditMode) {
    
    this.stroke.set(strokeColour);
    this.fill.set(fillColour);

    if(inEditMode) {
      fill(this.fill.x, this.fill.y, this.fill.z, this.opacity);
      stroke(this.stroke.x, this.stroke.y, this.stroke.z, this.opacity);
    } else {
      fill(this.fill.x, this.fill.y, this.fill.z);
      stroke(this.stroke.x, this.stroke.y, this.stroke.z);
    }

    strokeWeight(strokeWeight);

    beginShape();
    for (PVector transformedVertex : transformedVertices) {
      vertex(transformedVertex.x, transformedVertex.y);
    }
    endShape(CLOSE);
  }






  public void drawAABB() {
    for(Rigidbody rigidbody : rigidbodyList) {
        AABB aabb = rigidbody.GetAABB();
        rectMode(CORNERS);
        stroke(255, 0, 0);
        noFill();
        rect(aabb.getMin().x, aabb.getMin().y, aabb.getMax().x, aabb.getMax().y);
    }
  }

/*-----------------------------------------------------------------------------------------------*/
public void drawForces() {
    for(Rigidbody rigidbody : rigidbodyList) {
        for(ForceRegistry force : rigidbody.getForceRegistry()) {
            force.draw();
        }
    }
}
/*---------------------------------Collision Point Debugging--------------------------------------*/
  public void drawCollisionPoints() {
      for(PVector point : pointsOfContactList) {
        stroke(0, 0, 0);
        strokeWeight(0.1f);
        noFill();
        rectMode(CENTER);
        rect(point.x, point.y, 1, 1);
      }
        pointsOfContactList.clear();
    }

  
/*-----------------------------------------------------------------------------------------------*/

/*
public void drawGrid(){

  float majorGridSize = 120;
  float secondaryMajorGridSize = 60;
  float minorGridSize = 30;

  // Calculate the number of grid lines based on the screen size and grid size
  int majorNumVerticalLines = min(ceil(width / majorGridSize), 1000);
  int secondaryMajornumVerticalLines = min(ceil(width / secondaryMajorGridSize), 1000);
  int minorNumVerticalLines = min(ceil(width / minorGridSize), 1000);

  int majorNumHorizontalLines = min(ceil(height / majorGridSize), 1000);
  int secondaryMajornumHorizontalLines = min(ceil(height / secondaryMajorGridSize), 1000);
  int minorNumHorizontalLines = min(ceil(height / minorGridSize), 1000);

  float majorOffsetX = ((Camera.position.x-width/2) * Camera.zoom) % majorGridSize;
  float majorOffsetY = ((Camera.position.y-height/2) * Camera.zoom) % majorGridSize;

  float secondaryMajorOffsetX = ((Camera.position.x-width/2)* Camera.zoom) % secondaryMajorGridSize;
  float secondaryMajorOffsetY = ((Camera.position.y-height/2) * Camera.zoom) % secondaryMajorGridSize;

  float minorOffsetX = ((Camera.position.x-width/2) * Camera.zoom) % minorGridSize;
  float minorOffsetY = ((Camera.position.y-height/2) * Camera.zoom) % minorGridSize;

// Draw the major vertical gridlines
for (int i = 0; i <= majorNumVerticalLines; i++) {
    float x = i * majorGridSize + majorOffsetX;
    fill(#3f3f3f);
    rect(x, 0, 1, height);
}

// Draw the major horizontal grid lines
for (int i = 0; i <= majorNumHorizontalLines; i++) {
    float y = i * majorGridSize + majorOffsetY;
    fill(#3f3f3f);
    rect(0, y, width, 0.25);
}

// Draw the secondary major vertical gridlines
for (int i = 0; i <= secondaryMajornumVerticalLines; i++) {
    float x = i * secondaryMajorGridSize + secondaryMajorOffsetX;
    fill(#3f3f3f);
    rect(x, 0, 0.5, height);
}

// Draw the secondary major horizontal grid lines
for (int i = 0; i <= secondaryMajornumHorizontalLines; i++) {
    float y = i * secondaryMajorGridSize + secondaryMajorOffsetY;
    fill(#3f3f3f);
    rect(0, y, width, 0.25);
}

//Draw the minor vertical gridlines
for (int i = 0; i <= minorNumVerticalLines; i++) {
    float x = i * minorGridSize + minorOffsetX;
    fill(#3f3f3f);
    rect(x, 0, 0.25, height);
}

// Draw the minor horizontal grid lines
for (int i = 0; i <= minorNumHorizontalLines; i++) {
    float y = i * minorGridSize + minorOffsetY;
    fill(#3f3f3f);
    rect(0, y, width, 0.25);
}
         
}
*/


}

public enum ShapeType {
  CIRCLE,
  BOX,
  POLYGON,
  SOFTBODY
}
//ID 0: CIRCLE
//ID 1: BOX
//ID 2: POLYGON
//ID 3: SOFTBODY
public class Softbody {

    private PVector initialPosition;

    private float radius;
    private float rectWidth;
    private float rectHeight;

    private float stiffness = 1000;
    private float damping = 1f;

    private int numRowParticles;
    private int numColumnParticles;

    private float particleRadius = 0.5f;

    private ArrayList<Rigidbody> softbodyEntityList = new ArrayList<Rigidbody>();
    private ArrayList<Rigidbody> edgeParticles = new ArrayList<Rigidbody>();
    private Rigidbody[][] softBodyParticles;

    

    public Softbody(PVector initialPosition, float radius, float RectWidth, float RectHeight) {
        this.initialPosition = initialPosition;
        this.radius = radius;

        this.rectWidth = (int)round(RectWidth);
        this.rectHeight = (int)round(RectHeight);

        //Create a way to calculate this later
        this.numRowParticles = (int)round(this.rectWidth/this.particleRadius);
        this.numColumnParticles = (int)round(this.rectHeight/this.particleRadius);
        softBodyParticles = new Rigidbody[numRowParticles][numColumnParticles];

        softbodyList.add(this);
    }


    public void CreateBoxSoftbody() {
        float spacingX = 2f;
        float spacingY = 2f;

        float initialParticlePositionX = this.initialPosition.x - this.rectWidth/2;
        float initialParticlePositionY = this.initialPosition.y - this.rectHeight/2;

        for(int row = 0; row < numRowParticles; row++) {
            for(int column = 0; column < numColumnParticles; column++) {

                PVector currentParticlePosition = new PVector(initialParticlePositionX + row*spacingX, initialParticlePositionY + column*spacingY);

                Rigidbody currentParticle = RigidbodyGenerator.CreateCircleBody(particleRadius, 0.5f, 0.1f, false, true, 0.1f, new PVector(0,0,0), new PVector(255,255,255));
                currentParticle.setPosition(currentParticlePosition);

                softBodyParticles[row][column] = currentParticle;
                //currentParticle.setCollidability(false);
                currentParticle.addForceToForceRegistry(new Gravity(currentParticle));
                currentParticle.setIsVisible(false);
                AddBodyToBodyEntityList(currentParticle);
            }
        }


for(int row = 0; row < numRowParticles; row++) {
    for(int column = 0; column < numColumnParticles; column++) {

        Rigidbody currentParticle = softBodyParticles[row][column];

        // Link to particle below if it exists
        if(row < numRowParticles - 1) {
            Rigidbody particleToLinkTo = softBodyParticles[row+1][column];
            addSpringBetweenParticles(currentParticle, particleToLinkTo);
        }

        // Link to particle to the right if it exists
        if(column < numColumnParticles - 1) {
            Rigidbody particleToLinkTo = softBodyParticles[row][column+1];
            addSpringBetweenParticles(currentParticle, particleToLinkTo);
        }

        // Link to bottom-right diagonal if it exists
        if(row < numRowParticles - 1 && column < numColumnParticles - 1) {
            Rigidbody particleToLinkTo = softBodyParticles[row+1][column+1];
            addSpringBetweenParticles(currentParticle, particleToLinkTo);
        }

        // Link to top-right diagonal if it exists
        if(row > 0 && column < numColumnParticles - 1) {
            Rigidbody particleToLinkTo = softBodyParticles[row-1][column+1];
            addSpringBetweenParticles(currentParticle, particleToLinkTo);
        }
        
    }
}

    }

private void addSpringBetweenParticles(Rigidbody particleA, Rigidbody particleB) {
    Spring spring = new Spring(particleA, particleB, new PVector(), new PVector());
    
    spring.setSpringConstant(this.stiffness);
    spring.setDamping(this.damping);
    spring.drawSpring = false;

    particleA.addForceToForceRegistry(spring);
    particleB.addForceToForceRegistry(spring);

    ALL_FORCES_ARRAYLIST.add(spring);
}

    public void updateSoftbody() {
      draw();
    }

    public void draw() {
        fill(255);
        stroke(0);
        beginShape();
        for (int column = 0; column < numColumnParticles; column++) {
          PVector pos = softBodyParticles[0][column].getPosition();
          vertex(pos.x, pos.y);
        }
        // Right edge
        for (int row = 0; row < numRowParticles; row++) {
          PVector pos = softBodyParticles[row][numColumnParticles - 1].getPosition();
          vertex(pos.x, pos.y);
        }
        // Bottom edge
        for (int column = numColumnParticles - 1; column >= 0; column--) {
          PVector pos = softBodyParticles[numRowParticles - 1][column].getPosition();
          vertex(pos.x, pos.y);
        }
        // Left edge
        for (int row = numRowParticles - 1; row >= 0; row--) {
          PVector pos = softBodyParticles[row][0].getPosition();
          vertex(pos.x, pos.y);
        }
        endShape(CLOSE);

    }


/*

public void draw() {

    beginShape();
    PVector center = calculateCenter();
    // Top edge
    for (int column = 0; column < numColumnParticles; column++) {
        PVector pos = softBodyParticles[0][column].getPosition();
        PVector offset = pos.copy().sub(center).normalize().mult(particleRadius);
        vertex(pos.x + offset.x, pos.y + offset.y);
    }
    // Right edge
    for (int row = 0; row < numRowParticles; row++) {
        PVector pos = softBodyParticles[row][numColumnParticles - 1].getPosition();
        PVector offset = pos.copy().sub(center).normalize().mult(particleRadius);
        vertex(pos.x + offset.x, pos.y + offset.y);
    }
    // Bottom edge
    for (int column = numColumnParticles - 1; column >= 0; column--) {
        PVector pos = softBodyParticles[numRowParticles - 1][column].getPosition();
        PVector offset = pos.copy().sub(center).normalize().mult(particleRadius);
        vertex(pos.x + offset.x, pos.y + offset.y);
    }
    // Left edge
    for (int row = numRowParticles - 1; row >= 0; row--) {
        PVector pos = softBodyParticles[row][0].getPosition();
        PVector offset = pos.copy().sub(center).normalize().mult(radius);
        vertex(pos.x + offset.x, pos.y + offset.y);
    }

    endShape(CLOSE);
}

private PVector calculateCenter() {
    float totalX = 0;
    float totalY = 0;
    int count = 0;

    for (int row = 0; row < numRowParticles; row++) {
        for (int col = 0; col < numColumnParticles; col++) {
            PVector pos = softBodyParticles[row][col].getPosition();
            totalX += pos.x;
            totalY += pos.y;
            count++;
        }
    }

    if (count == 0) {
        return new PVector(0, 0); // or some default value in case there are no particles
    }

    float centerX = totalX / count;
    float centerY = totalY / count;

    return new PVector(centerX, centerY);
}
*/
}

public class Spring implements ForceRegistry {

    private Rigidbody rigidbodyA;
    private Rigidbody rigidbodyB;

    private PVector anchorPoint = new PVector();
    private PVector localAnchorA = new PVector();
    private PVector localAnchorB = new PVector();
    
    private boolean drawSpring = true;

    //Some default values
    private boolean lockTranslationToXAxis = false;
    private boolean lockTranslationToYAxis = false;
    
    private boolean isPerfectSpring = false;

    private float equilibriumLength = 1f;
    private float springConstant = 50;
    private float damping = 0.5f;
    
    private float springLength;

    private boolean isTwoBodySpring;


    /*--------------- Reusable --------------- */
    private PVector worldAnchorA = new PVector();
    private PVector worldAnchorB = new PVector();

    private PVector velocityA = new PVector();
    private PVector velocityB = new PVector();

    private PVector direction = new PVector();


    public Spring () {
        this.rigidbodyA = null;
        this.rigidbodyB = null;
    }


    public Spring(Rigidbody rigidbody, PVector localAnchorA, PVector anchorPoint) {

        this.rigidbodyA = rigidbody;
        this.localAnchorA.set(localAnchorA);
        this.anchorPoint.set(anchorPoint);

        this.springLength = PhysEngMath.Transform(localAnchorA, rigidbodyA.getPosition(), rigidbodyA.getAngle()).sub(anchorPoint).mag();

        this.isTwoBodySpring = false;

    }

    public Spring(Rigidbody rigidbodyA, Rigidbody rigidbodyB, PVector localAnchorA, PVector localAnchorB) {
        
        this.rigidbodyA = rigidbodyA;
        this.rigidbodyB = rigidbodyB;
        
        this.localAnchorA.set(localAnchorA);
        this.localAnchorB.set(localAnchorB);
        
        this.springLength = PhysEngMath.Transform(localAnchorB, rigidbodyB.getPosition(), rigidbodyB.getAngle()).sub(PhysEngMath.Transform(localAnchorA, rigidbodyA.getPosition(), rigidbodyA.getAngle())).mag();

        this.isTwoBodySpring = true;

    }

    @Override
    public PVector getForce(Rigidbody rigidbody, PVector position) {
        float totalForceMagnitude = 0f;
        float displacement = 0f;

        if(isTwoBodySpring) {
                this.velocityA.set(rigidbodyA.getVelocity());
                this.velocityB.set(rigidbodyB.getVelocity());

                this.worldAnchorA.set(PhysEngMath.Transform(this.localAnchorA, (rigidbody == rigidbodyA) ? position : rigidbodyA.getPosition(), rigidbodyA.getAngle()));
                this.worldAnchorB.set(PhysEngMath.Transform(this.localAnchorB,(rigidbody == rigidbodyB) ? position : rigidbodyB.getPosition(), rigidbodyB.getAngle()));

                if(lockTranslationToYAxis) {
                    if(rigidbody == rigidbodyA) {
                        this.rigidbodyA.setVelocity(velocityA.set(0, velocityA.y));
                    } else {
                        this.rigidbodyB.setVelocity(velocityB.set(0, velocityB.y));
                    }
                } else if(lockTranslationToXAxis) {
                    if(rigidbody == rigidbodyA) {
                       this. rigidbodyA.setVelocity(velocityA.set(velocityA.x, 0));
                    } else {
                        this.rigidbodyB.setVelocity(velocityB.set(velocityB.x, 0));
                    }
                }

                this.direction.set(worldAnchorB.sub(worldAnchorA));
                displacement = this.direction.mag();
                direction.normalize();


                if(!isPerfectSpring){                                                                                    
                    totalForceMagnitude = (displacement - this.springLength * this.equilibriumLength) * this.springConstant;
                    totalForceMagnitude += (direction.dot(velocityB.sub(velocityA)) * this.damping);
                } else {
                    totalForceMagnitude = (displacement - this.springLength * this.equilibriumLength) * this.springConstant;
                }
            

                return this.direction.mult((rigidbody == rigidbodyA) ? totalForceMagnitude : -totalForceMagnitude);
        } else {
            worldAnchorA.set(PhysEngMath.Transform(this.localAnchorA, position, rigidbodyA.getAngle()));
            worldAnchorB.set(anchorPoint);
    
            velocityA.set(rigidbodyA.getVelocity());
            velocityB.set(0,0);

            this.direction.set(worldAnchorB.sub(worldAnchorA));
            displacement = direction.mag();
            direction.normalize();

            if(lockTranslationToYAxis) rigidbodyA.setVelocity(velocityA.set(0, velocityA.y));
            else if(lockTranslationToXAxis) rigidbodyA.setVelocity(velocityA.set(velocityA.x, 0));
            
            if(!isPerfectSpring){                                                                                    
                totalForceMagnitude = (displacement - this.springLength * this.equilibriumLength) * this.springConstant;
                totalForceMagnitude += (direction.dot(velocityB.sub(velocityA)) * this.damping);
            } else {
                totalForceMagnitude = (displacement - this.springLength * this.equilibriumLength) * this.springConstant;
            }

            return this.direction.mult(totalForceMagnitude);
        }
    } 

    
           

public void draw() {
    if(this.drawSpring) {
        PVector worldAnchorA;
        PVector worldAnchorB;
        PVector direction;
        float length;

        if(isTwoBodySpring) {
            worldAnchorA = PhysEngMath.Transform(localAnchorA, rigidbodyA.getPosition(), rigidbodyA.getAngle());
            worldAnchorB = PhysEngMath.Transform(localAnchorB, rigidbodyB.getPosition(), rigidbodyB.getAngle());
        } else {
            worldAnchorA = PhysEngMath.Transform(localAnchorA, rigidbodyA.getPosition(), rigidbodyA.getAngle());
            worldAnchorB = this.anchorPoint;
        }

        direction = PVector.sub(worldAnchorA, worldAnchorB);
        length = direction.mag();
        direction.normalize();

        fill(255);

        float segments = 5;
        float segmentLength = length / segments;

        float offsetMagnitude = 0.5f;


        strokeWeight(0.3f);
        stroke(0); 
        line(worldAnchorA.x, worldAnchorA.y, worldAnchorB.x, worldAnchorB.y);
        stroke(255); 
        strokeWeight(0.1f);
        line(worldAnchorA.x, worldAnchorA.y, worldAnchorB.x, worldAnchorB.y);
        
        PVector segmentStart = new PVector();
        PVector segmentEnd = new PVector();
        PVector midPoint = new PVector();
        PVector offset = new PVector();
        PVector directionSegmentLength = PVector.mult(direction, segmentLength);

        for(int i = 0; i < segments; i++) {

            segmentStart.set(PVector.add(worldAnchorB, PVector.mult(directionSegmentLength, i)));
            segmentEnd.set(PVector.add(worldAnchorB, PVector.mult(directionSegmentLength, i + 1)));


            midPoint.set(PVector.lerp(segmentStart, segmentEnd, 0.5f));


            if(i % 2 == 0) {
                offset.set(new PVector(-direction.y, direction.x).mult(offsetMagnitude));
            } else {
                offset.set(new PVector(direction.y, -direction.x).mult(offsetMagnitude));
            }

            PVector midPointOffset = PVector.add(midPoint, offset);

            strokeWeight(0.2f);
            stroke(0);
            line(segmentStart.x, segmentStart.y, midPointOffset.x, midPointOffset.y);
            line(midPointOffset.x, midPointOffset.y, segmentEnd.x, segmentEnd.y);
            strokeWeight(0.1f);
            stroke(255);
            line(segmentStart.x, segmentStart.y, midPointOffset.x, midPointOffset.y);
            line(midPointOffset.x, midPointOffset.y, segmentEnd.x, segmentEnd.y);
        }
    } else {
        return;
    }
}
    

    @Override
    public PVector getApplicationPoint(Rigidbody rigidbody, PVector position) {
            if(rigidbody == rigidbodyA) {
                return PhysEngMath.Transform(localAnchorA, position, rigidbodyA.getAngle());
            } else {
                return PhysEngMath.Transform(localAnchorB, position, rigidbodyB.getAngle());
            }
    }

/*
====================================================================================================
================================== Getters & Setters ===============================================
====================================================================================================
*/
    public void setRigidbodyA(Rigidbody rigidbody){
        this.rigidbodyA = rigidbody;
    }
    public void setSpringConstant(float springConstant) {
        this.springConstant = springConstant;
    }

    public void setSpringLength(float springLength) {
        this.springLength = springLength;
    }

    public void setEquilibriumLength(float equilibriumLength) {
        this.equilibriumLength = equilibriumLength;
    }

    public void setDamping(float damping) {
        this.damping = damping;
    }

    public void setLockTranslationToXAxis(boolean lockTranslationToXAxis) {
        this.lockTranslationToXAxis = lockTranslationToXAxis;
    }

    public void setLockTranslationToYAxis(boolean lockTranslationToYAxis) {
        this.lockTranslationToYAxis = lockTranslationToYAxis;
    }

    public void setPerfectSpring(boolean isPerfectSpring) {
        this.isPerfectSpring = isPerfectSpring;
    }
    public void setDrawSpring(boolean drawSpring) {
        this.drawSpring = drawSpring;
    }
    public void setAnchorPoint(PVector anchorPoint) {
        this.anchorPoint.set(anchorPoint);
    }

    public void setAnchorPoint(float x, float y) {
        this.anchorPoint.set(x, y);
    }

    public void setLocalAnchorA(PVector localAnchorA) {
        this.localAnchorA.set(localAnchorA);
    }

    public void setLocalAnchorA(float x, float y) {
        this.localAnchorA.set(x, y);
    }

    public void setLocalAnchorB(PVector localAnchorB) {
        this.localAnchorB.set(localAnchorB);
    }

    public void setLocalAnchorB(float x, float y) {
        this.localAnchorB.set(x, y);
    }

    public float getSpringConstant() {
        return this.springConstant;
    }

    public float getSpringLength() {
        return this.springLength;
    }

    public float getEquilibriumLength() {
        return this.equilibriumLength;
    }

    public float getDamping() {
        return this.damping;
    }

    public boolean getLockTranslationToXAxis() {
        return this.lockTranslationToXAxis;
    }

    public boolean getLockTranslationToYAxis() {
        return this.lockTranslationToYAxis;
    }

    public boolean getPerfectSpring() {
        return this.isPerfectSpring;
    }

    public PVector getAnchorPoint() {
        return this.anchorPoint;
    }

    public PVector getLocalAnchorA() {
        return this.localAnchorA;
    }

    public PVector getLocalAnchorB() {
        return this.localAnchorB;
    }

    public boolean getDrawSpring() {
        return this.drawSpring;
    }
    @Override
    public Rigidbody getRigidbodyA() {
        return this.rigidbodyA;
    }
    @Override
    public Rigidbody getRigidbodyB() {
        if(isTwoBodySpring) {
            return this.rigidbodyB;
        }
        return this.rigidbodyA;
    }

    public boolean getIsTwoBodySpring() {
        return this.isTwoBodySpring;
    }
}


public class UI_Button extends UI_Element {
    

    public UI_Window Button_ParentWindow;

    public String Button_Name;
    public float Button_Name_Position_X;
    public float Button_Name_Position_Y;

    public boolean Button_State;

    public PShape Button_Shape_Group = createShape(GROUP);


    public UI_Button (String Button_Name, UI_Window Button_ParentWindow, boolean Button_State) {
        this.Button_Name = Button_Name;
        this.Button_State = Button_State;

        this.Button_Shape_Group.setName(this.Button_Name + "Group");
        this.Button_ParentWindow = Button_ParentWindow;

        this.initializeButton();
    }

    public void initializeButton() {
        this.Element_Width = 138;
        this.Element_Height = 34;
        rectMode(CENTER);
        this.createElementBaseShape();
        this.createElementText();
    }




/*
======================================= Toggle Creation ============================================
*/  
    @Override
    public void createElementBaseShape() {
        rectMode(CENTER);
        ArrayList<UI_Element> elements = this.Button_ParentWindow.getWindowElements();

        int numElements = 0;

        for(UI_Element element : elements) {
            if(element instanceof UI_Button) {
                numElements++;
            }
        }

        float buttonShapeX = 0;
        float buttonShapeY = this.Button_ParentWindow.getWindowFormContainerHeight() / 2 - 65 - this.Element_Height / 2;
        float buttonShapeWidth = this.Element_Width;
        float buttonShapeHeight = this.Element_Height;


        if(this.Button_Name.equals("Save Level")) {
            this.Element_Width = 304;
            this.Element_Height = 31;
            buttonShapeWidth = this.Element_Width;
            buttonShapeHeight = this.Element_Height;
            buttonShapeX = 0;
            buttonShapeY = this.Button_ParentWindow.getWindowFormContainerHeight() / 2 - this.Element_Height / 2 - 16;
        } else if (this.Button_Name.equals("Rename Level")) {
            this.Element_Width = 304;
            this.Element_Height = 31;
            buttonShapeWidth = this.Element_Width;
            buttonShapeHeight = this.Element_Height;
            buttonShapeX = 0;
            buttonShapeY = this.Button_ParentWindow.getWindowFormContainerHeight() / 2 - this.Element_Height / 2 - 16;
        } else if(this.Button_Name.equals("Reset to defaults")){
            this.Element_Width = 650;
            this.Element_Height = 54;
            this.Element_Text_Size = 22;
            buttonShapeWidth = this.Element_Width;
            buttonShapeHeight = this.Element_Height;
            buttonShapeX = 0;
            buttonShapeY = this.Button_ParentWindow.getWindowFormContainerHeight() / 2 - this.Element_Height / 2 - 32.5f;
        } else if(this.Button_Name.equals("Back")) {
            this.Element_Width = 650;
            this.Element_Height = 54;
            this.Element_Text_Size = 22;
            buttonShapeWidth = this.Element_Width;
            buttonShapeHeight = this.Element_Height;
            buttonShapeX = 0;
            buttonShapeY = this.Button_ParentWindow.getWindowFormContainerHeight() / 2 - this.Element_Height / 2 - 32.5f;
        } else if(this.Button_Name.equals("Prev Page") || this.Button_Name.equals("Delete Level")) {
            buttonShapeX = -this.Button_ParentWindow.getWindowFormContainerWidth() / 2 + this.Element_Width / 2 + 17;
        } else if(this.Button_Name.equals("Next Page") || this.Button_Name.equals("Load Level")) {
            buttonShapeX = this.Button_ParentWindow.getWindowFormContainerWidth() / 2 - this.Element_Width / 2 - 17;
        } else if(this.Button_Name.equals("Navigation & Controls")) {
            this.Element_Width = 650;
            this.Element_Height = 54;
            this.Element_Text_Size = 22;
            buttonShapeWidth = this.Element_Width;
            buttonShapeHeight = this.Element_Height;
            buttonShapeX = 0;
            buttonShapeY = -this.Button_ParentWindow.getWindowFormContainerHeight() / 2 + 1*(this.Element_Height + 30) + this.Element_Height / 2 + 40;
        } else if(this.Button_Name.equals("Pen tool & Properties editor")) {
            this.Element_Width = 650;
            this.Element_Height = 54;
            this.Element_Text_Size = 22;
            buttonShapeWidth = this.Element_Width;
            buttonShapeHeight = this.Element_Height;
            buttonShapeX = 0;
            buttonShapeY = -this.Button_ParentWindow.getWindowFormContainerHeight() / 2 + 2*(this.Element_Height + 30) + this.Element_Height / 2 + 40;
        } else if(this.Button_Name.equals("Rigidbody tools")) {
            this.Element_Width = 650;
            this.Element_Height = 54;
            this.Element_Text_Size = 22;
            buttonShapeWidth = this.Element_Width;
            buttonShapeHeight = this.Element_Height;
            buttonShapeX = 0;
            buttonShapeY = -this.Button_ParentWindow.getWindowFormContainerHeight() / 2 + 3*(this.Element_Height + 30) + this.Element_Height / 2 + 40;

        } else if(this.Button_Name.equals("Force tools")) {
            this.Element_Width = 650;
            this.Element_Height = 54;
            this.Element_Text_Size = 22;
            buttonShapeWidth = this.Element_Width;
            buttonShapeHeight = this.Element_Height;
            buttonShapeX = 0;
            buttonShapeY = -this.Button_ParentWindow.getWindowFormContainerHeight() / 2 + 4*(this.Element_Height + 30) + this.Element_Height / 2 + 40;

        } else if(this.Button_Name.equals("Settings")) {
            this.Element_Width = 650;
            this.Element_Height = 54;
            this.Element_Text_Size = 22;
            buttonShapeWidth = this.Element_Width;
            buttonShapeHeight = this.Element_Height;
            buttonShapeX = 0;
            buttonShapeY = -this.Button_ParentWindow.getWindowFormContainerHeight() / 2 + 5*(this.Element_Height + 30) + this.Element_Height / 2 + 40;
        } else if(this.Button_Name.equals("Creations")) {
            this.Element_Width = 650;
            this.Element_Height = 54;
            this.Element_Text_Size = 22;
            buttonShapeWidth = this.Element_Width;
            buttonShapeHeight = this.Element_Height;
            buttonShapeX = 0;
            buttonShapeY = -this.Button_ParentWindow.getWindowFormContainerHeight() / 2 + 6*(this.Element_Height + 30) + this.Element_Height / 2 + 40;
        } else if(this.Button_Name.equals("FAQ")) {
            this.Element_Width = 650;
            this.Element_Height = 54;
            this.Element_Text_Size = 22;
            buttonShapeWidth = this.Element_Width;
            buttonShapeHeight = this.Element_Height;
            buttonShapeX = 0;
            buttonShapeY = -this.Button_ParentWindow.getWindowFormContainerHeight() / 2 + this.Element_Height / 2f + 40;
        } else if(numElements == 2) {
            this.Element_Width = 304;
            this.Element_Height = 31;
            buttonShapeWidth = this.Element_Width;
            buttonShapeHeight = this.Element_Height;
            buttonShapeX = 0;
            buttonShapeY = this.Button_ParentWindow.getWindowFormContainerHeight() / 2 - this.Element_Height / 2 - 16;
        } 


        PShape Button_Shape_Base = createShape(RECT, buttonShapeX, buttonShapeY, buttonShapeWidth, buttonShapeHeight, 12);
            Button_Shape_Base.setName("Button_Shape_Base");
            if(!this.Button_State) {
                Button_Shape_Base.setStrokeWeight(this.Element_Stroke_Weight);
                Button_Shape_Base.setFill(this.Element_Base_Unselected_Color);
                Button_Shape_Base.setStroke(this.Element_Base_Unselected_Stroke_Color);
            } else {
                Button_Shape_Base.setStrokeWeight(this.Element_Stroke_Weight);
                Button_Shape_Base.setFill(this.Element_Base_Selected_Color);
                Button_Shape_Base.setStroke(this.Element_Base_Selected_Stroke_Color);
            }

        PShape Button_Shape_Listener = UI_Constants.createElementListener(Button_Shape_Base);
            Button_Shape_Listener.setName("Button_Shape_Listener");

        this.Button_Shape_Group.addChild(Button_Shape_Base);
        this.Button_Shape_Group.addChild(Button_Shape_Listener);
    }

    @Override 
    public void createElementText() {
        textFont(this.Element_Font);
        textSize(this.Element_Text_Size);
        textAlign(CENTER, CENTER);

        this.Button_Name_Position_X = this.Button_Shape_Group.getChild("Button_Shape_Base").getParam(0);
        this.Button_Name_Position_Y = this.Button_Shape_Group.getChild("Button_Shape_Base").getParam(1) - (textAscent() - textDescent()) * UI_Constants.GLOBAL_TEXT_ALIGN_FACTOR_Y;
    }

    

/*
======================================= Toggle Interaction =========================================
*/  
    @Override
    public boolean onMousePress() {
        float x = mouseX - this.Button_ParentWindow.getWindowPosition().x;
        float y = mouseY - this.Button_ParentWindow.getWindowPosition().y;

        if(this.Button_Shape_Group.getChild("Button_Shape_Listener").contains(x, y)) {
            if(this.Button_Name.equals("Save Level")) {
                if(this.Button_State) {
                    this.onDeselect();
                } else {
                    this.onSelect();
                }
            } else {
                this.onSelect();
            }
            return true;
        } else {
            return false;
        }
    }

    @Override 
    public void onMouseRelease() {
        if(this.Button_ParentWindow instanceof UI_HelpWindow && this.Button_State) {
            UI_HelpWindow helpWindow = (UI_HelpWindow) this.Button_ParentWindow;
            helpWindow.onButtonPress(this.Button_Name);
            this.onDeselect();
        }

        if(this.Button_Name.equals("Prev Page") && this.Button_State) {
            UI_CreationWindow creationWindow = (UI_CreationWindow) this.Button_ParentWindow;
                creationWindow.onFileDecrement();
            this.onDeselect();

        } else if(this.Button_Name.equals("Next Page") && this.Button_State) {
            UI_CreationWindow creationWindow = (UI_CreationWindow) this.Button_ParentWindow;
                creationWindow.onFileIncrement();
            this.onDeselect();
        } else if(this.Button_Name.equals("Load Level") && this.Button_State) {
            UI_CreationWindow creationWindow = (UI_CreationWindow) this.Button_ParentWindow;
                creationWindow.onLevelLoad();
            this.onDeselect();
        } else if(this.Button_Name.equals("Delete Level") && this.Button_State) {
            UI_CreationWindow creationWindow = (UI_CreationWindow) this.Button_ParentWindow;
                creationWindow.onLevelDelete();
            this.onDeselect();
        } else if(this.Button_Name.equals("Rename Level") && this.Button_State) {
            UI_CreationWindow creationWindow = (UI_CreationWindow) this.Button_ParentWindow;
                creationWindow.onRenameLevelSelect();
            this.onDeselect();
        } else if(this.Button_Name.equals("Reset to defaults") && this.Button_State) {
            UI_SettingsWindow settingsWindow = (UI_SettingsWindow) this.Button_ParentWindow;
            settingsWindow.onResetButtonPressed();
            this.onDeselect();
        }
    }

    @Override
    public void onMouseDrag() {
        
    }
    

    @Override
    public void onSelect() {
        this.Button_State = true;

        this.Button_Shape_Group.getChild("Button_Shape_Base").setStroke(this.Element_Base_Selected_Stroke_Color);
        this.Button_Shape_Group.getChild("Button_Shape_Base").setFill(this.Element_Base_Selected_Color);
    }


    @Override
    public void onDeselect() {
        this.Button_State = false;

        this.Button_Shape_Group.getChild("Button_Shape_Base").setStroke(this.Element_Base_Unselected_Stroke_Color);
        this.Button_Shape_Group.getChild("Button_Shape_Base").setFill(this.Element_Base_Unselected_Color);
    }

/*
===================================== Toggle Draw ==================================================
*/

    @Override
    public void drawText() {
        fill(this.Element_Text_Color);
        textFont(this.Element_Font);
        textSize(this.Element_Text_Size);
        textAlign(CENTER, CENTER);
        text(this.Button_Name, this.Button_Name_Position_X, this.Button_Name_Position_Y);

    }


/*
======================================= Toggle Getters and Setters =================================
*/  
    @Override   
    public String getElementName() {
        return this.Button_Name;
    }

    @Override
    public PShape getShape() {
        return this.Button_Shape_Group;
    }

    @Override
    public boolean getState() {
        return this.Button_State;
    }
    @Override
    public String getGroupName() {
        return null;
    }

    @Override 
    public float getValue() {
        return 0;
    }

    @Override
    public void setValue(float value) {
        return;
    }

    @Override
    public void incrementValue(float amount) {

    }

    @Override
    public void setState(boolean state) {
        if(state) {
            this.onSelect();
        } else {
            this.onDeselect();
        }
    }

}   
public class UI_Constants {
/*---------------------------------------- Color -------------------------------------------------*/
    public final int BLUE_UNSELECTED = color(2, 60, 89);
    public final int BLUE_SELECTED = color(0, 123, 185);
    public final int GRAY_600 = color(22, 23, 23);
    public final int GRAY_500 = color(34, 35, 36);
    public final int GRAY_400 = color(44, 44, 47);
    public final int GRAY_300 = color(82, 82, 82);
    public final int GRAY_250 = color(107, 107, 107);
    public final int GRAY_200 = color(120, 120, 120);
    public final int GRAY_150 = color(158, 158, 158);
    public final int GRAY_100 = color(164, 164, 164);
    public final int GRAY_50 = color(176, 176, 176);
    public final int GRAY_25 = color(183, 183, 183);
    public final int GRAY_10 = color(196, 196, 196);
    public final int WHITE = color(255, 255, 255);
    public final int TRANSPARENT = color(0, 0, 0, 0);

/*---------------------------------------- Font -------------------------------------------------*/
    public final PFont INTER_BOLD = createFont(sketchPath() + "/data/fonts/Inter-Bold.ttf", 48, TEXT_SMOOTHING);
    public final PFont INTER_MEDIUM = createFont(sketchPath() + "/data/fonts/Inter-Medium.ttf", 48, TEXT_SMOOTHING);
    public final PFont INTER_REGULAR = createFont(sketchPath() + "/data/fonts/Inter-Regular.ttf", 48, TEXT_SMOOTHING);

    // public final PFont INTER_BOLD = createFont(sketchPath() + "/data/fonts/Inter-Bold.ttf", 48, this.SMOOTHING);
    // public final PFont INTER_MEDIUM = createFont(sketchPath() + "/data/fonts/Inter-Medium.ttf", 48, this.SMOOTHING);
    // public final PFont INTER_REGULAR = createFont(sketchPath() + "/data/fonts/Inter-Regular.ttf", 48, this.SMOOTHING);

    public final PFont[] FONTS = {INTER_BOLD, INTER_MEDIUM, INTER_REGULAR};

/*------------------------------------------ Tab -------------------------------------------------*/
    public final float TAB_WIDTH = 355;
    public final float TAB_HEIGHT = 40; 

    public final float TAB_PADDING_Y = 12;
    public final float TAB_POSITION_X = displayWidth / 2;

    public final float TAB_POSITION_Y = TAB_PADDING_Y + TAB_HEIGHT / 2;

    public final int TAB_ROUNDING = 15;
    public final int TAB_FILL = GRAY_600;
    public final int TAB_STROKE = GRAY_400;

    public final int TAB_TEXT_SIZE = 16;
    public final String[] TAB_NAME = {"Settings", "Properties", "Creations", "Help"};
    public final PFont TAB_TEXT_FONT = INTER_BOLD;

    public final int TAB_TEXT_SELECTED_COLOR = WHITE;
    public final int TAB_TEXT_UNSELECTED_COLOR = GRAY_50;

    public final float TAB_STROKE_WEIGHT = 1.5f;


/*-------------------------------------- Tab Buttons ---------------------------------------------*/

    public final float TAB_BUTTON_WIDTH = 40;
    public final float TAB_BUTTON_HEIGHT = 40;

    public final float TAB_BUTTON_PADDING_X = 5;
    public final float TAB_BUTTON_POSITION_Y = TAB_POSITION_Y;

    public final float TAB_BUTTON_Q_POSITION_X = TAB_POSITION_X - TAB_WIDTH / 2 - TAB_BUTTON_WIDTH / 2 - TAB_BUTTON_PADDING_X;
    public final float TAB_BUTTON_E_POSITION_X = TAB_POSITION_X + TAB_WIDTH / 2 + TAB_BUTTON_WIDTH / 2 + TAB_BUTTON_PADDING_X;

    public final int TAB_BUTTON_ROUNDING = 15;

    public final int TAB_BUTTON_UNSELECTED_FILL = GRAY_600;
    public final int TAB_BUTTON_UNSELECTED_STROKE = GRAY_400;

    public final int TAB_BUTTON_SELECTED_FILL = GRAY_300;
    public final int TAB_BUTTON_SELECTED_STROKE = GRAY_400;

    public final float TAB_BUTTON_STROKE_WEIGHT = 1.5f;

    public final int TAB_BUTTON_TEXT_SIZE = 16;
    public final PFont TAB_BUTTON_TEXT_FONT = INTER_REGULAR;
    public final int TAB_BUTTON_TEXT_COLOR = GRAY_50;

/*-------------------------------------- Tab Selector ---------------------------------------------*/
    public final float TAB_SELECTOR_HEIGHT = 26;
    public final float TAB_SELECTOR_POSITION_Y = TAB_POSITION_Y;
    public final int TAB_SELECTOR_ROUNDING = 7;

    public final int TAB_SELECTOR_FILL = BLUE_SELECTED;
    public final boolean TAB_SELECTOR_STROKE = false;


/*-------------------------------------- HotBar ---------------------------------------------------*/
    public final int HOTBAR_SLOT_COUNT = 7;

    public final float HOTBAR_SLOT_WIDTH = 69;
    public final float HOTBAR_SLOT_HEIGHT = 69;

    public final float HOTBAR_CONTAINER_WIDTH = 567;
    public final float HOTBAR_CONTAINER_HEIGHT = 69;

    public final float HOTBAR_TOTAL_SLOT_WIDTH = HOTBAR_SLOT_WIDTH * HOTBAR_SLOT_COUNT;

    public final float HOTBAR_CONTAINER_POSITION_X = displayWidth / 2;

    public final float HOTBAR_CONTAINER_POSITION_Y;

    public final int HOTBAR_SLOT_ROUNDING = 10;

    public final int HOTBAR_SLOT_UNSELECTED_COLOR = GRAY_600;
    public final int HOTBAR_SLOT_UNSELECTED_STROKE = GRAY_400;

    public final int HOTBAR_SLOT_SELECTED_COLOR = BLUE_UNSELECTED;
    public final int HOTBAR_SLOT_SELECTED_STROKE = BLUE_SELECTED;

    public final float HOTBAR_STROKE_WEIGHT = 1.5f;

    public final int HOTBAR_TEXT_SIZE = 16;
    public final float HOTBAR_TEXT_PADDING_X = 6;
    public final float HOTBAR_TEXT_PADDING_Y = 6;
    public final PFont HOTBAR_TEXT_FONT = INTER_BOLD;

    public final int HOTBAR_LABEL_UNSELECTED_TEXT_COLOR = GRAY_50;
    public final int HOTBAR_LABEL_SELECTED_TEXT_COLOR = WHITE;

/*------------------------------------- Window ---------------------------------------------------*/

/*
======================================== Global Constants ==========================================
*/


    public final float GLOBAL_STROKE_WEIGHT = 1.5f;
    public final float GLOBAL_TEXT_ALIGN_FACTOR_Y;

/*
======================================== Initialization ============================================
*/  

    public UI_Constants() {

    /*
    ======================================== Tab Initialization ====================================
    */
            if(System.getProperty("os.name").toLowerCase().contains("mac")) {
                if(g.getClass().getSimpleName().equals("PGraphicsFX2D")) {
                    frameRate(100);
                } else {
                    frameRate(500);
                }
                GLOBAL_TEXT_ALIGN_FACTOR_Y = 1/6f;
                HOTBAR_CONTAINER_POSITION_Y =  802;
            } else if(System.getProperty("os.name").toLowerCase().contains("windows")){
                frameRate(500);
                GLOBAL_TEXT_ALIGN_FACTOR_Y = 1/6f;
                HOTBAR_CONTAINER_POSITION_Y = 990;
            } else {
                frameRate(500);
                GLOBAL_TEXT_ALIGN_FACTOR_Y = 1/6f;
                HOTBAR_CONTAINER_POSITION_Y = 990;
            }

        
    /*
    ======================================== HotBar Initialization =============================
    */
    }

    public PShape createElementListener(PShape Element_Shape) {
        float[] Element_Params = Element_Shape.getParams();

        PShape Element_Listener = createShape();
        Element_Listener.beginShape();
            Element_Listener.vertex(Element_Params[0] - Element_Params[2] / 2, Element_Params[1] - Element_Params[3] / 2);
            Element_Listener.vertex(Element_Params[0] + Element_Params[2] / 2, Element_Params[1] - Element_Params[3] / 2);
            Element_Listener.vertex(Element_Params[0] + Element_Params[2] / 2, Element_Params[1] + Element_Params[3] / 2);
            Element_Listener.vertex(Element_Params[0] - Element_Params[2] / 2, Element_Params[1] + Element_Params[3] / 2);
        Element_Listener.endShape(CLOSE);
        Element_Listener.setFill(false);
        Element_Listener.setStroke(false);
        Element_Listener.setName("Toggle_Shape_Base_Listener");
        return Element_Listener;
    }
}
public class UI_CreationWindow extends UI_Window {



    public UI_State state = UI_State.DEFAULT;
    public UI_State previousState = UI_State.DEFAULT;


    private String currentlyLoadedLevel = "";
    private UI_FileButton activeFileButton = null;

    private int totalFiles = -1;

    private int currentPage = 0;


	public UI_CreationWindow() {
		super("Creations", 2, new PVector(338, 400), new PVector(338, 35), new PVector(338, 400 - 35), false);

        this.Window_Container.resetMatrix();
        float borderSizeX = 290;
        float borderSizeY = 242;
        float borderY = -this.Window_Form_Container_Size.y / 2 + 9 + borderSizeY / 2;

        PShape selectionBorder = createShape(RECT, 0, borderY, borderSizeX, borderSizeY, this.Window_Rounding);
            selectionBorder.setName("File_Selection_Border");
            selectionBorder.setFill(false);
            selectionBorder.setStroke(UI_Constants.GRAY_300);
            selectionBorder.setStrokeWeight(UI_Constants.GLOBAL_STROKE_WEIGHT);
        
        this.Window_Container.addChild(selectionBorder);
        
        this.Window_Container.translate(this.Window_Position.x, this.Window_Position.y);
        this.Window_Container.scale(this.Window_Scale);

        this.initializeCreationsWindow();
	}

	public void initializeCreationsWindow() {
        this.updateFileSelection(false, false, null);
        this.onFileDeselect();
    }

    public void updateFileSelection(boolean isIncrement, boolean isDecrement, UI_FileButton activeFileButton) {
        //5 elements per page
        String path = sketchPath() + "/data/LevelSaves/";
        File[] allFiles = new File(path).listFiles();
        
        //Sorts files to be most recent modified ontop 

        File[] saveFiles = Arrays.stream(allFiles)
            .filter(file -> file.getName().endsWith(".json"))
            .toArray(File[]::new);
        Arrays.sort(saveFiles, Comparator.comparingLong(File::lastModified).reversed());

        this.totalFiles = saveFiles.length;

        if(isIncrement) {
            if((this.currentPage + 1) * 5 < saveFiles.length) {
                this.currentPage++;
            }
        }

        if(isDecrement) {
            if(this.currentPage > 0) {
                this.currentPage--;
            }
        }

        int start = this.currentPage * 5;
        int end;

        if((currentPage + 1) * 5 > saveFiles.length) {
            end = saveFiles.length;
        } else {
            end = (currentPage + 1) * 5;
        }

        for(int i = start; i < end; i++) {

            UI_FileButton fileButton = new UI_FileButton(saveFiles[i], 
                                                        saveFiles[i].getName().substring(0, saveFiles[i].getName().indexOf(".json")), 
                                                        this, "FileGroup", false, saveFiles[i].getAbsolutePath());
            if(activeFileButton != null) {
                if(fileButton.equals(activeFileButton)) {

                }

                if(this.state == UI_State.RENAME_LEVEL) {
                    if(fileButton.equals(activeFileButton)) {
                        fileButton.FileButton_ShowName = false;
                    }
                }
            } 

            this.addElement(fileButton);
        }

    }   


    public void onFileSelect() {
        this.clearAllElements();
        this.updateFileSelection(false, false, this.activeFileButton);
        this.addElement(new UI_Button("Delete Level", this, false));
        this.addElement(new UI_Button("Load Level", this, false));
        this.addElement(new UI_Button("Rename Level", this, false));
    }

    public void onFileDeselect() {
        this.clearAllElements();
        this.updateFileSelection(false, false, null);

        if(this.totalFiles > 5) {
            if(this.currentPage > 0) {
                this.addElement(new UI_Button("Prev Page", this, false));
            }
            if((this.currentPage + 1) * 5 < this.totalFiles) {
                this.addElement(new UI_Button("Next Page", this, false));
            }
        }

        this.addElement(new UI_Button("Save Level", this, false));

    }

    public void onLevelSaved() {

        this.saveLevelState();
        this.state = UI_State.DEFAULT;

        this.clearAllElements();
        this.currentPage = 0;
        this.updateFileSelection(false, false, null);

        if(this.totalFiles > 5) {
            if(this.currentPage > 0) {
                this.addElement(new UI_Button("Prev Page", this, false));
            }
            if((this.currentPage + 1) * 5 < this.totalFiles) {
                this.addElement(new UI_Button("Next Page", this, false));
            }
        }

        this.addElement(new UI_Button("Save Level", this, false));
    }

    public void onLevelLoad() {
        this.loadLevelState();
        this.currentPage = 0;
        this.onFileDeselect();
    }

    public void onLevelDelete() {
        this.activeFileButton.deleteFile();
        this.onFileDeselect();
    }


    public void onFileDecrement() {
        this.clearAllElements();
        this.updateFileSelection(false, true, null);

        if(this.totalFiles > 5) {
            if(this.currentPage > 0) {
                this.addElement(new UI_Button("Prev Page", this, false));
            }
            if((this.currentPage + 1) * 5 < this.totalFiles) {
                this.addElement(new UI_Button("Next Page", this, false));
            }
        }

        this.addElement(new UI_Button("Save Level", this, false));
    }

    public void onFileIncrement() {
        this.clearAllElements();
        this.updateFileSelection(true, false, null);

        if(this.totalFiles > 5) {
            if(this.currentPage > 0) {
                this.addElement(new UI_Button("Prev Page", this, false));
            }
            if((this.currentPage + 1) * 5 < this.totalFiles) {
                this.addElement(new UI_Button("Next Page", this, false));
            }
        }

        this.addElement(new UI_Button("Save Level", this, false));
    }

    public void onRenameLevelSelect() {
        this.state = UI_State.RENAME_LEVEL;

        this.clearAllElements();
        this.updateFileSelection(false, false, this.activeFileButton);

        this.state = UI_State.FILE_SELECTED;

        this.addElement(new UI_Button("Rename Level", this, true));

        float[] params = this.activeFileButton.FileButton_Shape_Group.getChild("FileButton_Shape_Base").getParams();

        UI_TextField renameLevel = new UI_TextField("Rename Level TextField", this, params[0], params[1], params[2], params[3], true);
        renameLevel.TextField_Text = this.activeFileButton.FileButton_Name;
        renameLevel.TextField_TextLength = this.activeFileButton.FileButton_Name.length();
        renameLevel.TextField_ShowName = false;
        this.addElement(renameLevel);
    }

    public void onLevelRenamed() {
        this.activeFileButton.renameFile(this.getFileButtonToRenameTextField().TextField_Text);
        this.state = UI_State.DEFAULT;

        this.clearAllElements();
        this.updateFileSelection(false, false, null);

        if(this.totalFiles > 5) {
            if(this.currentPage > 0) {
                this.addElement(new UI_Button("Prev Page", this, false));
            }
            if((this.currentPage + 1) * 5 < this.totalFiles) {
                this.addElement(new UI_Button("Next Page", this, false));
            }
        }

        this.addElement(new UI_Button("Save Level", this, false));
    }

    public void onSaveLevelSelect() {
        this.clearAllElements();
        this.updateFileSelection(false, false, null);
        
        float params[] = this.Window_Container.getChild("File_Selection_Border").getParams();
        float TextField_Position_X = 0;
        float TextField_Position_Y = params[1] + params[3] / 2 + 16 + 31/2;

        this.addElement(new UI_TextField("Level Name", this, TextField_Position_X, TextField_Position_Y));
        this.addElement(new UI_Button("Save Level", this, true));
    }


    @Override
    public void interactionDraw() {
        if(UI_Manager.getTabBar().getActiveTabID() == 2) {
            this.lockSelected();
        }   
    }

    @Override
    public void interactionMousePress() {

    }

    @Override
    public void interactionMouseRelease() {
        if(UI_Manager.getTabBar().getActiveTabID() == 2) { 
            this.checkWindowElements();
            this.updateState();
        }
    }

    @Override
    public void interactionMouseClick() {

    }

    @Override
    public void onWindowSelect() {
        this.deselectAllWindows();
        this.isActiveWindow = true;
        this.Window_Visibility = true;
        UI_Manager.bringToFront(this);
        this.Window_Container.getChild("Window_Container_Stroke").setStroke(UI_Constants.BLUE_SELECTED);
        this.Window_Container.getChild("Window_Text_Container").setFill(UI_Constants.BLUE_UNSELECTED);
    }


    
    public void lockSelected() {
        this.isActiveWindow = true;
        this.Window_Visibility = true;
        UI_Manager.getHotBar().setActiveSlotID(-1);
        //this.updateFileSelection();
        this.Window_Container.getChild("Window_Container_Stroke").setStroke(UI_Constants.BLUE_SELECTED);
        this.Window_Container.getChild("Window_Text_Container").setFill(UI_Constants.BLUE_UNSELECTED);
    }

    public void open() {
        this.deselectAllWindows();
        this.isActiveWindow = true;
        this.Window_Visibility = true;
        UI_Manager.bringToFront(this);
        this.Window_Container.getChild("Window_Container_Stroke").setStroke(UI_Constants.BLUE_SELECTED);
        this.Window_Container.getChild("Window_Text_Container").setFill(UI_Constants.BLUE_UNSELECTED);
        this.initializeCreationsWindow();
    }


    private UI_TextField getTextField() {
        for(UI_Element element : this.Window_Elements) {
            if(element instanceof UI_TextField && element.getElementName().equals("Level Name")) {
                return (UI_TextField)element;
            }
        }
        return null;
    }

    private UI_TextField getFileButtonToRenameTextField() {
        for(UI_Element element : this.Window_Elements) {
            if(element instanceof UI_TextField && element.getElementName().equals("Rename Level TextField")) {
                return (UI_TextField)element;
            }
        }
        return null;
    }

	@Override
	public void onKeyPress(int keyCode) {
        // if(this.state == UI_State.SAVE_LEVEL) {
        //     UI_TextField textField = this.getTextField();
        //     if(textField != null && textField.keyPress(keyCode)) {
        //         //Returns true if enter is pressed, so once this returns true save the level with the name of the text inside
        //     }
        // }

		switch(keyCode) {
			case KeyEvent.VK_Z:
				this.saveLevelState();
                break;
			case KeyEvent.VK_X:
				this.loadLevelState();
                break;
            case KeyEvent.VK_LEFT:
                this.onFileDecrement();
                break;
            case KeyEvent.VK_RIGHT:
                this.onFileIncrement();
                break;
        }

	}


    public void updateState() {
        if(this.state == this.previousState) {
            return;
        }

        switch(this.state) {
            case DEFAULT:
                this.onFileDeselect();
                break;
            case FILE_SELECTED:
                this.onFileSelect();
                break;
            case SAVE_LEVEL:
                this.onSaveLevelSelect();
                break;
        }

        this.previousState = this.state;
    }

    public void redrawState() {
        switch(this.state) {
            case DEFAULT:
                this.onFileDeselect();
                break;
            case FILE_SELECTED:
                this.onFileSelect();
                break;
            case SAVE_LEVEL:
                this.onSaveLevelSelect();
                break;
        }
    }


   
    public void checkWindowElements() {
        for(UI_Element element : this.Window_Elements) {
            if(element instanceof UI_FileButton) {
                if(element.getState()) {
                    this.activeFileButton = (UI_FileButton)element;
                    this.state = UI_State.FILE_SELECTED;
                    return;
                }
            }

            if(element instanceof UI_Button) {
                if(element.getElementName().equals("Save Level") && element.getState()) {
                    this.state = UI_State.SAVE_LEVEL;
                    return;
                } else if(element.getElementName().equals("Save Level") && !element.getState()) {
                    this.state = UI_State.DEFAULT;
                    return;
                }
            }   
        }

        this.activeFileButton = null;
        this.state = UI_State.DEFAULT;
    }

/*
=========================================== Level Loading & Saving =============================================
*/
	public void loadLevelState() {
		IS_PAUSED = true;
		JSONArray rigidbodyArray = loadJSONArray(this.activeFileButton.FilePath);
        this.currentlyLoadedLevel = this.activeFileButton.FileButton_Name;

		ALL_FORCES_ARRAYLIST.clear();
		rigidbodyList.clear();

		for(int i = 0; i < rigidbodyArray.size()-1; i++) {
			JSONObject rigidbodyJSON = rigidbodyArray.getJSONObject(i);
			Rigidbody rigidbody = this.deserializeRigidbody(rigidbodyJSON);
			rigidbody.addForceToForceRegistry(new Gravity(rigidbody));
			rigidbodyList.add(rigidbody);

		}

		JSONArray forcesArray = rigidbodyArray.getJSONArray(rigidbodyArray.size() - 1);

		for(int i = 0; i < forcesArray.size(); i++) {
			Spring spring = null;
			Rod rod = null;
			Motor motor = null;
			Gravity gravity = null;

			JSONObject forceJSON = forcesArray.getJSONObject(i);

			if(forceJSON.getString("ForceType").equals("Spring")){
				spring = this.deserializeSpring(forceJSON);
			} else if (forceJSON.getString("ForceType").equals("Rod")) {
				rod = this.deserializeRod(forceJSON);
			} else if (forceJSON.getString("ForceType").equals("Motor")) {
				motor = this.deserializeMotor(forceJSON);
			} else if(forceJSON.getString("ForceType").equals("Gravity")) {
				gravity = this.deserializeGravity(forceJSON);
			}

			if(spring != null) {
				if(spring.getIsTwoBodySpring()) {
					spring.getRigidbodyA().addForceToForceRegistry(spring);
					spring.getRigidbodyB().addForceToForceRegistry(spring);
					ALL_FORCES_ARRAYLIST.add(spring);
				} else {
					spring.getRigidbodyA().addForceToForceRegistry(spring);
					ALL_FORCES_ARRAYLIST.add(spring);
				}
			} else if(rod != null) {
				if(rod.getTwoBodyRod()) {
					rod.getRigidbodyA().addForceToForceRegistry(rod);
					rod.getRigidbodyB().addForceToForceRegistry(rod);

					if(rod.getIsJoint()) {
						rod.getRigidbodyA().addBodyToCollisionExclusionList(rod.getRigidbodyB());
						rod.getRigidbodyB().addBodyToCollisionExclusionList(rod.getRigidbodyA());
					}
					ALL_FORCES_ARRAYLIST.add(rod);
				} else {
					rod.getRigidbodyA().addForceToForceRegistry(rod);
					ALL_FORCES_ARRAYLIST.add(rod);
				}
			} else if(motor != null) {
				motor.getRigidbodyA().addForceToForceRegistry(motor);
				ALL_FORCES_ARRAYLIST.add(spring);

			} else if(gravity != null) {
				gravity.getRigidbodyA().addForceToForceRegistry(gravity);
				ALL_FORCES_ARRAYLIST.add(gravity);
			}
		}
		IS_PAUSED = false;
	}

	public void saveLevelState() {
		JSONArray rigidbodyArray = new JSONArray();

		for(Rigidbody body : rigidbodyList) {

			String ID = body.getID();

			/*---------------- Main Rigidbody JSON Object --------------*/
			JSONObject rigidbodyJSON = new JSONObject();
			/*----------------------------------------------------------*/

			JSONObject IDJSON = new JSONObject();
					IDJSON.setString("ID", ID);
				rigidbodyJSON.setJSONObject("RigidbodyID", IDJSON);

			JSONObject positionAndVelocityJSON = new JSONObject();
					positionAndVelocityJSON.setJSONObject("position", this.serialize2DPVector(body.getPosition()));
					positionAndVelocityJSON.setJSONObject("velocity", this.serialize2DPVector(body.getVelocity()));
				rigidbodyJSON.setJSONObject("positionAndVelocity", positionAndVelocityJSON);


			JSONObject angleAndAngularVelocityJSON = new JSONObject();
					angleAndAngularVelocityJSON.setFloat("angle", body.getAngle());
					angleAndAngularVelocityJSON.setFloat("angularVelocity", body.getAngularVelocity());
				rigidbodyJSON.setJSONObject("angleAndAngularVelocity", angleAndAngularVelocityJSON);

			JSONObject shapeTypeJSON = new JSONObject();
					shapeTypeJSON.setString("shapeType", body.getShapeType().name());
				rigidbodyJSON.setJSONObject("shapeType", shapeTypeJSON);

			JSONObject densityAndRestitutionJSON = new JSONObject();
					densityAndRestitutionJSON.setFloat("density", body.getDensity());
					densityAndRestitutionJSON.setFloat("restitution", body.getRestitution());
				rigidbodyJSON.setJSONObject("densityAndRestitution", densityAndRestitutionJSON);

			JSONObject geometryJSON = new JSONObject();
					JSONArray verticesArray = serializePVectorArray(body.getVertices());
					geometryJSON.setJSONArray("vertices", verticesArray);
					geometryJSON.setFloat("radius", body.getRadius());
					geometryJSON.setFloat("width", body.getWidth());
					geometryJSON.setFloat("height", body.getHeight());
				rigidbodyJSON.setJSONObject("geometry", geometryJSON);

		JSONObject frictionJSON = new JSONObject();
				frictionJSON.setFloat("coeffOfStaticFriction", body.getCoefficientOfStaticFriction());
				frictionJSON.setFloat("coeffOfKineticFriction", body.getCoefficientOfKineticFriction());
			rigidbodyJSON.setJSONObject("friction", frictionJSON);

		JSONObject staticityJSON = new JSONObject();
				staticityJSON.setBoolean("isStatic", body.getIsStatic());
				staticityJSON.setBoolean("isTranslationallyStatic", body.getIsTranslationallyStatic());
				staticityJSON.setBoolean("isRotationallyStatic", body.getIsRotationallyStatic());
			rigidbodyJSON.setJSONObject("staticity", staticityJSON);

		JSONObject drawingPropertiesJSON = new JSONObject();
				drawingPropertiesJSON.setFloat("strokeWeight", body.getStrokeWeight());
				drawingPropertiesJSON.setJSONObject("strokeColour", serialize3DPVector(body.getStrokeColour()));
				drawingPropertiesJSON.setJSONObject("fillColour", serialize3DPVector(body.getFillColour()));
			rigidbodyJSON.setJSONObject("drawingProperties", drawingPropertiesJSON);

		JSONObject visibilityAndCollidabilityJSON = new JSONObject();
				visibilityAndCollidabilityJSON.setBoolean("visibility", body.getIsVisible());
				visibilityAndCollidabilityJSON.setBoolean("collidability", body.getCollidability());
			rigidbodyJSON.setJSONObject("visibilityAndCollidability", visibilityAndCollidabilityJSON);


			rigidbodyArray.append(rigidbodyJSON);
		}

		rigidbodyArray.append(this.serializeForces());

		saveJSONArray(rigidbodyArray, sketchPath() + "/data/LevelSaves/" + this.getTextField().TextField_Text + ".json");
	}

	private JSONArray serializeForces() {
			JSONArray forcesArray = new JSONArray();

			for(int i = 0; i < ALL_FORCES_ARRAYLIST.size(); i++) {
				JSONObject forceJSON = new JSONObject();
				ForceRegistry force = ALL_FORCES_ARRAYLIST.get(i);

				if(force instanceof Spring) {
					forceJSON = serializeSpring((Spring)force);
				} else if(force instanceof Rod) {
					forceJSON = serializeRod((Rod)force);
				} else if(force instanceof Motor) {
					forceJSON = serializeMotor((Motor)force);
				} else if(force instanceof Gravity) {
					forceJSON = serializeGravity((Gravity)force);
				}
				forcesArray.append(forceJSON);
			}
			return forcesArray;
	}


	private Rigidbody deserializeRigidbody(JSONObject rigidbodyJSON) {
		Rigidbody rigidbody;
		ShapeType shapeType = this.deserializeShapeType(rigidbodyJSON.getJSONObject("shapeType"));

		if(shapeType == ShapeType.CIRCLE) {
			rigidbody = RigidbodyGenerator.CreateCircleBody(rigidbodyJSON.getJSONObject("geometry").getFloat("radius"),
															rigidbodyJSON.getJSONObject("densityAndRestitution").getFloat("density"),
															rigidbodyJSON.getJSONObject("densityAndRestitution").getFloat("restitution"),
															rigidbodyJSON.getJSONObject("staticity").getBoolean("isStatic"),
															rigidbodyJSON.getJSONObject("visibilityAndCollidability").getBoolean("collidability"),
															rigidbodyJSON.getJSONObject("drawingProperties").getFloat("strokeWeight"),
															this.deserialize3DPVector(rigidbodyJSON.getJSONObject("drawingProperties").getJSONObject("strokeColour")),
															this.deserialize3DPVector(rigidbodyJSON.getJSONObject("drawingProperties").getJSONObject("fillColour")));

		} else {
			rigidbody = RigidbodyGenerator.CreatePolygon(this.deserializePVectorArray(rigidbodyJSON.getJSONObject("geometry").getJSONArray("vertices")),
															rigidbodyJSON.getJSONObject("densityAndRestitution").getFloat("density"),
															rigidbodyJSON.getJSONObject("densityAndRestitution").getFloat("restitution"),
															rigidbodyJSON.getJSONObject("staticity").getBoolean("isStatic"),
															rigidbodyJSON.getJSONObject("staticity").getBoolean("isTranslationallyStatic"),
															rigidbodyJSON.getJSONObject("staticity").getBoolean("isRotationallyStatic"),
															rigidbodyJSON.getJSONObject("visibilityAndCollidability").getBoolean("collidability"),
															rigidbodyJSON.getJSONObject("drawingProperties").getFloat("strokeWeight"),
															this.deserialize3DPVector(rigidbodyJSON.getJSONObject("drawingProperties").getJSONObject("strokeColour")),
															this.deserialize3DPVector(rigidbodyJSON.getJSONObject("drawingProperties").getJSONObject("fillColour")));
		}

			rigidbody.setID(rigidbodyJSON.getJSONObject("RigidbodyID").getString("ID"));
			rigidbody.setIsStatic(rigidbodyJSON.getJSONObject("staticity").getBoolean("isStatic"));
			rigidbody.setIsTranslationallyStatic(rigidbodyJSON.getJSONObject("staticity").getBoolean("isTranslationallyStatic"));
			rigidbody.setIsRotationallyStatic(rigidbodyJSON.getJSONObject("staticity").getBoolean("isRotationallyStatic"));

			rigidbody.SetInitialPosition(this.deserialize2DPVector(rigidbodyJSON.getJSONObject("positionAndVelocity").getJSONObject("position")));
			rigidbody.setVelocity(this.deserialize2DPVector(rigidbodyJSON.getJSONObject("positionAndVelocity").getJSONObject("velocity")));
			rigidbody.setAngle(rigidbodyJSON.getJSONObject("angleAndAngularVelocity").getFloat("angle"));
			rigidbody.setAngularVelocity(rigidbodyJSON.getJSONObject("angleAndAngularVelocity").getFloat("angularVelocity"));


			return rigidbody;
	}

	private Spring deserializeSpring(JSONObject springJSON) {

		boolean isTwoBodySpring = springJSON.getBoolean("isTwoBodySpring");
		if(isTwoBodySpring) {
			Rigidbody rigidbodyA = this.getRigidbodyByID(springJSON.getString("rigidbodyAID"));
			Rigidbody rigidbodyB = this.getRigidbodyByID(springJSON.getString("rigidbodyBID"));


			PVector localAnchorA = this.deserialize2DPVector(springJSON.getJSONObject("localAnchorA"));
			PVector localAnchorB = this.deserialize2DPVector(springJSON.getJSONObject("localAnchorB"));

			Spring spring = new Spring(rigidbodyA, rigidbodyB, localAnchorA, localAnchorB);

			spring.setSpringConstant(springJSON.getFloat("springConstant"));
			spring.setEquilibriumLength(springJSON.getFloat("equilibriumLength"));
			spring.setDamping(springJSON.getFloat("damping"));
			spring.setDrawSpring(springJSON.getBoolean("drawSpring"));
			spring.setLockTranslationToXAxis(springJSON.getBoolean("lockTranslationToXAxis"));
			spring.setLockTranslationToYAxis(springJSON.getBoolean("lockTranslationToYAxis"));
			spring.setPerfectSpring(springJSON.getBoolean("isPerfectSpring"));
			spring.setSpringLength(springJSON.getFloat("springLength"));

			return spring;
		} else {
			Rigidbody rigidbodyA = this.getRigidbodyByID(springJSON.getString("rigidbodyAID"));
			PVector localAnchorA = this.deserialize2DPVector(springJSON.getJSONObject("localAnchorA"));
			PVector anchorPoint = this.deserialize2DPVector(springJSON.getJSONObject("anchorPoint"));

			Spring spring = new Spring(rigidbodyA, localAnchorA, anchorPoint);
			spring.setSpringConstant(springJSON.getFloat("springConstant"));
			spring.setEquilibriumLength(springJSON.getFloat("equilibriumLength"));
			spring.setDamping(springJSON.getFloat("damping"));
			spring.setDrawSpring(springJSON.getBoolean("drawSpring"));
			spring.setLockTranslationToXAxis(springJSON.getBoolean("lockTranslationToXAxis"));
			spring.setLockTranslationToYAxis(springJSON.getBoolean("lockTranslationToYAxis"));
			spring.setPerfectSpring(springJSON.getBoolean("isPerfectSpring"));
			spring.setSpringLength(springJSON.getFloat("springLength"));

			return spring;
		}
	}

	private Rod deserializeRod(JSONObject rodJSON) {
			boolean isTwoBodyRod = rodJSON.getBoolean("isTwoBodyRod");
			if(isTwoBodyRod) {
					Rigidbody rigidbodyA = this.getRigidbodyByID(rodJSON.getString("rigidbodyAID"));
					Rigidbody rigidbodyB = this.getRigidbodyByID(rodJSON.getString("rigidbodyBID"));

					PVector localAnchorA = this.deserialize2DPVector(rodJSON.getJSONObject("localAnchorA"));
					PVector localAnchorB = this.deserialize2DPVector(rodJSON.getJSONObject("localAnchorB"));

					Rod rod = new Rod(rigidbodyA, rigidbodyB, localAnchorA, localAnchorB);
					rod.setLength(rodJSON.getFloat("length"));
					rod.setDamping(rodJSON.getFloat("damping"));
					rod.setIsJoint(rodJSON.getBoolean("isJoint"));

					return rod;
			} else {
					Rigidbody rigidbodyA = this.getRigidbodyByID(rodJSON.getString("rigidbodyAID"));
					PVector localAnchorA = this.deserialize2DPVector(rodJSON.getJSONObject("localAnchorA"));
					PVector anchorPoint = this.deserialize2DPVector(rodJSON.getJSONObject("anchorPoint"));

					Rod rod = new Rod(rigidbodyA, localAnchorA, anchorPoint);
					rod.setLength(rodJSON.getFloat("length"));
					rod.setDamping(rodJSON.getFloat("damping"));
					rod.setIsJoint(rodJSON.getBoolean("isJoint"));
					return rod;
			}
	}

	private Motor deserializeMotor(JSONObject motorJSON) {
			Rigidbody rigidbody = this.getRigidbodyByID(motorJSON.getString("rigidbodyID"));

			Motor motor = new Motor(rigidbody, motorJSON.getFloat("targetAngularVelocity"));
			motor.setLocalAnchor(this.deserialize2DPVector(motorJSON.getJSONObject("localAnchor")));
			motor.setDrawMotor(motorJSON.getBoolean("drawMotor"));
			motor.setDrawMotorForce(motorJSON.getBoolean("drawMotorForce"));
			return motor;

		}

	private Gravity deserializeGravity(JSONObject gravityJSON) {
			Rigidbody rigidbody = this.getRigidbodyByID(gravityJSON.getString("rigidbodyID"));
			return new Gravity(rigidbody);
	}


	private JSONObject serializeSpring(Spring spring) {
			JSONObject springJSON = new JSONObject();

			springJSON.setString("rigidbodyAID", spring.getRigidbodyA().getID());

			if(spring.getIsTwoBodySpring()) {
					springJSON.setString("rigidbodyBID", spring.getRigidbodyB().getID());
			}

			springJSON.setString("ForceType", "Spring");
			springJSON.setFloat("springConstant", spring.getSpringConstant());
			springJSON.setFloat("equilibriumLength", spring.getEquilibriumLength());
			springJSON.setFloat("damping", spring.getDamping());

			springJSON.setJSONObject("localAnchorA", serialize2DPVector(spring.getLocalAnchorA()));
			springJSON.setJSONObject("localAnchorB", serialize2DPVector(spring.getLocalAnchorB()));
			springJSON.setJSONObject("anchorPoint", serialize2DPVector(spring.getAnchorPoint()));

			springJSON.setBoolean("drawSpring", spring.getDrawSpring());
			springJSON.setBoolean("lockTranslationToXAxis", spring.getLockTranslationToXAxis());
			springJSON.setBoolean("lockTranslationToYAxis", spring.getLockTranslationToYAxis());

			springJSON.setBoolean("isPerfectSpring", spring.getPerfectSpring());
			springJSON.setBoolean("isTwoBodySpring", spring.getIsTwoBodySpring());
			springJSON.setFloat("springLength", spring.getSpringLength());

			return springJSON;
	}

	private JSONObject serializeRod(Rod rod) {
			JSONObject rodJSON = new JSONObject();

			rodJSON.setString("rigidbodyAID", rod.getRigidbodyA().getID());
			if(rod.getTwoBodyRod()) {
					rodJSON.setString("rigidbodyBID", rod.getRigidbodyB().getID());
			}
			rodJSON.setString("ForceType", "Rod");
			rodJSON.setFloat("length", rod.getLength());
			rodJSON.setFloat("damping", rod.getDamping());

			rodJSON.setJSONObject("localAnchorA", serialize2DPVector(rod.getLocalAnchorA()));
			rodJSON.setJSONObject("localAnchorB", serialize2DPVector(rod.getLocalAnchorB()));
			rodJSON.setJSONObject("anchorPoint", serialize2DPVector(rod.getAnchorPoint()));

			rodJSON.setBoolean("isTwoBodyRod", rod.getTwoBodyRod());
			rodJSON.setBoolean("isJoint", rod.getIsJoint());

			return rodJSON;
	}

	private JSONObject serializeMotor(Motor motor) {
			JSONObject motorJSON = new JSONObject();

			motorJSON.setString("ForceType", "Motor");
			motorJSON.setString("rigidbodyID", motor.getRigidbodyA().getID());
			motorJSON.setJSONObject("localAnchor", serialize2DPVector(motor.getLocalAnchor()));
			motorJSON.setFloat("targetAngularVelocity", motor.getTargetAngularVelocity());
			motorJSON.setBoolean("drawMotorForce", motor.getDrawMotorForce());
			motorJSON.setBoolean("drawMotor", motor.getDrawMotor());
			
			return motorJSON;
	}

	private JSONObject serializeGravity(Gravity gravity) {
			JSONObject gravityJSON = new JSONObject();

			gravityJSON.setString("ForceType", "Gravity");
			gravityJSON.setString("rigidbodyID", gravity.getRigidbodyA().getID());
			return gravityJSON;
	}


	private ShapeType deserializeShapeType(JSONObject shapeTypeJSON) {
			return ShapeType.valueOf(shapeTypeJSON.getString("shapeType"));
	}

	private JSONObject serialize2DPVector(PVector vector) {
			JSONObject vectorJSON = new JSONObject();

			vectorJSON.setFloat("x", vector.x);
			vectorJSON.setFloat("y", vector.y);
			return vectorJSON;
	}

	private PVector deserialize2DPVector(JSONObject vectorJSON) {
			return new PVector(vectorJSON.getFloat("x"), vectorJSON.getFloat("y"));
	}

	private JSONObject serialize3DPVector(PVector vector) {
			JSONObject vectorJSON = new JSONObject();

			vectorJSON.setFloat("x", vector.x);
			vectorJSON.setFloat("y", vector.y);
			vectorJSON.setFloat("z", vector.z);
			return vectorJSON;
	}

	private PVector deserialize3DPVector(JSONObject vectorJSON) {
			return new PVector(vectorJSON.getFloat("x"), vectorJSON.getFloat("y"), vectorJSON.getFloat("z"));
	}


	private JSONArray serializePVectorArray(PVector[] vectors) {
			JSONArray vectorArray = new JSONArray();
			if(vectors == null || vectors.length == 0) {
				return vectorArray;
			}
			for(PVector vector : vectors) {
				vectorArray.append(this.serialize2DPVector(vector));
			}
			return vectorArray;
	}

	private PVector[] deserializePVectorArray(JSONArray vectorArrayJSON) {
			PVector[] vectorArray = new PVector[vectorArrayJSON.size()];

			for(int i = 0; i < vectorArrayJSON.size(); i++) {
				vectorArray[i] = this.deserialize2DPVector(vectorArrayJSON.getJSONObject(i));
			}
			return vectorArray;
	}


	private Rigidbody getRigidbodyByID(String id) {
			for(Rigidbody body : rigidbodyList) {
					if(body.getID().equals(id)) {
						return body;
					}
			}
		return null;
	}
/*
=================================================================================================
*/
}
public abstract class UI_Element{

    /*--------------------------------- Padding --------------------------------------------------*/

    /* Represents the padding of the element shape from the edge of the window */
    public int Element_Container_Padding_X = 10;

    /* Represents the padding of the topmost element shape from the top of the window */
    public int Element_Container_Top_Padding_Y = 19;

    /* Represents the padding of a shape from a previous shapes edge element */
    public int Element_Element_Padding_Y = 13;

    /* Represents the padding of the text from either the edge of a shape, or the edge of a subelement */
    public int Element_Text_Padding_X = 10;

    /* Represents the padding of a tickbox in a toggle from the edge of the shape */
    public int Element_Tickbox_Padding_X = 5;

    /*------------------------------- Dimensions -------------------------------------------------*/

    /* This is for regular toggles and sliders, there will be different dimensions for other elements */
    public int Element_Width = 265;
    public int Element_Height = 31;

    public int Element_Tickbox_Width = 23;
    public int Element_Tickbox_Height = 23;

    public int Element_Rounding = 5;

    /*------------------------------- Position ---------------------------------------------------*/
    /*
      Each window element will have the same x position as the window it lies in due to centering,
      so only the y position must be changed.
    */

    /*------------------------------- Text -------------------------------------------------------*/
    public String Element_Text = "Default Text";
    public String Element_Value_Text = "Default Value Text";

    public PFont Element_Font = UI_Constants.INTER_REGULAR;
    public int Element_Text_Size = 16;
    public int Element_Text_Color = UI_Constants.WHITE;

    /*------------------------------- Colour -----------------------------------------------------*/
    public int Element_Base_Unselected_Color = UI_Constants.GRAY_500;
    public int Element_Base_Unselected_Stroke_Color = UI_Constants.GRAY_400;

    public int Element_Base_Selected_Color = UI_Constants.GRAY_300;
    public int Element_Base_Selected_Stroke_Color = UI_Constants.GRAY_500;

    public float Element_Stroke_Weight = 1.5f;


    public abstract void createElementBaseShape();
    public abstract void createElementText();
    
    public abstract boolean onMousePress();
    public abstract void onMouseRelease();
    public abstract void onMouseDrag();

    public abstract void onSelect();
    public abstract void onDeselect();

    public abstract boolean getState();
    public abstract void setState(boolean state);
    public abstract float getValue();
    public abstract void setValue(float value);
    public abstract void incrementValue(float amount);
    public abstract void drawText();
    public abstract String getElementName();
    public abstract String getGroupName();
    public abstract PShape getShape();
}
public class UI_FileButton extends UI_Element {
    

    public UI_Window FileButton_ParentWindow;

    public String FileButton_Name;
    public float FileButton_Name_Position_X;
    public float FileButton_Name_Position_Y;

    public String FileButton_Group;
    public boolean FileButton_State;
    public String FilePath;

    public boolean FileButton_ShowName = true;
    public File FileButton_File;

    public PShape FileButton_Shape_Group = createShape(GROUP);



    public UI_FileButton (File FileButton_File, String FileButton_Name, UI_Window FileButton_ParentWindow, String FileButton_Group, boolean FileButton_State, String FilePath) {
        this.FileButton_Name = FileButton_Name;
        this.FileButton_State = FileButton_State;
        this.FileButton_Group = FileButton_Group;
        this.FilePath = FilePath;
        this.FileButton_File = FileButton_File;


        this.FileButton_Shape_Group.setName(this.FileButton_Name + "Group");
        this.FileButton_ParentWindow = FileButton_ParentWindow;

        this.initializeFileButton();
    }

    public void initializeFileButton() {
        rectMode(CENTER);
        this.createElementBaseShape();
        this.createElementText();
    }




/*
======================================= Button Creation ============================================
*/  
    @Override
    public void createElementBaseShape() {

        this.Element_Height = 34;
        this.Element_Width = 272;

        rectMode(CENTER);
        int numElements = this.FileButton_ParentWindow.getWindowElementArrayListSize();

        float fileButtonShapeX;
        float fileButtonShapeY;
        float fileButtonShapeWidth;
        float fileButtonShapeHeight;

        if(numElements == 0) {
            fileButtonShapeX = 0;
            fileButtonShapeY = -this.FileButton_ParentWindow.getWindowFormContainerHeight() / 2 + this.Element_Container_Top_Padding_Y + this.Element_Height / 2;
            fileButtonShapeWidth = this.Element_Width;
            fileButtonShapeHeight = this.Element_Height;
            
        } else {
            fileButtonShapeX = 0;
            fileButtonShapeY = (this.Element_Height - this.FileButton_ParentWindow.getWindowFormContainerHeight()) /2 + (this.Element_Height + this.Element_Element_Padding_Y) * numElements + this.Element_Container_Top_Padding_Y;
            fileButtonShapeWidth = this.Element_Width;
            fileButtonShapeHeight = this.Element_Height;
        }

        PShape FileButton_Shape_Base = createShape(RECT, fileButtonShapeX, fileButtonShapeY, fileButtonShapeWidth, fileButtonShapeHeight, this.Element_Rounding);
            FileButton_Shape_Base.setName("FileButton_Shape_Base");
            FileButton_Shape_Base.setStrokeWeight(this.Element_Stroke_Weight);
            FileButton_Shape_Base.setFill(this.Element_Base_Unselected_Color);
            FileButton_Shape_Base.setStroke(this.Element_Base_Unselected_Stroke_Color);

        PShape FileButton_Shape_Base_Listener = UI_Constants.createElementListener(FileButton_Shape_Base);
            FileButton_Shape_Base_Listener.setName("FileButton_Shape_Base_Listener");

        this.FileButton_Shape_Group.addChild(FileButton_Shape_Base);
        this.FileButton_Shape_Group.addChild(FileButton_Shape_Base_Listener);
    }

    @Override 
    public void createElementText() {
        textFont(this.Element_Font);
        textSize(this.Element_Text_Size);
        textAlign(CENTER, CENTER);

        this.FileButton_Name_Position_X = this.FileButton_Shape_Group.getChild("FileButton_Shape_Base").getParam(0);
        this.FileButton_Name_Position_Y = this.FileButton_Shape_Group.getChild("FileButton_Shape_Base").getParam(1) - (textAscent() - textDescent()) * UI_Constants.GLOBAL_TEXT_ALIGN_FACTOR_Y;
    }


    public void onFileButtonSelect() {
        
    }

    public void onFileButtonDeselect() {


    }

    

/*
======================================= Button Interaction =========================================
*/  
    @Override
    public boolean onMousePress() {
        float x = mouseX - this.FileButton_ParentWindow.getWindowPosition().x;
        float y = mouseY - this.FileButton_ParentWindow.getWindowPosition().y;

        return this.FileButton_Shape_Group.getChild("FileButton_Shape_Base_Listener").contains(x, y);
    }

    @Override 
    public void onMouseRelease() {

    }

    @Override
    public void onMouseDrag() {
        
    }
    

    @Override
    public void onSelect() {
        this.FileButton_State = true;
        this.FileButton_Shape_Group.getChild("FileButton_Shape_Base").setStroke(this.Element_Base_Selected_Stroke_Color);
        this.FileButton_Shape_Group.getChild("FileButton_Shape_Base").setFill(this.Element_Base_Selected_Color);
    }


    @Override
    public void onDeselect() {
        this.FileButton_State = false;
        this.FileButton_Shape_Group.getChild("FileButton_Shape_Base").setStroke(this.Element_Base_Unselected_Stroke_Color);
        this.FileButton_Shape_Group.getChild("FileButton_Shape_Base").setFill(this.Element_Base_Unselected_Color);
    }

/*
=====================================  Button Draw ==================================================
*/

    @Override
    public void drawText() {
        fill(this.Element_Text_Color);
        textFont(this.Element_Font);
        textSize(this.Element_Text_Size);
        textAlign(CENTER, CENTER);

        if(this.FileButton_ShowName) {
            text(this.FileButton_Name, this.FileButton_Name_Position_X, this.FileButton_Name_Position_Y);
        }

    }




/*
======================================= Button Getters and Setters =================================
*/  

    public void deleteFile() {
        if(!this.FileButton_File.delete()) {
            System.out.println("Failed to delete file: " + this.FileButton_File.getName());
        }
    }

    public void renameFile(String newName) {

    if (newName == null || newName.trim().isEmpty()) {
        System.out.println("Invalid new name: " + newName);
        return;
    }

    String oldName = this.FileButton_File.getName().substring(0, this.FileButton_File.getName().indexOf(".json"));

    if(oldName.equals(newName)) {
        return;
    }

    File newFile = new File(sketchPath() + "/data/levelSaves/" + newName + ".json");

    if (newFile.exists()) {
        System.out.println("A file with the name " + newName + " already exists.");
        return;
    }

    if(!this.FileButton_File.renameTo(newFile)) {
        System.out.println("Failed to rename file: " + this.FileButton_File.getName() + " to " + newName);
    }

    }

    public boolean equals(UI_FileButton fileButton) {
        if(this.FileButton_Name.equals(fileButton.getElementName())) {
            this.onSelect();
            return true;
        }
        return false;
    }

    
    @Override   
    public String getElementName() {
        return this.FileButton_Name;
    }

    @Override
    public PShape getShape() {
        return this.FileButton_Shape_Group;
    }

    @Override
    public boolean getState() {
        return this.FileButton_State;
    }
    @Override
    public String getGroupName() {
        return this.FileButton_Group;
    }

    @Override 
    public float getValue() {
        return 0;
    }

    @Override
    public void setValue(float value) {
        return;
    }

    @Override
    public void incrementValue(float amount) {

    }

    @Override
    public void setState(boolean state) {
        if(state) {
            this.onSelect();
        } else {
            this.onDeselect();
        }
    }

}   
public class UI_HelpWindow extends UI_Window {



    private int activeSelectionID = -1;
    private String[] WindowTitles = new String[] {"FAQ",
                                                  "Navigation & Controls", 
                                                  "Pen tool & Properties editor",
                                                  "Rigidbody tools",
                                                  "Force tools",
                                                  "Settings",
                                                  "Creations"
                                                  };


    private String[] NavigationAndControlsTexts = new String[] {
        "-To navigate between tabs, you can either press on an individual tab, or press Q or E to switch to the next or previous tab",
        "-To navigate between different hotbar slots, you can press the number keys between 1 & 7, each corresponding to a different slot",
        "-Pressing WASD or ZX keys while having a properties window open increments and decrements the dimensional sliders and angle sliders. Hold shift to increase the increment or decrement",
        "-Press CTRL-C while in edit mode and having a selection active to copy the selection, and press CTRL-V to paste the selection",
        "-Press RIGHT-CLICK and drag to pan the camera, and scroll to zoom in and out",
        "-Pressing the SPACEBAR will pause or unpause the simulation",
        "-Pressing TAB disables or enables cursor snapping"
    };


    private String[] PenToolAndPropertiesEditorTexts = new String[] {
        "-While having the pen tool selected, and having no shapes selected, click on a shape to edit its properties. You can add vertices by clicking on empty space, move vertices by dragging them, and delete vertices by pressing BACKSPACE while hovering over a vertex. To finish editing the body, press ENTER to exit edit mode",
        "-While having shapes selected and having your mouse over the selection box, drag to move the shapes around, and click again to deselect the shapes",
        "-While having the pen tool selected, drag to select a number of shapes. Once you have selected shapes, you are able to copy your selection with CTRL-C & paste your selection with CTRL-V"
    };

    private String[] RigidbodyToolsTexts = new String[] {
        "-To add a rigidbody simply click while having either the circle or the square selected",
        "-To increase the weight of a body, increase its density",
        "-To increase the bounciness of a body, increase its restitution",
        "-To increase the size or dimensions of a body, use the width and height sliders, or the radius slider. You can alternatively press WASD to increment or decrement the sliders dimensional sliders. Pressing SHIFT while using any of these keys will increase the increment and decrement",
        "-By setting the body as static, you make it immovable, both rotationally and positionally",
        "-By setting the body as having a fixed position or a fixed rotation, you either lock the position of the body but allow it to rotate, or you lock the rotation of the body, but allow its position to change, respectively"
    };

    private String[] ForceToolsTexts = new String[] {
        "-Changing the spring constant of a spring makes the spring stiffer or looser",
        "-Changing the equilibrium length of a spring changes the springs resting position",
        "-Changing the spring damping increases or decreases how quickly the springs oscillation slows down. Enabling the perfect spring option will make it oscillate indefinitely with no energy loss",
        "-Locking the translation of a spring to a specific axis makes the spring affect the acceleration of the parent body on only that axis",
        "-To correctly create a rod with the joint option enabled, first pause the simulation. Align the parts of the bodies you wish to connect, placing them directly on top of each other. After positioning, add the rod by clicking once",
        "-Changing the target angular velocity of a motor will increase its speed"
    };


    private String[] SettingsTexts = new String[] {
        "-Changing the simulation quality changes the sub-step count for each frame. Low corresponds to a sub-step count of 64, Medium to a sub-step count of 256, and High to a sub-step count of 1024",
        "-Changing the visual quality to Low disables smoothing and pure strokes. Changing it to medium enables bilinear smoothing while keeping pure strokes disabled. Changing it to High enables bicubic smoothing, enables pure strokes, and if your computer screen or monitor is an Apple Retina display, or a Windows HiDPI display, it enables 2x pixel density",
        "-Changing the text quality to Low disables text smoothing and pure glyphs. Changing the text quality to High enables text smoothing and glyphs"
    };

    private String[] CreationsTexts = new String[] {
        "-To save a level, press \"Save Level\", enter the level name, and press ENTER. Once a level has been saved, it's name cannot be used again. Level names can only contain letters and numbers, with no special characters",
        "-To load a creation, select it from the window and press \"Load Level\". To delete a level, select it and press \"Delete Level\"",
        "-Once more than 5 levels have been saved, a new page will be added. Press the \"Prev Page\" and \"Next Page\" buttons to alternate between level pages",
    };

    private String[] FAQTexts = new String[] {
        "How do I place forces?",
        "-In order to place a force, at least one of its ends needs to be parented to a rigidbody. Just click on a body and then empty space, or click on two bodies one after another",
        "How do I use the mouse spring?",
        "-To use the mouse spring, just press shift while over a rigidbody and drag. This will cause a spring to be attached to your mouse, and the body you clicked on",
        "Why are my rods vibrating?",
        "-Honestly, no clue, its very difficult to create rods in physics simulations without using more complex methods than what I am capable of, so the rods will stay broken",
    };


    private float initialYPadding = 40;
    private float padding = 15;


    public UI_HelpWindow() {
        super("Help", 4, new PVector(713, 700), new PVector(713, 47), new PVector(713, 653), false);
        this.setWindowPosition(new PVector(displayWidth/2, displayHeight/2 - 35));
        textFont(UI_Constants.INTER_BOLD);
        textSize(25);
        textAlign(CENTER, CENTER);
        this.Window_Text_Width = textWidth(this.Window_Name);
        this.Window_Text_Position.set(0, -(this.Window_Form_Container_Size.y + this.Window_Text_Container_Size.y) / 2 - (textAscent() - textDescent()) * UI_Constants.GLOBAL_TEXT_ALIGN_FACTOR_Y);
    }   


    @Override
    public void drawText() {
        if(this.isActiveWindow) {
            fill(UI_Constants.WHITE);
        } else {
            fill(UI_Constants.GRAY_25);
        }

        textFont(UI_Constants.INTER_BOLD);
        textSize(25);
        textAlign(CENTER, CENTER);
        
        if(this.activeSelectionID == -1) {
            text(this.Window_Name, this.Window_Text_Position.x, this.Window_Text_Position.y);
        } else {
            text(this.WindowTitles[this.activeSelectionID], this.Window_Text_Position.x, this.Window_Text_Position.y);
        }
    }

    public void switchToSelectionScene() {
        this.clearAllElements();
        this.addElement(new UI_Button("FAQ", this, false));
        this.addElement(new UI_Button("Navigation & Controls", this, false));
        this.addElement(new UI_Button("Pen tool & Properties editor", this, false));
        this.addElement(new UI_Button("Rigidbody tools", this, false));
        this.addElement(new UI_Button("Force tools", this, false));
        this.addElement(new UI_Button("Settings", this, false));
        this.addElement(new UI_Button("Creations", this, false));
    }


    public void switchToFAQScene() {
        this.clearAllElements();
        float[] textBoxHeights = {this.calculateTextBoxHeight(this.FAQTexts[0], 1, 1.2f), this.calculateTextBoxHeight(this.FAQTexts[1], 4, 1.2f), this.calculateTextBoxHeight(this.FAQTexts[2], 1, 1.2f), this.calculateTextBoxHeight(this.FAQTexts[3], 4, 1.2f), this.calculateTextBoxHeight(this.FAQTexts[4], 1, 1.2f), this.calculateTextBoxHeight(this.FAQTexts[5], 4, 1.2f)};
        for(int i = 0; i < this.FAQTexts.length; i++) {
            this.addElement(new UI_Text(this.FAQTexts[i], this, this.calculateTextBoxPosition(i, textBoxHeights, padding), new PVector(633, textBoxHeights[i]), 3, 20, UI_Constants.WHITE, true, UI_Constants.INTER_REGULAR));
        }
        this.addElement(new UI_Button("Back", this, false));
    }

    public void switchToNavigationAndControlsScene() {
        this.clearAllElements();
        float[] textBoxHeights = {this.calculateTextBoxHeight(this.NavigationAndControlsTexts[0], 2, 1.2f), this.calculateTextBoxHeight(this.NavigationAndControlsTexts[1], 2, 1.2f), this.calculateTextBoxHeight(this.NavigationAndControlsTexts[2], 3, 1.2f), this.calculateTextBoxHeight(this.NavigationAndControlsTexts[3], 2, 1.2f), this.calculateTextBoxHeight(this.NavigationAndControlsTexts[4], 2, 1.2f), this.calculateTextBoxHeight(this.NavigationAndControlsTexts[5], 1, 1.2f), this.calculateTextBoxHeight(this.NavigationAndControlsTexts[6], 1, 1.2f)};

        for(int i = 0; i < this.NavigationAndControlsTexts.length; i++) {
            this.addElement(new UI_Text(this.NavigationAndControlsTexts[i], this, this.calculateTextBoxPosition(i, textBoxHeights, padding), new PVector(633, textBoxHeights[i]), 3, 20, UI_Constants.WHITE, true, UI_Constants.INTER_REGULAR));
        }

        this.addElement(new UI_Button("Back", this, false));
    }

    public void switchToPenAndPropertiesScene() {
        this.clearAllElements();

        float[] textBoxHeights = {this.calculateTextBoxHeight(this.PenToolAndPropertiesEditorTexts[0], 6, 1.2f), this.calculateTextBoxHeight(this.PenToolAndPropertiesEditorTexts[1], 3, 1.2f), this.calculateTextBoxHeight(this.PenToolAndPropertiesEditorTexts[2], 3, 1.2f)};

        for(int i = 0; i < this.PenToolAndPropertiesEditorTexts.length; i++) {
            this.addElement(new UI_Text(this.PenToolAndPropertiesEditorTexts[i], this, this.calculateTextBoxPosition(i, textBoxHeights, padding), new PVector(633, textBoxHeights[i]), 3, 20, UI_Constants.WHITE, true, UI_Constants.INTER_REGULAR));
        }
        this.addElement(new UI_Button("Back", this, false));
    }

    public void switchToRigidbodyToolsScene() {
        this.clearAllElements();

        float[] textBoxHeights = {this.calculateTextBoxHeight(this.RigidbodyToolsTexts[0], 2, 1.2f), this.calculateTextBoxHeight(this.RigidbodyToolsTexts[1], 1, 1.2f), this.calculateTextBoxHeight(this.RigidbodyToolsTexts[2], 1, 1.2f), this.calculateTextBoxHeight(this.RigidbodyToolsTexts[3], 5, 1.2f), this.calculateTextBoxHeight(this.RigidbodyToolsTexts[4], 2, 1.2f), this.calculateTextBoxHeight(this.RigidbodyToolsTexts[5], 4, 1.2f)};
        for(int i = 0; i < this.RigidbodyToolsTexts.length; i++) {
            this.addElement(new UI_Text(this.RigidbodyToolsTexts[i], this, this.calculateTextBoxPosition(i, textBoxHeights, padding), new PVector(633, textBoxHeights[i]), 3, 20, UI_Constants.WHITE, true, UI_Constants.INTER_REGULAR));
        }
        this.addElement(new UI_Button("Back", this, false));
    }

    public void switchToForcesToolsScene() {
        this.clearAllElements();

        float[] textBoxHeights = {this.calculateTextBoxHeight(this.ForceToolsTexts[0], 2, 1.2f), this.calculateTextBoxHeight(this.ForceToolsTexts[1], 2, 1.2f), this.calculateTextBoxHeight(this.ForceToolsTexts[2], 3, 1.2f), this.calculateTextBoxHeight(this.ForceToolsTexts[3], 2, 1.2f), this.calculateTextBoxHeight(this.ForceToolsTexts[4], 4, 1.2f), this.calculateTextBoxHeight(this.ForceToolsTexts[5], 3, 1.2f)};
        for(int i = 0; i < this.ForceToolsTexts.length; i++) {
            this.addElement(new UI_Text(this.ForceToolsTexts[i], this, this.calculateTextBoxPosition(i, textBoxHeights, padding), new PVector(633, textBoxHeights[i]), 3, 20, UI_Constants.WHITE, true, UI_Constants.INTER_REGULAR));
        }
        this.addElement(new UI_Button("Back", this, false));
    }

    public void switchToSettingsScene() {
        this.clearAllElements();

        float[] textBoxHeights = {this.calculateTextBoxHeight(this.SettingsTexts[0], 3, 1.2f), this.calculateTextBoxHeight(this.SettingsTexts[1], 6, 1.2f), this.calculateTextBoxHeight(this.SettingsTexts[2], 3, 1.2f)};
        for(int i = 0; i < this.SettingsTexts.length; i++) {
            this.addElement(new UI_Text(this.SettingsTexts[i], this, this.calculateTextBoxPosition(i, textBoxHeights, padding), new PVector(633, textBoxHeights[i]), 3, 20, UI_Constants.WHITE, true, UI_Constants.INTER_REGULAR));
        }
        this.addElement(new UI_Button("Back", this, false));
    }

    public void switchToCreationsScene() {
        this.clearAllElements();

        float[] textBoxHeights = {this.calculateTextBoxHeight(this.CreationsTexts[0], 4, 1.2f), this.calculateTextBoxHeight(this.CreationsTexts[1], 2, 1.2f), this.calculateTextBoxHeight(this.CreationsTexts[2], 3, 1.2f)};

        for(int i = 0; i < this.CreationsTexts.length; i++) {
            this.addElement(new UI_Text(this.CreationsTexts[i], this, this.calculateTextBoxPosition(i, textBoxHeights, padding), new PVector(633, textBoxHeights[i]), 3, 20, UI_Constants.WHITE, true, UI_Constants.INTER_REGULAR));
        }
        this.addElement(new UI_Button("Back", this, false));
    }


    public void onButtonPress(String name) {
        switch (name) {
            case "FAQ":
                this.activeSelectionID = 0;
                this.switchToFAQScene();
                break;
            case "Navigation & Controls":
                this.activeSelectionID = 1;
                this.switchToNavigationAndControlsScene();
                break;
            case "Pen tool & Properties editor":
                this.activeSelectionID = 2;
                this.switchToPenAndPropertiesScene();
                break;
            case "Rigidbody tools":
                this.activeSelectionID = 3;
                this.switchToRigidbodyToolsScene();
                break;
            case "Force tools":
                this.activeSelectionID = 4;
                this.switchToForcesToolsScene();
                break;
            case "Settings":
                this.activeSelectionID = 5;
                this.switchToSettingsScene();
                break;
            case "Creations":
                this.activeSelectionID = 6;
                this.switchToCreationsScene();
                break;
            case "Back":
                this.activeSelectionID = -1;
                this.switchToSelectionScene();
                break;
        }
    }
    public void open() {
        this.deselectAllWindows();
        this.isActiveWindow = true;
        this.Window_Visibility = true;
        UI_Manager.bringToFront(this);
        this.Window_Container.getChild("Window_Container_Stroke").setStroke(UI_Constants.BLUE_SELECTED);
        this.Window_Container.getChild("Window_Text_Container").setFill(UI_Constants.BLUE_UNSELECTED);
        this.switchToSelectionScene();

    }



    @Override
    public void interactionDraw() {
        if(UI_Manager.getTabBar().getActiveTabID() == 3) {
            this.lockSelected();
            UI_Manager.closeAllWindows(this);
        }   
    }

    @Override
    public boolean onMouseDrag() {
        if(!this.Window_Visibility) {
            return false;
        }
        if(mousePressed && this.isMouseOverWindowFormContainer) {
            this.onElementMouseDrag();
            return true;
        }
        return false;
    }



    public void lockSelected() {
        this.isActiveWindow = true;
        this.Window_Visibility = true;
        UI_Manager.getHotBar().setActiveSlotID(-1);
        this.Window_Container.getChild("Window_Container_Stroke").setStroke(UI_Constants.BLUE_SELECTED);
        this.Window_Container.getChild("Window_Text_Container").setFill(UI_Constants.BLUE_UNSELECTED);
    }


    public float calculateTextBoxHeight(String text, int numLines, float lineSpacing) {
        textFont(UI_Constants.INTER_REGULAR);
        textSize(20);
        float lineHeight = textAscent() + textDescent();
        float textBoxHeight = (lineHeight * lineSpacing) * numLines; //+ 2 * padding;
        return textBoxHeight;

        // return 20*lineSpacing*numLines;
    }

    public float calculateTextBoxWidth(String text, int padding, int numTextBoxes) {
        float textBoxWidth = (width - 2 * padding) / numTextBoxes;
        return textBoxWidth;
    }

    public PVector calculateTextBoxPosition(int index, float[] textBoxHeights, float padding) {
        float yPosition = -this.Window_Form_Container_Size.y / 2 + initialYPadding;
        for (int i = 0; i < index; i++) {
            yPosition += textBoxHeights[i] + padding;
        }
        return new PVector(-this.Window_Form_Container_Size.x / 2 + 40, yPosition);
    }
}
  
public class UI_HotBar {

    private PShape HOT_SHAPE;
    private float[] TEXT_POSITION_X;
    private float[] TEXT_POSITION_Y;

    private float[] SLOT_POSITION;

    private float SCALE_FACTOR = width/1512f;

    private int activeSlotID = 0;


 
    public UI_HotBar() {
        this.initializeHotbar();
    }   

    public void draw() {
        this.drawHotbar();
    }




/*
======================================== Initialization ============================================
*/
    public void initializeHotbar() {
        rectMode(CENTER);
        this.SLOT_POSITION = new float[UI_Constants.HOTBAR_SLOT_COUNT];
        this.TEXT_POSITION_X = new float[UI_Constants.HOTBAR_SLOT_COUNT];
        this.TEXT_POSITION_Y = new float[UI_Constants.HOTBAR_SLOT_COUNT];


        this.HOT_SHAPE = createShape(GROUP);
        this.HOT_SHAPE.setName("HOTBAR");
    
        float totalPadding = UI_Constants.HOTBAR_CONTAINER_WIDTH - UI_Constants.HOTBAR_TOTAL_SLOT_WIDTH;

        float padding = totalPadding / (UI_Constants.HOTBAR_SLOT_COUNT + 1);

        float startX = UI_Constants.HOTBAR_CONTAINER_POSITION_X - UI_Constants.HOTBAR_CONTAINER_WIDTH/ 2;

        for(int i = 0; i < UI_Constants.HOTBAR_SLOT_COUNT; i++) {
            float xPos = startX + i * (padding + UI_Constants.HOTBAR_SLOT_WIDTH) + UI_Constants.HOTBAR_SLOT_WIDTH / 2;
            float yPos = UI_Constants.HOTBAR_CONTAINER_POSITION_Y;

            float slotXPos = xPos - UI_Constants.HOTBAR_SLOT_WIDTH / 2;
            float slotYPos = yPos - UI_Constants.HOTBAR_SLOT_HEIGHT / 2;

            SLOT_POSITION[i] = xPos;

            PShape SLOT_GROUP = createShape(GROUP);

            PShape SLOT = createShape(RECT, xPos, yPos, UI_Constants.HOTBAR_SLOT_WIDTH, 
                                                        UI_Constants.HOTBAR_SLOT_HEIGHT, 
                                                        UI_Constants.HOTBAR_SLOT_ROUNDING);
            PShape SLOT_LISTENER = UI_Constants.createElementListener(SLOT);
                SLOT_LISTENER.setName("SLOT_LISTENER");

                if(i == this.activeSlotID) {
                    SLOT.setFill(UI_Constants.HOTBAR_SLOT_SELECTED_COLOR);
                    SLOT.setStroke(UI_Constants.HOTBAR_SLOT_SELECTED_STROKE);
                } else {
                    SLOT.setFill(UI_Constants.HOTBAR_SLOT_UNSELECTED_COLOR);
                    SLOT.setStroke(UI_Constants.HOTBAR_SLOT_UNSELECTED_STROKE);
                }

                SLOT.setStrokeWeight(UI_Constants.HOTBAR_STROKE_WEIGHT);

                PShape SLOT_ICON_SELECTED = loadShape(sketchPath() + "/data/icons/HotbarSlot" + (i + 1) + "Selected.svg");
                    SLOT_ICON_SELECTED.setName("SLOT_ICON_SELECTED");
                    SLOT_ICON_SELECTED.translate(slotXPos, slotYPos);
                    SLOT_ICON_SELECTED.setVisible(false);

                if(i == this.activeSlotID) {
                    SLOT_ICON_SELECTED.setVisible(true);
                }

                PShape SLOT_ICON = loadShape(sketchPath() + "/data/icons/HotbarSlot" + (i + 1) + ".svg");
                    SLOT_ICON.setName("SLOT_ICON");
                    SLOT_ICON.translate(slotXPos, slotYPos);

                SLOT_GROUP.addChild(SLOT);
                SLOT_GROUP.addChild(SLOT_ICON);
                SLOT_GROUP.addChild(SLOT_ICON_SELECTED);
                SLOT_GROUP.addChild(SLOT_LISTENER);

            this.HOT_SHAPE.addChild(SLOT_GROUP);
        }

        this.HOT_SHAPE.translate(UI_Constants.HOTBAR_CONTAINER_POSITION_X, UI_Constants.HOTBAR_CONTAINER_POSITION_Y);
        this.HOT_SHAPE.scale(SCALE_FACTOR); 
        this.HOT_SHAPE.translate(-UI_Constants.HOTBAR_CONTAINER_POSITION_X, -UI_Constants.HOTBAR_CONTAINER_POSITION_Y);
        this.initializeText();
    }


    public void initializeText() {
        textFont(UI_Constants.HOTBAR_TEXT_FONT);
        textSize(UI_Constants.HOTBAR_TEXT_SIZE);
        textAlign(CENTER, CENTER);

        for(int i = 0; i < UI_Constants.HOTBAR_SLOT_COUNT; i++) {
            float textEdgePadding = UI_Constants.HOTBAR_SLOT_WIDTH / 2 - textWidth(String.valueOf(i + 1)) / 2 - UI_Constants.HOTBAR_TEXT_PADDING_X;
            float textXPos = this.SLOT_POSITION[i] + textEdgePadding;
            float textYPos = UI_Constants.HOTBAR_CONTAINER_POSITION_Y + textEdgePadding - (textAscent() - textDescent()) * UI_Constants.GLOBAL_TEXT_ALIGN_FACTOR_Y;
            
            this.TEXT_POSITION_X[i] = textXPos;
            this.TEXT_POSITION_Y[i] = textYPos;
        }
    }




/*
====================================== Element Updates =============================================
*/

    public void onSlotChange(int slotID) {
        int previousSlotID = this.activeSlotID;

        if(previousSlotID != -1) {
            this.HOT_SHAPE.getChild(this.activeSlotID).getChild(0).setFill(UI_Constants.HOTBAR_SLOT_UNSELECTED_COLOR);
            this.HOT_SHAPE.getChild(this.activeSlotID).getChild(0).setStroke(UI_Constants.HOTBAR_SLOT_UNSELECTED_STROKE);
            this.HOT_SHAPE.getChild(this.activeSlotID).getChild(1).setVisible(true);
            this.HOT_SHAPE.getChild(this.activeSlotID).getChild(2).setVisible(false);
        }

        if(slotID == -1) {
            this.activeSlotID = -1;
            return;
        } 

        this.activeSlotID = slotID;
    
        this.HOT_SHAPE.getChild(slotID).getChild(0).setFill(UI_Constants.HOTBAR_SLOT_SELECTED_COLOR);
        this.HOT_SHAPE.getChild(slotID).getChild(0).setStroke(UI_Constants.HOTBAR_SLOT_SELECTED_STROKE);
        this.HOT_SHAPE.getChild(slotID).getChild(1).setVisible(false);
        this.HOT_SHAPE.getChild(slotID).getChild(2).setVisible(true);



        boolean resetMouseObject = (4 <= previousSlotID && previousSlotID <= 6) && (this.activeSlotID < 4 || this.activeSlotID > 6)
                                    || (1 <= previousSlotID && previousSlotID <= 3) && (this.activeSlotID < 1 || this.activeSlotID > 3);


        if(resetMouseObject) {
            Mouse.getMouseObjectResults().clear();
            UI_PropertiesForceWindow window = UI_Manager.getPropertiesForceWindow();
            if(window.MOUSE_SPRING_ADDED) {
                window.removeMouseSpring();
            }
        }
    

        UI_Window window;
        switch(this.activeSlotID) {
            case 0:
                UI_Manager.closeAllWindows();
                break;
            case 1:
                UI_Manager.closeAllWindows();
                break;
            case 2:
                if(previousSlotID == -1) {
                    UI_Manager.closeAllWindows();
                }

                window = UI_Manager.getPropertiesRigidbodyWindow();
                window.onSlotChange(previousSlotID);
                UI_Manager.bringToFront(window);
                //UI_Manager.repositionWindow(window);
                window.onWindowSelect();
                break;
            case 3:
                if(previousSlotID == -1) {
                    UI_Manager.closeAllWindows();
                }
                window = UI_Manager.getPropertiesRigidbodyWindow();
                window.onSlotChange(previousSlotID);
                UI_Manager.bringToFront(window);
                //UI_Manager.repositionWindow(window);
                window.onWindowSelect();
                break;
            case 4:
                if(previousSlotID == -1) {
                    UI_Manager.closeAllWindows();
                }
                window = UI_Manager.getPropertiesForceWindow();

                window.onSlotChange(previousSlotID);
                UI_Manager.bringToFront(window);
                //UI_Manager.repositionWindow(window);
                window.onWindowSelect();
                break;
            case 5:
                if(previousSlotID == -1) {
                    UI_Manager.closeAllWindows();
                }
                window = UI_Manager.getPropertiesForceWindow();
    
                window.onSlotChange(previousSlotID);
                UI_Manager.bringToFront(window);
                //UI_Manager.repositionWindow(window);
                window.onWindowSelect();
                break;
            case 6:
                if(previousSlotID == -1) {
                    UI_Manager.closeAllWindows();
                }
                window = UI_Manager.getPropertiesForceWindow();
                window.onSlotChange(previousSlotID);
                UI_Manager.bringToFront(window);
                //UI_Manager.repositionWindow(window);
                window.onWindowSelect();
                break;
        }
        
        if(previousSlotID == 1) {
            UI_Manager.getPropertiesEditorWindow().onWindowClose();
        }
    }


    public boolean onMousePress() {
        for(int i = 0; i < UI_Constants.HOTBAR_SLOT_COUNT; i++) {
            if(this.HOT_SHAPE.getChild(i).getChild("SLOT_LISTENER").contains(mouseX, mouseY)) {
                this.setActiveSlotID(i);
                return true;
            }
        }
        return false;
    }

/*
=========================================== Drawing ================================================
*/

    public void drawHotbar() {
        shape(this.HOT_SHAPE);
        this.drawHotbarText();
    }

    public void drawHotbarText() {
        pushMatrix();
        translate(UI_Constants.HOTBAR_CONTAINER_POSITION_X, UI_Constants.HOTBAR_CONTAINER_POSITION_Y);
        scale(SCALE_FACTOR); 
        translate(-UI_Constants.HOTBAR_CONTAINER_POSITION_X, -UI_Constants.HOTBAR_CONTAINER_POSITION_Y);

        textFont(UI_Constants.HOTBAR_TEXT_FONT);
        textAlign(CENTER, CENTER);
        textSize(UI_Constants.HOTBAR_TEXT_SIZE);

        for(int i = 0; i < UI_Constants.HOTBAR_SLOT_COUNT; i++) {
            if(this.activeSlotID == i) {
                fill(UI_Constants.HOTBAR_LABEL_SELECTED_TEXT_COLOR);
            } else {
                fill(UI_Constants.HOTBAR_LABEL_UNSELECTED_TEXT_COLOR);
            }
            text(i + 1, this.TEXT_POSITION_X[i], this.TEXT_POSITION_Y[i]);
        }
        popMatrix();
    }

    


/*
====================================== Getters & Setters ===========================================
*/  
    public void setActiveSlotID(int slotID) {
        this.onSlotChange(slotID);
    }
    public PShape getHotbarShape() {
        return this.HOT_SHAPE;
    }

    public float[] getSlotPosition() {
        return this.SLOT_POSITION;
    }

    public float[] getTextPositionX() {
        return this.TEXT_POSITION_X;
    }

    public float[] getTextPositionY() {
        return this.TEXT_POSITION_Y;
    }

    public int getActiveSlotID() {
        return this.activeSlotID;
    }

}
public class UI_Manager {
    
    private UI_TabBar TAB_BAR;
    private UI_HotBar HOT_BAR;

    private UI_PropertiesRigidbodyWindow propertiesRigidbodyWindow;
    private UI_PropertiesForceWindow propertiesForceWindow;
    private UI_PropertiesEditorWindow propertiesEditorWindow;
    private UI_CreationWindow creationWindow;
    private UI_SettingsWindow settingsWindow;
    private UI_HelpWindow helpWindow;

    private ArrayList<UI_Window> WINDOWS;



    public boolean dragging = false;

    public boolean hasWindowBeenInteractedWith = false;
    public float timeWindowBeenInteractedWith;

    public boolean isMouseOverWindow = false;
    public boolean wasMousePressedOverWindow = false;

    public void init() {
        UI_Constants = new UI_Constants();
        this.WINDOWS = new ArrayList<UI_Window>();
        this.TAB_BAR = new UI_TabBar();
        this.HOT_BAR = new UI_HotBar(); 

        this.propertiesRigidbodyWindow = new UI_PropertiesRigidbodyWindow();
        this.propertiesForceWindow = new UI_PropertiesForceWindow();
        this.propertiesEditorWindow = new UI_PropertiesEditorWindow();
        this.creationWindow = new UI_CreationWindow();
        this.settingsWindow = new UI_SettingsWindow();
        this.helpWindow = new UI_HelpWindow();

        this.WINDOWS.add((UI_Window)this.propertiesRigidbodyWindow);
        this.WINDOWS.add((UI_Window)this.propertiesForceWindow);
        this.WINDOWS.add((UI_Window)this.propertiesEditorWindow);
        this.WINDOWS.add((UI_Window)this.creationWindow);
        this.WINDOWS.add((UI_Window)this.settingsWindow);
        this.WINDOWS.add((UI_Window)this.helpWindow);

        for(UI_Window window : WINDOWS) {
            window.setWindowVisibility(false);
        }       

        this.TAB_BAR.updateWindows();
    }


    public void draw() {
        if(hasWindowBeenInteractedWith) {
            if(millis() - timeWindowBeenInteractedWith > 100) {
                this.hasWindowBeenInteractedWith = false;
                this.timeWindowBeenInteractedWith = 0;
            }
        }   

        this.TAB_BAR.draw();
        this.HOT_BAR.draw();

        for(UI_Window window : this.WINDOWS) {
                window.draw();
        }

        for(UI_Window window : this.WINDOWS) {
            if(window.isMouseOverWindow) {
                this.isMouseOverWindow = true;
                return;
            } else {
                this.isMouseOverWindow = false;
            }

            if(window.wasMousePressedOverWindow) {
                this.wasMousePressedOverWindow = true;
                return;
            } else {
                this.wasMousePressedOverWindow = false;
            }
        }
    }

    public void interactionDraw() {
        for(UI_Window window : this.WINDOWS) {
            window.interactionDraw();
        }
    }



/*
======================================= Mouse Interaction =======================================
*/
    public void onMousePress() {
        if(this.HOT_BAR.onMousePress()) {
            this.timeWindowBeenInteractedWith = millis();
            this.hasWindowBeenInteractedWith = true;
        }

        if(this.TAB_BAR.onMousePress()) {
            this.timeWindowBeenInteractedWith = millis();
            this.hasWindowBeenInteractedWith = true;
        }

        boolean windowVisibilityChange = false;
        boolean isVisibilityChangeActiveWindow = false;
        UI_Window activeWindow = this.getActiveWindow();

        for(int i = this.WINDOWS.size() - 1; i >= 0; i--) {
            this.WINDOWS.get(i).interactionMousePress();

            boolean isWindowVisibleBefore = this.WINDOWS.get(i).Window_Visibility;
            boolean isWindowVisibleAfter;

            if(this.WINDOWS.get(i).onMousePress()) {
                isWindowVisibleAfter = this.WINDOWS.get(i).Window_Visibility;

                if(activeWindow != null) {
                    if(isWindowVisibleBefore != isWindowVisibleAfter) {
                        if(this.WINDOWS.get(i) == activeWindow) {
                            isVisibilityChangeActiveWindow = true;
                        }
                    windowVisibilityChange = true;
                    }
                }
                
                this.timeWindowBeenInteractedWith = millis();
                this.hasWindowBeenInteractedWith = true;

                if(!windowVisibilityChange) {
                    return;
                }
            } 
        }

        if(windowVisibilityChange && !isVisibilityChangeActiveWindow && activeWindow != null) {
            activeWindow.onWindowSelectHotbarCaller();
        }
    }

    public void onMouseDrag() {
        for(int i = this.WINDOWS.size() - 1; i >= 0; i--) {

            this.WINDOWS.get(i).interactionMouseDrag();
            
            if(this.WINDOWS.get(i).onMouseDrag()) {
                this.timeWindowBeenInteractedWith = millis();
                this.hasWindowBeenInteractedWith = true;
                return;
            }
        }
    }

    public void onMouseRelease() {
        ArrayList<UI_Window> windowsCopy = new ArrayList<>(this.WINDOWS);
        for(UI_Window window : windowsCopy) {
            window.onMouseRelease();
            window.interactionMouseRelease();
        }
    }

    public void onMouseClick() {
        ArrayList<UI_Window> windowsCopy = new ArrayList<>(this.WINDOWS);
        for(UI_Window window : windowsCopy) {
            window.interactionMouseClick();
        }
    }
/*
================================================================================================
*/
    public void bringToFront(UI_Window window) {
        this.WINDOWS.add(this.WINDOWS.remove(this.WINDOWS.indexOf(window)));
    }



    public void onKeyPress(int keyCode) {
        UI_Window window = getActiveWindow();

        if(window != null) {
            window.onKeyPress(keyCode);
        }
    }
    

    public void repositionWindow(UI_Window window) {
        for(UI_Window win : UI_Manager.WINDOWS) {
            if(window == win) {
                continue;
            }

            if(win.getWindowPosition().x < displayWidth / 2) {
                window.setWindowPosition(new PVector(displayWidth * (3/4), displayHeight/3));
            } else {
                window.setWindowPosition(new PVector(displayWidth * (1/4), displayHeight/3));
            }
        }
    }


    public void closeAllWindows() {
        for(UI_Window window : this.WINDOWS) {
            window.onWindowClose();
        }
    }

    public void closeAllWindows(UI_Window window) {
        for(UI_Window win : this.WINDOWS) {
            if(win != window) {
                win.onWindowClose();
            }
        }
    }

/*
====================================== Getters and Setters =========================================
*/

    
    public UI_Window getActiveWindow() {
        for(UI_Window window : this.WINDOWS) {
            if(window.isActiveWindow) {
                return window;
            }
        }
        return null;
    }
    public UI_HotBar getHotBar() {
        return this.HOT_BAR;
    }
    public UI_TabBar getTabBar() {
        return this.TAB_BAR;
    }
    public UI_Window getWindow(int id) {
        return this.WINDOWS.get(id);
    }

    // public UI_Window getWindowByName(String name) {
    //     for(UI_Window window : this.WINDOWS) {
    //         if(window.getWindowName().equals(name)) {
    //             return window;
    //         }
    //     }
    //     throw new IllegalArgumentException("No window with name: " + name);
    // }


    public UI_PropertiesRigidbodyWindow getPropertiesRigidbodyWindow() {
        return this.propertiesRigidbodyWindow;
    }

    public UI_PropertiesForceWindow getPropertiesForceWindow() {
        return this.propertiesForceWindow;
    }

    public UI_PropertiesEditorWindow getPropertiesEditorWindow() {
        return this.propertiesEditorWindow;
    }

    public UI_CreationWindow getCreationWindow() {
        return this.creationWindow;
    }

    public UI_SettingsWindow getSettingsWindow() {
        return this.settingsWindow;
    }

    public UI_HelpWindow getHelpWindow() {
        return this.helpWindow;
    }

    public ArrayList<UI_Window> getWindows() {
        return this.WINDOWS;
    }

    public boolean getIsOverWindows() {
        return this.isMouseOverWindow;
    }

    public boolean getIsOverOrPressedWindows() {
        return this.isMouseOverWindow || this.wasMousePressedOverWindow;
    }

    public boolean getIsPressedOverWindow() {
        return this.wasMousePressedOverWindow;
    }

    public int getActiveTabID() {
        return this.TAB_BAR.getActiveTabID();
    }
    public void setActiveTabID(int id) {
        this.TAB_BAR.setActiveTabID(id);
    }
}
public class UI_PropertiesEditorWindow extends UI_Window {



    private String OS = System.getProperty("os.name").toLowerCase();
    private boolean mac = false;
    private boolean mouseSpringAdded = false;

    private Rigidbody rigidbodyToEdit = null;

    private ArrayList<Rigidbody> selectedRigidbodies = new ArrayList<Rigidbody>();

    private ArrayList<Rigidbody> rigidbodiesToCopy = new ArrayList<Rigidbody>();


    public boolean PAUSE_STATE_ON_OPEN = false;
    private float mouseDownTime;
    private boolean inEditMode = false;

    private boolean inDragSelectMode = false;
    private boolean isSelectionBeingDragged = false;
    private AABB dragBox = null;
    private PVector initialDragPosition = new PVector();


    private boolean inCopySelectMode = false;
    private PVector initialCopyMousePosition = new PVector();

    private int vertexIndexToDrag = -1;
    private boolean circleVertexToDrag = false;





    private float prvDnsty;
    private float prvRsttn;
    private boolean prvStatic;
    private boolean prvFixRot;
    private boolean prvFixPos;
    private float prvAngle;



    public UI_PropertiesEditorWindow() {
        super("Properties Editor (rigidbody)", 2, new PVector(width / 3, height / 2));
        if(OS.contains("mac")) {
            this.mac = true;
        }
        this.initialize();
    }

/*
========================================= UI Elements  =============================================
*/
    public void initialize() {
    }


    public void onEditorActive() {
        IS_PAUSED = true;
        IS_PAUSED_LOCK = true;

        this.clearAllElements();
        this.Window_Visibility = true;
        this.onWindowSelect();

        this.initializeEditor();
    }

    public void initializeEditor() {
        this.clearAllElements();
        this.addElement(new UI_Slider("Density", (UI_Window)this, MIN_BODY_DENSITY, MAX_BODY_DENSITY, this.rigidbodyToEdit.getDensity()));
        this.addElement(new UI_Slider("Restitution", (UI_Window)this, 0, 1, this.rigidbodyToEdit.getRestitution()));
        this.addElement(new UI_Toggle("Static", (UI_Window)this, "Staticity", this.rigidbodyToEdit.getIsStatic()));
        this.addElement(new UI_Toggle("Fixed Rotation", (UI_Window)this, "Staticity", this.rigidbodyToEdit.getIsRotationallyStatic()));
        this.addElement(new UI_Toggle("Fixed Position", (UI_Window)this, "Staticity", this.rigidbodyToEdit.getIsTranslationallyStatic()));
        this.addElement(new UI_Slider("Angle", (UI_Window)this, -360, 360, this.rigidbodyToEdit.getAngle()));


        this.prvDnsty = this.rigidbodyToEdit.getDensity();
        this.prvRsttn = this.rigidbodyToEdit.getRestitution();
        this.prvStatic = this.rigidbodyToEdit.getIsStatic();
        this.prvFixRot = this.rigidbodyToEdit.getIsRotationallyStatic();
        this.prvFixPos = this.rigidbodyToEdit.getIsTranslationallyStatic();
        this.prvAngle = this.rigidbodyToEdit.getAngle();
    }



/*
========================================= Drawing ========================================
*/ 
    @Override
    public void interactionDraw() {
        if(this.inEditMode) {
            this.elementChangeListener();
            this.selectLock();
        }

        if(UI_Manager.getIsOverOrPressedWindows()) {
            return;
        }

        if(UI_Manager.HOT_BAR.getActiveSlotID() != 1) {
            return;
        }

        if(this.inEditMode) {
            this.onWindowSelect();
            this.drawVertices();
            return;
        }

        if(this.inDragSelectMode) {
            this.drawDragSelect();
            return;
        }

        if(this.dragBox != null && this.dragBox.calculateArea() > 0.1f) {
            this.dragBox.drawAABB();
            return;
        }

        if(this.inCopySelectMode) {
            this.drawCopiedRigidbodies();
            this.updateCopiedRigidbodyPosition();
        }
    }


    public void drawVertices() {
        ShapeType shapeType = this.rigidbodyToEdit.getShapeType();

        if(shapeType == ShapeType.BOX || shapeType == ShapeType.POLYGON) {
            this.drawPolygonVertices();
        } else if(shapeType == ShapeType.CIRCLE) {
            this.drawCircleVertex();
        }
    }


    public void drawPolygonVertices() {
        PVector[] currentVertices = this.rigidbodyToEdit.GetTransformedVertices();

        for(int i = 0; i < currentVertices.length; i++) {
            int color1 = color(20, 143, 205, 255);
            int color2 = color(32, 90, 119, 255); 
            float t = (sin(millis() / 500.0f) + 1) / 2; 
            int c = lerpColor(color1, color2, t);

            if(this.vertexIndexToDrag != -1) {
                if(i == this.vertexIndexToDrag) {
                    pushMatrix();
                    translate(currentVertices[i].x, currentVertices[i].y);
                    fill(color1);
                    strokeWeight(0.019f);
                    stroke(0, 0, 0, 175);
                    ellipse(0, 0, 0.24f, 0.24f);
                    popMatrix();
                } else {
                    pushMatrix();
                    translate(currentVertices[i].x, currentVertices[i].y);
                    fill(color2);
                    strokeWeight(0.019f);
                    stroke(0, 0, 0, 175);
                    ellipse(0, 0, 0.21f, 0.21f);
                    popMatrix();
                }
            } else {
                pushMatrix();
                translate(currentVertices[i].x, currentVertices[i].y);
                fill(c);
                strokeWeight(0.019f);
                stroke(0, 0, 0, 175);
                ellipse(0, 0, 0.24f, 0.24f);
                popMatrix();
            }
            
        }
    }

    public void drawCircleVertex() {
        PVector vertex = new PVector(this.rigidbodyToEdit.getRadius(), 0);
        vertex = PhysEngMath.Transform(vertex, this.rigidbodyToEdit.getAngle());
        PVector position = this.rigidbodyToEdit.getPosition();

        pushMatrix();
        translate(position.x, position.y);

        int color1 = color(0, 123, 185, 255);
        int color2 = color(32, 90, 119, 255);
        float t = (sin(millis() / 500.0f) + 1) / 2;
        int c = lerpColor(color1, color2, t); 
        
        if(this.circleVertexToDrag) {
            fill(color1);
            strokeWeight(0.018f);
            stroke(0, 0, 0, 175);
            ellipse(vertex.x, vertex.y, 0.24f, 0.24f);
        } else {
            fill(c);
            strokeWeight(0.018f);
            stroke(0, 0, 0, 175);
            ellipse(vertex.x, vertex.y, 0.24f, 0.24f);
        }
        popMatrix();
    }


    public void drawDragSelect() {
        PVector start = Mouse.getMouseDownCoordinates();
        PVector end = Mouse.getMouseCoordinates();
        rectMode(CORNERS);
        noFill();
        stroke(255);
        dash.rect(start.x, start.y, end.x, end.y);
    }

    public void drawCopiedRigidbodies() {
        if(this.inCopySelectMode) {
            for(Rigidbody rigidbody: this.rigidbodiesToCopy) {
                ShapeType shapeType = rigidbody.getShapeType();
                if(shapeType == ShapeType.BOX || shapeType == ShapeType.POLYGON) {
                    this.drawPolygon(rigidbody);
                } else if(shapeType == ShapeType.CIRCLE) {
                    this.drawCircle(rigidbody);
                }
            }
        }
    }


    public void drawPolygon(Rigidbody rigidbody) {
        PVector[] vertices = rigidbody.getVertices();
        fill(255, 255, 255, 166);
        stroke(0, 0, 0, 166);
        pushMatrix();
        translate(rigidbody.getPosition().x, rigidbody.getPosition().y);
        rotate(rigidbody.getAngle());
        beginShape();
        for(PVector vertex : vertices) {
            vertex(vertex.x, vertex.y);
        }
        endShape(CLOSE);
        popMatrix();
    }


    public void drawCircle(Rigidbody rigidbody) {
        fill(255, 255, 255, 166);
        stroke(0, 0, 0, 166);
        PVector position = rigidbody.getPosition();
        float radius = rigidbody.getRadius();

        pushMatrix();
        translate(position.x, position.y);
        ellipse(0, 0, radius * 2, radius * 2);
        popMatrix();
    }

/*
========================================= Vertex Methods ========================================
*/

    public int selectVertex(float radius) {
        PVector[] rigidbodyVertices = this.rigidbodyToEdit.GetTransformedVertices();

        for(int i = 0; i < rigidbodyVertices.length; i++) {
            if(PVector.sub(Camera.screenToWorld(), rigidbodyVertices[i]).magSq() < radius) {
                return i;
            }
        }
        return -1;
    }

    public boolean selectCircleVertex(float radius) {
        PVector vertex = PhysEngMath.Transform(new PVector(this.rigidbodyToEdit.getRadius(), 0), this.rigidbodyToEdit.getPosition(), this.rigidbodyToEdit.getAngle());
        if(PVector.sub(Camera.screenToWorld(), vertex).magSq() < radius) {
            return true;
        } else {
            return false;
        }
    }


    public boolean moveVertex() {
        ShapeType shapeType = rigidbodyToEdit.getShapeType();
        
        if(shapeType == ShapeType.BOX || shapeType == ShapeType.POLYGON) {
           return this.movePolygonVertex();
        } else if(shapeType == ShapeType.CIRCLE) {
            return this.moveCircleVertex();
        } else {
            throw new IllegalArgumentException("Unknown ShapeType");
        }
    }


    public boolean movePolygonVertex() {
        if(this.vertexIndexToDrag == -1) {
            return false;
        }

        PVector vertex = Camera.screenToWorld();
        PVector[] rigidbodyCoreVertices = this.rigidbodyToEdit.getVertices();

        PVector[] vertexList = Arrays.copyOf(rigidbodyCoreVertices, rigidbodyCoreVertices.length);

        PVector prevVertex = vertexList[(this.vertexIndexToDrag - 1 + vertexList.length) % vertexList.length];
        PVector nextVertex = vertexList[(this.vertexIndexToDrag + 1) % vertexList.length];

        PVector toPrev = PVector.sub(prevVertex, vertex);
        PVector toNext = PVector.sub(nextVertex, vertex);

        vertexList[this.vertexIndexToDrag] = PhysEngMath.ReverseTransform(vertex, this.rigidbodyToEdit.getPosition().copy().mult(-1), -this.rigidbodyToEdit.getAngle());

        PVector toPrevNew = PVector.sub(prevVertex, vertexList[this.vertexIndexToDrag]);
        PVector toNextNew = PVector.sub(nextVertex, vertexList[this.vertexIndexToDrag]);

        if (PVector.angleBetween(toPrev, toPrevNew) > PI || PVector.angleBetween(toNext, toNextNew) > PI) {
            vertexList[this.vertexIndexToDrag] = vertex;
        }

        if(!this.checkConvexity(vertexList)) {
            return true;
        }

        this.rigidbodyToEdit.updatePolygon(vertexList);
        return true;
    }



    public boolean moveCircleVertex() {
        if(!this.circleVertexToDrag){
            return false;
        }
        PVector newVertex = Camera.screenToWorld();

        PVector newRadiusVector = PVector.sub(this.rigidbodyToEdit.getPosition(), newVertex);

        this.rigidbodyToEdit.updateCircle(newRadiusVector.mag());
        return true;
    }



    public boolean addVertexOnClick() {

        if(!this.inEditMode) {
            return false;
        }

        ShapeType rigidbodyShapeType = this.rigidbodyToEdit.getShapeType();

        if(rigidbodyShapeType == ShapeType.CIRCLE) {
            return false;
        }

        PVector vertex = PhysEngMath.ReverseTransform(Camera.screenToWorld(), this.rigidbodyToEdit.getPosition().copy().mult(-1), -this.rigidbodyToEdit.getAngle());
        PVector[] rigidbodyVertices = this.rigidbodyToEdit.getVertices();
        PVector[] newRigidbodyVertices = new PVector[rigidbodyVertices.length + 1];

        for(int i = 0; i < rigidbodyVertices.length; i++) {
            newRigidbodyVertices[i] = rigidbodyVertices[i];
        }

        newRigidbodyVertices[newRigidbodyVertices.length - 1] = vertex;

        if(this.checkConvexity(PhysEngMath.OrderVerticesClockwise(newRigidbodyVertices))) {
            this.rigidbodyToEdit.updatePolygon(newRigidbodyVertices);
            return true;
        }
        return false;
    } 


    public void deleteVertex(int index) {
        if(index == -1) {
            return;
        }
        PVector[] vertices = this.rigidbodyToEdit.getVertices();
        PVector[] newVertices = new PVector[vertices.length - 1];

        ArrayList<PVector> vertexList = new ArrayList<PVector>(Arrays.asList(this.rigidbodyToEdit.getVertices()));
        vertexList.remove(index);
        this.rigidbodyToEdit.updatePolygon(vertexList.toArray(new PVector[vertexList.size()]));
    }


    public void dragSelect() {
        this.inDragSelectMode = false;
        this.dragBox = new AABB(Mouse.getMouseDownCoordinates(), Mouse.getMouseCoordinates(), true);
        if(this.dragBox.calculateArea() < 0.1f) {
            this.dragBox = null;
            IS_PAUSED = this.PAUSE_STATE_ON_OPEN;
            IS_PAUSED_LOCK = false;

            Rigidbody newRigidbody = Mouse.getRigidbodyUnderMouse();

            if(!this.inEditMode && newRigidbody!= null) {
                this.enterEditMode(newRigidbody);
                return;
            } 

            if(this.inEditMode && newRigidbody != this.rigidbodyToEdit && newRigidbody != null) {
                this.editModeSwitchRigidbody(newRigidbody);
                return;
            } 

            return;
        }

        for(Rigidbody rigidbody : rigidbodyList) {
            if(Collisions.IntersectAABB(dragBox,rigidbody.GetAABB())) {
                rigidbody.setStrokeColour(255, 0, 0);
                this.selectedRigidbodies.add(rigidbody);
            }
        }

        if(this.selectedRigidbodies.size() == 0) {
            this.dragBox = null;
            IS_PAUSED = this.PAUSE_STATE_ON_OPEN;
            IS_PAUSED_LOCK = false;
            return;
        } else {
            this.dragBox.recalculateMaxAndMin(this.selectedRigidbodies);
        }
    }



    public boolean dragStart() {
        if(Collisions.IntersectAABBWithPoint(this.dragBox, Camera.screenToWorld())) {
            this.initialDragPosition.set(Camera.screenToWorld());
            this.isSelectionBeingDragged = true;
            return true;
        } else {
            return false;
        }
    }

    public boolean dragMove() {
        if(this.isSelectionBeingDragged) {
            PVector mouseDragDifference = PVector.sub(Camera.screenToWorld(), this.initialDragPosition);
            this.dragBox.shiftAABB(mouseDragDifference);
            this.dragBox.recalculateMaxAndMin(this.selectedRigidbodies);

            for(Rigidbody rigidbody : this.selectedRigidbodies) {
                rigidbody.addPosition(mouseDragDifference);
            }
            this.initialDragPosition.set(Camera.screenToWorld());
            return true;
        } else {
            return false;
        
        }
    }

    // public boolean dragMove() {
    //     if(Collisions.IntersectAABBWithPoint(this.dragBox, Camera.screenToWorld())) {
    //         if(!isSelectionBeingDragged) {
    //             this.initialDragPosition.set(Camera.screenToWorld());
    //             this.isSelectionBeingDragged = true;
    //         } else {
    //             PVector mouseDragDifference = PVector.sub(Camera.screenToWorld(), this.initialDragPosition);
    //             this.dragBox.shiftAABB(mouseDragDifference);
    //             for(Rigidbody rigidbody : this.selectedRigidbodies) {
    //                 rigidbody.addPosition(mouseDragDifference);
    //             }
    //             this.initialDragPosition.set(Camera.screenToWorld());
    //         }
    //         return true;
    //     } else {
    //         return false;
    //     }
    // }


    public boolean checkConvexity(PVector[] Vertices) {
        if(Vertices.length < 4) {
            return true;
        }

        boolean isPositive = false;

        for(int i = 0; i < Vertices.length; i++) {
            PVector current = Vertices[i];
            PVector next = Vertices[(i + 1) % Vertices.length];
            PVector nextNext = Vertices[(i + 2) % Vertices.length];

            PVector edge1 = PVector.sub(next, current);
            PVector edge2 = PVector.sub(nextNext, next);

            float cross = edge1.cross(edge2).z;

            if(i == 0) {
                isPositive = cross > 0;
            } else if((cross > 0) != isPositive) {
                return false;
            }
        }

        return true;
    }



    public boolean selectShapeVertex() {
        if(this.inEditMode) {
            ShapeType shapeType = this.rigidbodyToEdit.getShapeType();
            if(shapeType == ShapeType.BOX || shapeType == ShapeType.POLYGON) {
                this.vertexIndexToDrag = this.selectVertex(VERTEX_SNAP_RADIUS);
                return true;
            } else if(shapeType == ShapeType.CIRCLE) {
                this.circleVertexToDrag = this.selectCircleVertex(VERTEX_SNAP_RADIUS);
                return true;
            }

            return false;
        }

        return false;
    }



    public void elementChangeListener() {
        for(UI_Element element : this.Window_Elements) {
            switch(element.getElementName()) {
                case "Density":
                    if(!PhysEngMath.Equals(this.prvDnsty, element.getValue())) {
                        this.rigidbodyToEdit.setDensity(element.getValue());
                        this.rigidbodyToEdit.updateRigidbody();
                    }
                    break;
                case "Restitution":
                    if(!PhysEngMath.Equals(this.prvRsttn, element.getValue())) {
                        this.rigidbodyToEdit.setRestitution(element.getValue());
                        this.rigidbodyToEdit.updateRigidbody();
                    }
                    break;
                case "Static":
                    if(this.prvStatic != element.getState()) {
                        this.rigidbodyToEdit.setIsStatic(element.getState());
                        this.rigidbodyToEdit.updateRigidbody();
                    }
                    break;
                case "Fixed Rotation":
                    if(this.prvFixRot != element.getState()) {
                        this.rigidbodyToEdit.setIsRotationallyStatic(element.getState());
                        this.rigidbodyToEdit.updateRigidbody();
                    }
                    break;
                case "Fixed Position":
                    if(this.prvFixPos != element.getState()) {
                        this.rigidbodyToEdit.setIsTranslationallyStatic(element.getState());
                        this.rigidbodyToEdit.setVelocity(new PVector());
                        this.rigidbodyToEdit.updateRigidbody();
                    }
                    break;
                case "Angle":
                    if(!PhysEngMath.Equals(this.prvAngle, element.getValue())) {
                        this.rigidbodyToEdit.setAngle(radians(element.getValue()));
                    }
                    break;
            }
        }
    }

/*
========================================= Mouse Interaction =======================================
*/  

    @Override
    public void interactionMousePress() {
        this.mouseDownTime = millis();
        /*----------------- Checks ----------------*/
        if(UI_Manager.hasWindowBeenInteractedWith) {
            return;
        }
        if(UI_Manager.getIsOverOrPressedWindows()) {
            return;
        }
        if(UI_Manager.HOT_BAR.getActiveSlotID() != 1) {
            return;
        } 
        if(this.mouseSpringAdded) {
            return;
        }
        /*----------------------------------------*/

        if(this.selectShapeVertex()) {
            return;
        }

        if(!this.inEditMode && this.selectedRigidbodies.size() != 0) {
            if(this.dragStart()) {
                return;
            }
        }    
    }
    @Override
    public void interactionMouseRelease() {
        /*----------------- Resets ----------------*/
        this.vertexIndexToDrag = -1;
        this.circleVertexToDrag = false;

        this.isSelectionBeingDragged = false;
        /*----------------------------------------*/

        //Drag select makes inDragSelectMode false
        if(this.inDragSelectMode) {
            this.dragSelect();
        }
    }


    @Override
    public void interactionMouseDrag() {
        /*----------------- Checks ----------------*/
        if(UI_Manager.hasWindowBeenInteractedWith) {
            return;
        }
        if(UI_Manager.getIsOverOrPressedWindows()) {
            return;
        }
        if(UI_Manager.HOT_BAR.getActiveSlotID() != 1) {
            return;
        }  
        if(this.mouseSpringAdded) {
            return;
        }
        /*----------------------------------------*/

        if(this.inEditMode) {
            if(!this.moveVertex()) {
                this.enterDragSelect();
            }
        } else if(!this.inEditMode && this.selectedRigidbodies.size() == 0) {
            this.enterDragSelect();

        } else if(!this.inEditMode && this.selectedRigidbodies.size() != 0) {
            if(!this.dragMove()) {
                this.enterDragSelect();
            }
        }     
    }

    @Override
    public void interactionMouseClick() {
        /*----------------- Checks ----------------*/
        if(UI_Manager.hasWindowBeenInteractedWith) {
            return;
        }
        if(UI_Manager.getIsOverOrPressedWindows()) {
            return;
        }
        if(UI_Manager.HOT_BAR.getActiveSlotID() != 1) {
            return;
        } 
        if(this.mouseSpringAdded) {
            return;
        }
        // if(!this.mac) {
        //     if(millis() - this.mouseDownTime > 100) {
        //         return;
        //     }
        // }
        
        if(millis() - this.mouseDownTime > 150) {
            return;
        }
        /*----------------------------------------*/

        if(this.enterEditModeOnClick()) {
            return;
        }

        if(this.addVertexOnClick()) {
            return;
        }

        if(this.selectedRigidbodiesOnClick()) {
            return;
        }

        if(this.copiedRigidbodiesOnClick()) {
            return;
        }
    }




    public boolean enterEditModeOnClick() {
        Rigidbody newRigidbody = Mouse.getRigidbodyUnderMouse();

        if(!this.inEditMode && newRigidbody!= null) {
            this.enterEditMode(newRigidbody);
            return true;
        } 

        if(this.inEditMode && newRigidbody != this.rigidbodyToEdit && newRigidbody != null) {
            this.editModeSwitchRigidbody(newRigidbody);
            return true;
        } 

        return false;
    }


    public void enterEditMode(Rigidbody newRigidbody) {
        VERTEX_SNAP_RADIUS = 0.5f;
        this.rigidbodyToEdit = newRigidbody;
        this.inEditMode = true;
        this.inDragSelectMode = false;
        this.dragBox = null;
        this.vertexIndexToDrag = -1;
        this.clearSelectedRigidbodies();
        this.onEditorActive();
    }

    public void editModeSwitchRigidbody(Rigidbody newRigidbody) {
        this.rigidbodyToEdit = newRigidbody;
        this.clearSelectedRigidbodies();
        this.onEditorActive();
    }


    public boolean selectedRigidbodiesOnClick() {
        if(this.selectedRigidbodies.size() != 0 && !this.inCopySelectMode) {
            IS_PAUSED_LOCK = false;
            IS_PAUSED = this.PAUSE_STATE_ON_OPEN;
            this.clearSelectedRigidbodies();
            this.dragBox = null;
            return true;
        }
        return false;
    }



    public void updateCopiedRigidbodyPosition() {
        if(this.inCopySelectMode) {
            for(Rigidbody rigidbody : this.rigidbodiesToCopy) {
                rigidbody.addPosition(PVector.sub(Camera.screenToWorld(), this.initialCopyMousePosition));
            }
            this.initialCopyMousePosition.set(Camera.screenToWorld());
        }
    }

    public void updateCopiedPosRelToAABBCenterToMouse() {

        if(this.dragBox == null) {
            throw new RuntimeException("DragBox is null");
        }

        PVector AABBCenter = this.dragBox.calculateCenter();
        PVector difference = PVector.sub(Camera.screenToWorld(), AABBCenter);

        for(Rigidbody rigidbody : this.rigidbodiesToCopy) {
            rigidbody.addPosition(difference);
        }
    }

    public void selectedRigidbodiesOnCopy() {

        if(this.selectedRigidbodies.size() != 0 && this.dragBox != null) {
            for(Rigidbody rigidbody : this.selectedRigidbodies) {
                Rigidbody copiedRigidbody = new Rigidbody();
                copiedRigidbody.copy(rigidbody);
                this.rigidbodiesToCopy.add(copiedRigidbody);
            }

            this.updateCopiedPosRelToAABBCenterToMouse();

            this.inCopySelectMode = true;
            this.inDragSelectMode = false;
            this.inEditMode = false;
            this.vertexIndexToDrag = -1;
            this.clearSelectedRigidbodies();
            this.dragBox = null;
            this.initialCopyMousePosition.set(Camera.screenToWorld());
        }
    }

    public boolean copiedRigidbodiesOnClick() {
        if(this.inCopySelectMode) {
            this.inCopySelectMode = false;
            this.onWindowClose();
            return true;
        } 
        return false;
    }

    public void copiedRigidbodiesOnPaste() {
        ArrayList<Rigidbody> newCopyList = new ArrayList<Rigidbody>();
        for(Rigidbody rigidbody : this.rigidbodiesToCopy) {
            Rigidbody newRigidbody = new Rigidbody();
            newRigidbody.copy(rigidbody);
            newCopyList.add(newRigidbody);
            AddBodyToBodyEntityList(rigidbody);
        }

        this.clearCopiedRigidbodies();
        this.inCopySelectMode = true;
        this.rigidbodiesToCopy = newCopyList;
        this.initialCopyMousePosition.set(Camera.screenToWorld());
    }

    public void enterDragSelect() {
        this.inDragSelectMode = true;
        this.inEditMode = false;
        this.vertexIndexToDrag = -1;
        this.clearSelectedRigidbodies();
        this.dragBox = null;
        IS_PAUSED = true;
        IS_PAUSED_LOCK = true;
    }

    public void endDragSelectMode() {
        this.inDragSelectMode = false;
        this.inEditMode = false;
        this.vertexIndexToDrag = -1;
        this.clearSelectedRigidbodies();
        this.dragBox = null;
        IS_PAUSED = this.PAUSE_STATE_ON_OPEN;
        IS_PAUSED_LOCK = false;
    }


    public void clearSelectedRigidbodies() {
        for(Rigidbody rigidbody : this.selectedRigidbodies) {
            rigidbody.setStrokeColour(0, 0, 0);
        }
        this.selectedRigidbodies.clear();
    }

    public void clearCopiedRigidbodies() {
        for(Rigidbody rigidbody : this.rigidbodiesToCopy) {
            rigidbody.setStrokeColour(0, 0, 0);
        }
        this.rigidbodiesToCopy.clear();
    }

/*
======================================== Window Interaction ========================================
*/

    @Override
    public void onWindowClose() {
        this.Window_Visibility = false;
        this.isMouseOverWindow = false;
        this.isMouseOverWindowTextContainer = false;
        this.isMouseOverWindowFormContainer = false;
        this.wasMousePressedOverWindow = false;
        this.isActiveWindow = false;

        this.dragBox = null;
        this.inEditMode = false;
        this.inDragSelectMode = false;
        this.vertexIndexToDrag = -1;
        this.circleVertexToDrag = false;

        this.rigidbodyToEdit = null;

        this.clearCopiedRigidbodies();
        this.clearSelectedRigidbodies();
        Mouse.getMouseObjectResults().clear();
        IS_PAUSED = this.PAUSE_STATE_ON_OPEN;
        IS_PAUSED_LOCK = false;
        VERTEX_SNAP_RADIUS = 0.25f;
    }

    public void onWindowCloseNoPause() {
        this.Window_Visibility = false;
        this.isMouseOverWindow = false;
        this.isMouseOverWindowTextContainer = false;
        this.isMouseOverWindowFormContainer = false;
        this.wasMousePressedOverWindow = false;
        this.isActiveWindow = false;

        this.dragBox = null;
        this.inEditMode = false;
        this.inDragSelectMode = false;
        this.vertexIndexToDrag = -1;
        this.circleVertexToDrag = false;

        this.rigidbodiesToCopy.clear();

        this.clearSelectedRigidbodies();
        VERTEX_SNAP_RADIUS = 0.25f;
        this.rigidbodyToEdit = null;
    }


    @Override
    public void onWindowSelect() {
        this.deselectAllWindows();
        this.isActiveWindow = true;
        UI_Manager.bringToFront(this);
        this.Window_Container.getChild("Window_Container_Stroke").setStroke(UI_Constants.BLUE_SELECTED);
        this.Window_Container.getChild("Window_Text_Container").setFill(UI_Constants.BLUE_UNSELECTED);
    }


    public void selectLock() {
        this.isActiveWindow = true;
        this.Window_Container.getChild("Window_Container_Stroke").setStroke(UI_Constants.BLUE_SELECTED);
        this.Window_Container.getChild("Window_Text_Container").setFill(UI_Constants.BLUE_UNSELECTED);
    }

    public void rigidbodyDeletion() {
        if(this.selectedRigidbodies.size() == 0) {
            // Rigidbody rigidbodyToDelete = Mouse.getCurrentRigidbodyUnderMouse();

            // if(rigidbodyToDelete == null) {
            //     return;
            // }

            // this.selectedRigidbodies.remove(rigidbodyToDelete);
            // rigidbodyToDelete.delete();

            return;

        } else {
            for(Rigidbody rigidbody : this.selectedRigidbodies) {
                rigidbody.delete();
            }
            this.selectedRigidbodies.clear();
            this.endDragSelectMode();
        }

    }

    
/*
========================================= Key Press ========================================
*/



    @Override
    public void onKeyPress(int keyCode) {
        int activeSlotID = UI_Manager.HOT_BAR.getActiveSlotID();
        boolean shiftDown = KeyHandler.isKeyDown(KeyEvent.VK_SHIFT);

        switch(keyCode) {
            case KeyEvent.VK_DELETE:
                if(this.rigidbodyToEdit != null) {
                    this.deleteVertex(this.selectVertex(VERTEX_SNAP_RADIUS));
                } else {
                    this.rigidbodyDeletion();
                }
                break;
            case BACKSPACE:
                if(this.rigidbodyToEdit != null) {
                    this.deleteVertex(this.selectVertex(VERTEX_SNAP_RADIUS));
                } else {
                    this.rigidbodyDeletion();
                }
                break;
            case KeyEvent.VK_ENTER:
                this.onWindowClose();
                break;
            case KeyEvent.VK_C: 
                if(KeyHandler.isKeyDown(KeyEvent.VK_CONTROL)) {
                    this.selectedRigidbodiesOnCopy();
                }
                break;
            case KeyEvent.VK_V:
                if(KeyHandler.isKeyDown(KeyEvent.VK_CONTROL)) {
                    this.copiedRigidbodiesOnPaste();
                }
                break;
        }
    }

    /*
    ========================================= Getters & Setters ========================================
    */

    public boolean getInEditMode() {
        return this.inEditMode;
    }

    public ArrayList<Rigidbody> getSelectedRigidbodies() {
        return this.selectedRigidbodies;
    }

    public void setMouseSpringAdded(boolean mouseSpringAdded) {
        this.mouseSpringAdded = mouseSpringAdded;
    }
}



public class UI_PropertiesForceWindow extends UI_Window {



    private boolean hasInit = false;


    private boolean MOUSE_SPRING_ADDED;
    private Spring mouseSpring = new Spring();
/*
======================================= Element Values =============================================
*/  
    private float prvSprngConst = 100;
    private float prvEqlbrmLng = 1;
    private float prvDamping = 0.5f;
    private boolean prvLockYTrnsltn = false;
    private boolean prvLockXTrnsltn = false;
    private boolean prvPrfctSprng = false;

    private boolean prvJoint = false;

    private boolean prvDrawMotor = true;
    private float prvMotorSpeed = 0;

    public UI_PropertiesForceWindow() {
        super("Properties (forces)", 1, new PVector(width/4, 1.5f * height / 3));
        initialize();
    }

/*
======================================= UI ELEMENTS ================================================
*/

    public void initialize() {

    }

    @Override
    public void onSlotChange(int previousSlotID) {
        this.onWindowSelect();
        
        if(!hasInit) {
            switch(UI_Manager.HOT_BAR.getActiveSlotID()) {
                case 4:
                    this.onSpringActive();
                    this.hasInit = true;
                    break;
                case 5:
                    this.onRodActive();
                    this.hasInit = true;
                    break;
                case 6:
                    this.onMotorActive();
                    this.hasInit = true;
                    break;
            }

            this.Window_Visibility = true;

            return;
        }

        this.Window_Visibility = true;

        switch(UI_Manager.HOT_BAR.getActiveSlotID()) {
            case 4:
                this.onSpringActive();
                break;
            case 5:
                this.onRodActive();
                break;
            case 6:
                this.onMotorActive();
                break;
        }
    }

    public void onSpringActive() {
        this.savePrevElementStates();
        this.clearAllElements();
        this.HotBarSlotRepresentation = "Spring";
        this.addElement(new UI_Slider("Spring Constant", (UI_Window)this, 0, 300, prvSprngConst));
        this.addElement(new UI_Slider("Equilibrium Length", (UI_Window)this, 0, 10, prvEqlbrmLng));
        this.addElement(new UI_Slider("Damping", (UI_Window)this, 0, 1, prvDamping));
        this.addElement(new UI_Toggle("Lock Y Translation", (UI_Window)this, "Translation", prvLockYTrnsltn));
        this.addElement(new UI_Toggle("Lock X Translation", (UI_Window)this, "Translation", prvLockXTrnsltn));
        this.addElement(new UI_Toggle("Perfect Spring", (UI_Window)this, prvPrfctSprng));
    }

    public void onRodActive() {
        this.savePrevElementStates();
        this.clearAllElements();
        this.HotBarSlotRepresentation = "Rod";
        this.addElement(new UI_Toggle("Joint", (UI_Window)this, prvJoint));
    }

    public void onMotorActive() {
        this.savePrevElementStates();
        this.clearAllElements();
        this.HotBarSlotRepresentation = "Motor";
        this.addElement(new UI_Toggle("Draw Motor", (UI_Window)this, prvDrawMotor));
        this.addElement(new UI_Slider("Motor Speed", (UI_Window)this, -20, 20, prvMotorSpeed));
    }

    public void savePrevElementStates() {
        if(!this.hasInit) {
            return;
        }

        switch (this.HotBarSlotRepresentation) {
            case "Spring":
                this.prvSprngConst = this.getElementByName("Spring Constant").getValue();
                this.prvEqlbrmLng = this.getElementByName("Equilibrium Length").getValue();
                this.prvDamping = this.getElementByName("Damping").getValue();
                this.prvLockYTrnsltn = this.getElementByName("Lock Y Translation").getState();
                this.prvLockXTrnsltn = this.getElementByName("Lock X Translation").getState();
                this.prvPrfctSprng = this.getElementByName("Perfect Spring").getState();
                break;
            case "Rod":
                this.prvJoint = this.getElementByName("Joint").getState();
                break;
            case "Motor":
                this.prvDrawMotor = this.getElementByName("Draw Motor").getState();
                this.prvMotorSpeed = this.getElementByName("Motor Speed").getValue();
                break;
        }
    }
/*
========================================= Force Drawing ============================================
*/
    @Override
    public void interactionDraw() {
        if(UI_Manager.getIsOverOrPressedWindows()) {
            return;
        }
        this.drawForces();
    }







    public void drawForces() {

        /*---------------------------------- Checks --------------------------------------*/
        int activeSlotID = UI_Manager.HOT_BAR.getActiveSlotID();
        if(activeSlotID != 4 && activeSlotID != 5 && activeSlotID != 6) {
            return;
        }
        
        ArrayList<MouseObjectResult> mouseObjectResults = Mouse.getMouseObjectResults();
        if(mouseObjectResults.size() == 0 || mouseObjectResults.size() > 1) {
            return;
        } else if(mouseObjectResults.size() == 1 && (UI_Manager.getIsPressedOverWindow())) {
            mouseObjectResults.clear();
            return;
        }
        /*--------------------------------------------------------------------------------*/


        PVector worldAnchorA;
        PVector worldAnchorB;
        Rigidbody rigidbodyToDrawFrom;


        
        rigidbodyToDrawFrom = mouseObjectResults.get(0).getSelectedRigidbody();
        
        if(rigidbodyToDrawFrom != null) {
            worldAnchorA = PhysEngMath.Transform(mouseObjectResults.get(0).getTransformedLocalCoordinate(), rigidbodyToDrawFrom.getPosition(), rigidbodyToDrawFrom.getAngle());
            worldAnchorB = Mouse.getMouseCoordinates();
        } else {
            worldAnchorA = mouseObjectResults.get(0).getWorldCoordinate();
            worldAnchorB = Mouse.getMouseCoordinates();
        }

        switch(activeSlotID) {
            case 4:
                this.drawSpring(worldAnchorA, worldAnchorB, rigidbodyToDrawFrom);
                break;
            case 5:
                this.drawRod(worldAnchorA, worldAnchorB, rigidbodyToDrawFrom);
                break;
            case 6:
                this.drawMotor(worldAnchorA, worldAnchorB, rigidbodyToDrawFrom);
                break;
        }
    }   


    public void drawSpring(PVector worldAnchorA, PVector worldAnchorB, Rigidbody rigidbodyToDrawFrom) {
        PVector direction = PVector.sub(worldAnchorA, worldAnchorB);
        float length = direction.mag();
        direction.normalize();
    
        float segments = 5;
        float segmentLength = length / segments;
        float offsetMagnitude = 0.5f; // Adjust this value to change the size of the zigzags
    
        // Draw the rod
        strokeWeight(0.3f);
        stroke(0, 0, 0, 166); // Black
        line(worldAnchorA.x, worldAnchorA.y, worldAnchorB.x, worldAnchorB.y);
        stroke(255, 255, 255, 166); // White
        strokeWeight(0.1f);
        line(worldAnchorA.x, worldAnchorA.y, worldAnchorB.x, worldAnchorB.y);
    
        for(int i = 0; i < segments; i++) {
            PVector segmentStart = PVector.add(worldAnchorB, PVector.mult(direction, segmentLength * i));
            PVector segmentEnd = PVector.add(worldAnchorB, PVector.mult(direction, segmentLength * (i + 1)));
    
            // Calculate the midpoint of the segment
            PVector midPoint = PVector.lerp(segmentStart, segmentEnd, 0.5f);
    
            // Alternate the offset direction to give appearance of spring
            PVector offset;
            if(i % 2 == 0) {
                offset = PVector.mult(new PVector(-direction.y, direction.x), offsetMagnitude);
            } else {
                offset = PVector.mult(new PVector(direction.y, -direction.x), offsetMagnitude);
            }
    
            // Add the offset to the midpoint
            PVector midPointOffset = PVector.add(midPoint, offset);
    
            // Draw the lines
            strokeWeight(0.2f);
            stroke(0, 0, 0, 166);
            line(segmentStart.x, segmentStart.y, midPointOffset.x, midPointOffset.y);
            line(midPointOffset.x, midPointOffset.y, segmentEnd.x, segmentEnd.y);
            strokeWeight(0.1f);
            stroke(255, 255, 255, 166);
            line(segmentStart.x, segmentStart.y, midPointOffset.x, midPointOffset.y);
            line(midPointOffset.x, midPointOffset.y, segmentEnd.x, segmentEnd.y);
        }
    }


    public void drawRod(PVector worldAnchorA, PVector worldAnchorB, Rigidbody rigidbodyToDrawFrom) {
        strokeWeight(0.15f);
        stroke(0, 0, 0, 166);
        line(worldAnchorA.x, worldAnchorA.y, worldAnchorB.x, worldAnchorB.y);
        strokeWeight(0.1f);
        stroke(255, 255, 255, 166);
        line(worldAnchorA.x, worldAnchorA.y, worldAnchorB.x, worldAnchorB.y);
    }



    public void drawMotor(PVector worldAnchorA, PVector worldAnchorB, Rigidbody rigidbodyToDrawFrom) {
        if(rigidbodyToDrawFrom == null) {
                return;
        }

        PVector position = rigidbodyToDrawFrom.getPosition();
        boolean isClockwise = this.getElementByName("Motor Speed").getValue() > 0;

        float size = rigidbodyToDrawFrom.getRadius() * 0.5f;
        float arrowSize = size * 0.15f;
        float startAngle = 0;
        float endAngle = 3 * PI/2;
            
        pushMatrix();
        translate(position.x, position.y);
        rotate(rigidbodyToDrawFrom.getAngle() + PI/6);

        noFill();
        strokeWeight(0.1f);
        stroke(255, 0, 0, 166);
        arc(0, 0, size, size, startAngle, endAngle);

        // Calculate the start and end of the arc
        float startX =  size * cos(startAngle)/2;
        float startY = size * sin(startAngle)/2;
        float endX = size * cos(endAngle)/2;
        float endY = size * sin(endAngle)/2;
            
        if(isClockwise) {
            strokeWeight(0.1f);
            stroke(255, 0, 0, 166);
            triangle(endX, endY-arrowSize, endX, endY+arrowSize, endX+arrowSize*2, endY);
        } else {
            strokeWeight(0.1f);
            stroke(255, 0, 0, 166);
            triangle(startX-arrowSize, startY, startX + arrowSize, startY, startX, startY - 2 * arrowSize);
        }
        popMatrix();

    }


/*
========================================= Force Creation ==============================================
*/  
    @Override
    public void interactionMousePress() {
        if(UI_Manager.hasWindowBeenInteractedWith) {
            return;
        }

        if(UI_Manager.getIsOverOrPressedWindows()){
            return;
        }

        this.addMouseSpring();
    }

    @Override
    public void interactionMouseDrag() {
        if(this.MOUSE_SPRING_ADDED) {
            PVector mouseCoordinates = Mouse.getMouseCoordinates();
            mouseSpring.setAnchorPoint(mouseCoordinates);
        }
    }
    @Override
    public void interactionMouseRelease() {
        if(UI_Manager.getIsOverOrPressedWindows()) {
            return;
        }

        if(UI_Manager.hasWindowBeenInteractedWith) {
            Mouse.getMouseObjectResults().clear();
            return;
        }

        if(this.MOUSE_SPRING_ADDED) {
            this.removeMouseSpring();
            Mouse.clearMouseObjectResults();
            return;
        } 

        this.createForces();
        return;
    }







    public void createForces() {
        /*---------------------------------- Checks --------------------------------------*/
        int activeSlotID = UI_Manager.HOT_BAR.getActiveSlotID();
        if(activeSlotID != 4 && activeSlotID != 5 && activeSlotID != 6 && !Mouse.getIsMouseDownLeft()) {
            return;
        }

        ArrayList<MouseObjectResult> mouseObjectResults = Mouse.getMouseObjectResults();
        if(mouseObjectResults.size() == 0 || mouseObjectResults.size() == 1){
            return;
        }
        /*--------------------------------------------------------------------------------*/

        PVector mouseCoordinates = Mouse.getMouseCoordinates();

        Rigidbody rigidbody1 = mouseObjectResults.get(0).getSelectedRigidbody();
        Rigidbody rigidbody2 = mouseObjectResults.get(1).getSelectedRigidbody();
        PVector anchor1 = mouseObjectResults.get(0).getTransformedLocalCoordinate();
        PVector anchor2 = mouseObjectResults.get(1).getTransformedLocalCoordinate();

        Rigidbody[] rigidbodyArray = new Rigidbody[0];
        PVector[] anchorArray = new PVector[0];

        if(rigidbody1 != null && rigidbody2 == null) {
            rigidbodyArray = new Rigidbody[]{rigidbody1};
            anchorArray = new PVector[]{anchor1, anchor2};
        } else if(rigidbody1 == null && rigidbody2 != null){
            rigidbodyArray = new Rigidbody[]{rigidbody2};
            anchorArray = new PVector[]{anchor2, anchor1};
        } else if(rigidbody1 != null && rigidbody2 != null) {
            rigidbodyArray = new Rigidbody[]{rigidbody1, rigidbody2};
            anchorArray = new PVector[]{anchor1, anchor2};
        } else if(rigidbody1 == null && rigidbody2 == null) {
            return;
        }

        mouseObjectResults.clear();

        switch(activeSlotID) {
            case 4:
                this.createSpring(rigidbodyArray, anchorArray);
                break;
            case 5:
                this.createRod(rigidbodyArray, anchorArray);
                break;
            case 6:
                this.createMotor(rigidbodyArray, anchorArray);
                break;
        }
    }

    public void createSpring(Rigidbody[] rigidbodyArray, PVector[] anchorArray) {
        Spring spring;

        if(rigidbodyArray.length == 1) {
            spring = new Spring(rigidbodyArray[0], anchorArray[0], anchorArray[1]);
            ALL_FORCES_ARRAYLIST.add(spring);
            rigidbodyArray[0].addForceToForceRegistry(spring);

        } else if(rigidbodyArray.length == 2) {
            spring = new Spring(rigidbodyArray[0], rigidbodyArray[1], anchorArray[0], anchorArray[1]);
            ALL_FORCES_ARRAYLIST.add(spring);
            rigidbodyArray[0].addForceToForceRegistry(spring);
            rigidbodyArray[1].addForceToForceRegistry(spring);
        } else {
            throw new IllegalArgumentException("RigidbodyArray is 0");
        }

        spring.setSpringConstant(this.getElementByName("Spring Constant").getValue());
        spring.setEquilibriumLength(this.getElementByName("Equilibrium Length").getValue());
        spring.setDamping(this.getElementByName("Damping").getValue());
        spring.setLockTranslationToXAxis(this.getElementByName("Lock Y Translation").getState());
        spring.setLockTranslationToYAxis(this.getElementByName("Lock X Translation").getState());
        spring.setPerfectSpring(this.getElementByName("Perfect Spring").getState());
    }


    public void createRod(Rigidbody[] rigidbodyArray, PVector[] anchorArray) {
        Rod rod;

        if(rigidbodyArray.length == 1) {
            rod = new Rod(rigidbodyArray[0], anchorArray[0], anchorArray[1]);
            ALL_FORCES_ARRAYLIST.add(rod);
            rigidbodyArray[0].addForceToForceRegistry(rod);
        } else if(rigidbodyArray.length == 2) {
            rod = new Rod(rigidbodyArray[0], rigidbodyArray[1], anchorArray[0], anchorArray[1]);
            ALL_FORCES_ARRAYLIST.add(rod);
            rigidbodyArray[0].addForceToForceRegistry(rod);
            rigidbodyArray[1].addForceToForceRegistry(rod);
        } else {
            throw new IllegalArgumentException("RigidbodyArray is 0");
        }
        rod.setIsJoint(this.getElementByName("Joint").getState());
    }


    public void createMotor(Rigidbody[] rigidbodyArray, PVector[] anchorArray) {
        Motor motor = new Motor(rigidbodyArray[0], this.getElementByName("Motor Speed").getValue());

            ///motor.setDrawMotor(this.TOGGLE_STATES[7]);
            motor.setDrawMotorForce(this.getElementByName("Draw Motor").getState());
            Iterator<ForceRegistry> iterator = rigidbodyArray[0].getForceRegistry().iterator();

            while (iterator.hasNext()) {
                ForceRegistry force = iterator.next();
                if (force instanceof Motor) {
                    iterator.remove();
                    ALL_FORCES_ARRAYLIST.remove(force);
                }
            }

            ALL_FORCES_ARRAYLIST.add(motor);
            rigidbodyArray[0].addForceToForceRegistry(motor);
    }

/*
========================================= Mouse Spring ==============================================
*/
    public void addMouseSpring() {
        if(KeyHandler.isKeyDown(KeyEvent.VK_SHIFT) && !this.MOUSE_SPRING_ADDED) {
            Rigidbody rigidbody = Mouse.getCurrentRigidbodyUnderMouse();

            if(rigidbody != null){
                PVector mouseCoordinates = Mouse.getMouseCoordinates();
                PVector localAnchorA = PhysEngMath.Transform(PhysEngMath.SnapController(Mouse, rigidbody, mouseCoordinates), -rigidbody.getAngle());

                mouseSpring.setRigidbodyA(rigidbody);
                mouseSpring.setLocalAnchorA(localAnchorA);
                mouseSpring.setAnchorPoint(mouseCoordinates);
                mouseSpring.setSpringConstant(200);
                mouseSpring.setDamping(0.8f); 
                mouseSpring.setEquilibriumLength(0.2f);  
                rigidbody.addForceToForceRegistry(mouseSpring);
                this.MOUSE_SPRING_ADDED = true;
                UI_Manager.getPropertiesRigidbodyWindow().setMouseSpringAdded(true);
                UI_Manager.getPropertiesEditorWindow().setMouseSpringAdded(true);
                
            } 
        }
    }

    public void removeMouseSpring() {
        if(mouseSpring.getRigidbodyA() != null && this.MOUSE_SPRING_ADDED) {
            mouseSpring.getRigidbodyA().removeForceFromForceRegistry(mouseSpring);
            mouseSpring.setRigidbodyA(null);
            this.MOUSE_SPRING_ADDED = false;
            UI_Manager.getPropertiesEditorWindow().setMouseSpringAdded(false);
        }
    }


/*
======================================= Key Interaction ========================================
*/
        
    /* Assumes input is a keyCode that has definitely been pressed */
    @Override
    public void onKeyPress(int keyCode) {
        int activeSlotID = UI_Manager.HOT_BAR.getActiveSlotID();
        boolean shiftDown = KeyHandler.isKeyDown(KeyEvent.VK_SHIFT);

        switch(keyCode) {
            case KeyEvent.VK_A:
                if(activeSlotID == 4) {
                    if(shiftDown) {
                        this.getElementByName("Spring Constant").incrementValue(-10f);
                    } else {
                        this.getElementByName("Spring Constant").incrementValue(-5f);
                    }
                } else if(activeSlotID == 6) {
                    if(shiftDown) {
                        this.getElementByName("Motor Speed").incrementValue(-2f);
                    } else {
                        this.getElementByName("Motor Speed").incrementValue(-1f);
                    }
                }
                break;
            case KeyEvent.VK_D:
                if(activeSlotID == 4) {
                    if(shiftDown) {
                        this.getElementByName("Spring Constant").incrementValue(10f);
                    } else {
                        this.getElementByName("Spring Constant").incrementValue(5f);
                    }
                } else if(activeSlotID == 6) {
                    if(shiftDown) {
                        this.getElementByName("Motor Speed").incrementValue(2f);
                    } else {
                        this.getElementByName("Motor Speed").incrementValue(1f);
                    }
                }
                break;
            case KeyEvent.VK_W:
                if(activeSlotID == 4) {
                    if(shiftDown) {
                        this.getElementByName("Equilibrium Length").incrementValue(1f);
                    } else {
                        this.getElementByName("Equilibrium Length").incrementValue(0.5f);
                    }
                }
                break;
            case KeyEvent.VK_S:
                if(activeSlotID == 4) {
                    if(shiftDown) {
                        this.getElementByName("Equilibrium Length").incrementValue(-1f);
                    } else {
                        this.getElementByName("Equilibrium Length").incrementValue(-0.5f);
                    }
                }
                break;
        }

    }


}
public class UI_PropertiesRigidbodyWindow extends UI_Window {

    private boolean allowVelocityLine = false;
    private boolean wasMouseSpringAdded = false;
    private boolean hasInit = false;

    private float prvBdyDnsty = 1;
    private float prvBdyRsttn = 0.5f;
    private float prvBdyRds = 1;
    private float prvBdyWdth = 2;
    private float prvBdyHght = 2;
    private float prvBdyAngl = 0;

    private boolean prvSttc = false;
    private boolean prvFxRttn = false;
    private boolean prvFxPstn = false;



    public UI_PropertiesRigidbodyWindow() {
        super("Properties (rigidbody)", 0, new PVector(2 * width / 3, 1.5f * height / 3));
        this.initialize();
    }

/*
========================================= UI Elements  =============================================
*/
    public void initialize() {
    }

    @Override
    public void onSlotChange(int previousSlotID) { 
        this.onWindowSelect();

        if(!hasInit) {
            switch(UI_Manager.HOT_BAR.getActiveSlotID()) {
                case 2:
                    this.onCircleActive();
                    this.hasInit = true;
                    break;
                case 3:
                    this.onRectangleActive();
                    this.hasInit = true;
                    break;
            }
        }

            switch(UI_Manager.HOT_BAR.getActiveSlotID()) {
                case 2:
                    this.onCircleActive();
                    break;
                case 3:
                    this.onRectangleActive();
                    break;
            }
        this.Window_Visibility = true;
        
    }

    public void onCircleActive() {
        this.savePrevElementStates();
        this.clearAllElements();
        this.HotBarSlotRepresentation = "Circle";
        this.addElement(new UI_Slider("Density", (UI_Window)this, MIN_BODY_DENSITY, MAX_BODY_DENSITY, prvBdyDnsty));
        this.addElement(new UI_Slider("Restitution", (UI_Window)this, 0, 1, prvBdyRsttn));
        this.addElement(new UI_Slider("Radius", (UI_Window)this, MIN_BODY_RADIUS, MAX_BODY_RADIUS, prvBdyRds));
        this.addElement(new UI_Toggle("Static", (UI_Window)this, "Staticity", prvSttc));
        this.addElement(new UI_Toggle("Fixed Rotation", (UI_Window)this, "Staticity", prvFxRttn));
        this.addElement(new UI_Toggle("Fixed Position", (UI_Window)this, "Staticity", prvFxPstn));
        this.addElement(new UI_Slider("Angle", (UI_Window)this, -360, 360, prvBdyAngl));
    } 

    public void onRectangleActive() {
        this.savePrevElementStates();
        this.clearAllElements();
        this.HotBarSlotRepresentation = "Rectangle";
        this.addElement(new UI_Slider("Density", (UI_Window)this, MIN_BODY_DENSITY, MAX_BODY_DENSITY, prvBdyDnsty));
        this.addElement(new UI_Slider("Restitution", (UI_Window)this, 0, 1, prvBdyRsttn));
        this.addElement(new UI_Slider("Width", (UI_Window)this, MIN_BODY_WIDTH, MAX_BODY_WIDTH, prvBdyWdth));
        this.addElement(new UI_Slider("Height", (UI_Window)this, MIN_BODY_HEIGHT, MAX_BODY_HEIGHT, prvBdyHght));
        this.addElement(new UI_Toggle("Static", (UI_Window)this, "Staticity", prvSttc));
        this.addElement(new UI_Toggle("Fixed Rotation", (UI_Window)this, "Staticity", prvFxRttn));
        this.addElement(new UI_Toggle("Fixed Position", (UI_Window)this, "Staticity", prvFxPstn));
        this.addElement(new UI_Slider("Angle", (UI_Window)this, -360, 360, prvBdyAngl));
    }

    public void savePrevElementStates() {
        if(!this.hasInit) {
            return;
        }

        switch (this.HotBarSlotRepresentation) {
            case "Circle":
                this.prvBdyRds = this.getElementByName("Radius").getValue();
                this.prvBdyDnsty = this.getElementByName("Density").getValue();
                this.prvBdyRsttn = this.getElementByName("Restitution").getValue();
                this.prvSttc = this.getElementByName("Static").getState();
                this.prvFxRttn = this.getElementByName("Fixed Rotation").getState();
                this.prvFxPstn = this.getElementByName("Fixed Position").getState();
                this.prvBdyAngl = this.getElementByName("Angle").getValue();
                break;
            case "Rectangle":
                this.prvBdyWdth = this.getElementByName("Width").getValue();
                this.prvBdyHght = this.getElementByName("Height").getValue();
                this.prvBdyDnsty = this.getElementByName("Density").getValue();
                this.prvBdyRsttn = this.getElementByName("Restitution").getValue();
                this.prvSttc = this.getElementByName("Static").getState();
                this.prvFxRttn = this.getElementByName("Fixed Rotation").getState();
                this.prvFxPstn = this.getElementByName("Fixed Position").getState();
                this.prvBdyAngl = this.getElementByName("Angle").getValue();
                break;
        }
    }
/*
========================================= Rigidbody Drawing ========================================
*/ 
    @Override
    public void interactionDraw() {
        if(UI_Manager.getIsOverOrPressedWindows()) {
            return;
        }
        
        int activeSlotID = UI_Manager.HOT_BAR.getActiveSlotID();

        if(activeSlotID == 2 || activeSlotID == 3) {
            this.drawVelocityLine();
            this.drawRigidbody(activeSlotID);
            return;
        }
    }





    public void drawRigidbody(int activeSlotID) {

        float angle = radians(this.getElementByName("Angle").getValue());
        PVector position = new PVector();
            if(Mouse.getIsMouseDownLeft() == true && !this.wasMouseSpringAdded) {
                position.set(PhysEngMath.MouseVelocityCalculationAndClamp(Mouse.getMouseDownCoordinates(), 
                                                                          Mouse.getMouseCoordinates(), 
                                                                          MIN_MOUSE_VELOCITY_MAG, 
                                                                          MAX_MOUSE_VELOCITY_MAG));
                position.add(Mouse.getMouseDownCoordinates());
            } else {
                position.set(Mouse.getMouseCoordinates());
            }


        if(activeSlotID == 2) {
            this.drawCircle(position, angle);
        } else if(activeSlotID == 3) {
            this.drawRectangle(position, angle);
        }
    }

    public void drawCircle(PVector position, float angle) {
        pushMatrix();
        translate(position.x, position.y);
        rotate(angle);
            float radius = this.getElementByName("Radius").getValue();
            float diameter = radius * 2.0f;

            fill(255, 255, 255, 166);
            stroke(0, 0, 0, 166);
            strokeWeight(0.1f);
            ellipseMode(CENTER);
            ellipse(0, 0, diameter,  diameter);

            PVector va = new PVector();
            PVector vb = new  PVector(radius, 0);
            va = PhysEngMath.Transform(va, new PVector(), angle);
            vb = PhysEngMath.Transform(vb, new PVector(), angle);

            line(va.x, va.y, vb.x, vb.y);
        popMatrix();
    }

    public void drawRectangle(PVector position, float angle) {
        pushMatrix();
        translate(position.x, position.y);
        rotate(angle);
            fill(255, 255, 255, 166);
            stroke(0, 0, 0, 166);
            strokeWeight(0.1f);
            rectMode(CENTER);
            rect(0, 0, this.getElementByName("Width").getValue(), this.getElementByName("Height").getValue());
        popMatrix();
    }


/*
========================================= Rigidbody Creation =======================================
*/  
    @Override
    public void interactionMouseRelease() {
        if(UI_Manager.hasWindowBeenInteractedWith) {
            return;
        }

        if(UI_Manager.getIsOverOrPressedWindows()) {
            return;
        }

        int activeSlotID = UI_Manager.HOT_BAR.getActiveSlotID();

        if(activeSlotID == 2 || activeSlotID == 3) {
            if(!this.wasMouseSpringAdded) {
                this.createRigidbody(activeSlotID);
                return;
            }
        }
        this.wasMouseSpringAdded = false;
    }







    public void createRigidbody(int activeSlotID) {
        /*--------------------------------- Checks ---------------------------------*/
        if(Mouse.getRigidbodyUnderMouse() != null && !IS_PAUSED) {
            return;
        }
        /*---------------------------------------------------------------------------*/


        if(activeSlotID == 2) { 
            this.createCircle();
        } else if(activeSlotID == 3) {
            this.createRectangle();
        }


    }

    public void createCircle() {
        Rigidbody rigidbody = RigidbodyGenerator.CreateCircleBody(this.getElementByName("Radius").getValue(),
                                                                  this.getElementByName("Density").getValue(),
                                                                  this.getElementByName("Restitution").getValue(),
                                                                  this.getElementByName("Static").getState(),
                                                                  true,
                                                                  0.1f,
                                                                  new PVector(0, 0, 0),
                                                                  new PVector(255, 255, 255));

            if(!UI_Manager.getIsOverOrPressedWindows() && !this.wasMouseSpringAdded || !this.getElementByName("Fixed Position").getState()) {
                PVector velocity = PhysEngMath.MouseVelocityCalculationAndClamp(Mouse.getMouseDownCoordinates(), 
                                                                                Mouse.getMouseCoordinates(), 
                                                                                MIN_MOUSE_VELOCITY_MAG, 
                                                                                MAX_MOUSE_VELOCITY_MAG);
                rigidbody.SetInitialPosition(PVector.add(Mouse.getMouseDownCoordinates(), velocity));
                rigidbody.setVelocity(PhysEngMath.SquareVelocity(velocity).mult(-1));
            } else {
                rigidbody.SetInitialPosition(Mouse.getMouseCoordinates());
            }

            rigidbody.setIsTranslationallyStatic(this.getElementByName("Fixed Position").getState());
            rigidbody.setIsRotationallyStatic(this.getElementByName("Fixed Rotation").getState());
            rigidbody.setCollidability(true);
            rigidbody.RotateTo(radians(this.getElementByName("Angle").getValue()));
            // rigidbody.addForceToForceRegistry(new Gravity(rigidbody));
            rigidbody.addForceToForceRegistry(new ComplexGravity(rigidbody));


            AddBodyToBodyEntityList(rigidbody);
            this.wasMouseSpringAdded = false;
            return;
    }


    public void createRectangle() {
        Rigidbody rigidbody = RigidbodyGenerator.CreateBoxBody(this.getElementByName("Width").getValue(),
                                                              this.getElementByName("Height").getValue(),
                                                              this.getElementByName("Density").getValue(),
                                                              this.getElementByName("Restitution").getValue(),
                                                              this.getElementByName("Static").getState(),
                                                              true,
                                                              0.1f,
                                                              new PVector(0, 0, 0),
                                                              new PVector(255, 255, 255));
        if(!UI_Manager.getIsOverOrPressedWindows() && !this.wasMouseSpringAdded && !this.getElementByName("Fixed Position").getState()){
            PVector velocity = PhysEngMath.MouseVelocityCalculationAndClamp(Mouse.getMouseDownCoordinates(), 
                                                                            Mouse.getMouseCoordinates(), 
                                                                            MIN_MOUSE_VELOCITY_MAG, 
                                                                            MAX_MOUSE_VELOCITY_MAG);
            rigidbody.SetInitialPosition(PVector.add(Mouse.getMouseDownCoordinates(), velocity));
            rigidbody.setVelocity(PhysEngMath.SquareVelocity(velocity).mult(-1));
        } else {
            rigidbody.SetInitialPosition(Mouse.getMouseCoordinates());
        }
        
        rigidbody.setIsTranslationallyStatic(this.getElementByName("Fixed Position").getState());
        rigidbody.setIsRotationallyStatic(this.getElementByName("Fixed Rotation").getState());
        rigidbody.setCollidability(true);
        rigidbody.RotateTo(radians(this.getElementByName("Angle").getValue()));
        rigidbody.addForceToForceRegistry(new Gravity(rigidbody));

        AddBodyToBodyEntityList(rigidbody);
        this.wasMouseSpringAdded = false;
        return;
    }


    
/*
========================================= Rigidbody Drawing ========================================
*/
    public void drawVelocityLine() {
        if(mouseButton != LEFT || !mousePressed) {
            return;
        }
        if(this.wasMouseSpringAdded) {
            return;
        }

        PVector mouseDownCoordinates = Mouse.getMouseDownCoordinates();
        PVector clamped = PhysEngMath.MouseVelocityCalculationAndClamp(mouseDownCoordinates, Mouse.getMouseCoordinates(), 
                                                                        MIN_MOUSE_VELOCITY_MAG, MAX_MOUSE_VELOCITY_MAG);
        PVector endPoint = PVector.add(mouseDownCoordinates, clamped);

        if(PVector.sub(mouseDownCoordinates, endPoint).magSq() > 0.1f){
            stroke(lerpColor(color(0, 255, 0), color(255, 0, 0), sq(map(clamped.mag(), MIN_MOUSE_VELOCITY_MAG, MAX_MOUSE_VELOCITY_MAG, 0, 1))));
            line(mouseDownCoordinates.x, mouseDownCoordinates.y, endPoint.x, endPoint.y);
        }
    }



    @Override
    public void onKeyPress(int keyCode) {
        int activeSlotID = UI_Manager.HOT_BAR.getActiveSlotID();
        boolean shiftDown = KeyHandler.isKeyDown(KeyEvent.VK_SHIFT);

        switch(keyCode) {
            case KeyEvent.VK_Z:
                if(shiftDown) {
                    this.getElementByName("Angle").incrementValue(-10f);
                } else {
                    this.getElementByName("Angle").incrementValue(-5f);
                }
                break;
            case KeyEvent.VK_C:
                if(shiftDown) {
                    this.getElementByName("Angle").incrementValue(10f);
                } else {
                    this.getElementByName("Angle").incrementValue(5f);
                }
                break;
            case KeyEvent.VK_A:
                if(activeSlotID == 2) {
                    if(shiftDown) {
                        this.getElementByName("Radius").incrementValue(-1f);
                    } else {
                        this.getElementByName("Radius").incrementValue(-0.25f);
                    }
                } else if(activeSlotID == 3) {
                    if(shiftDown) {
                        this.getElementByName("Width").incrementValue(-5f);
                    } else {
                        this.getElementByName("Width").incrementValue(-1f);
                    }
                }
                break;
            case KeyEvent.VK_D:
                if(activeSlotID == 2) {
                    if(shiftDown) {
                        this.getElementByName("Radius").incrementValue(1f);
                    } else {
                        this.getElementByName("Radius").incrementValue(0.25f);
                    }
                } else if(activeSlotID == 3) {
                    if(shiftDown) {
                        this.getElementByName("Width").incrementValue(5f);
                    } else {
                        this.getElementByName("Width").incrementValue(1f);
                    }
                }
                break;
            case KeyEvent.VK_W:
                if(activeSlotID == 2) {
                    if(shiftDown) {
                        this.getElementByName("Radius").incrementValue(1f);
                    } else {
                        this.getElementByName("Radius").incrementValue(0.25f);
                    }
                } else if(activeSlotID == 3) {
                    if(shiftDown) {
                        this.getElementByName("Height").incrementValue(5f);
                    } else {
                        this.getElementByName("Height").incrementValue(1f);
                    }
                }
                break;

            case KeyEvent.VK_S:
                if(activeSlotID == 2) {
                    if(shiftDown) {
                        this.getElementByName("Radius").incrementValue(-1f);
                    } else {
                        this.getElementByName("Radius").incrementValue(-0.25f);
                    }
                } else if(activeSlotID == 3) {
                    if(shiftDown) {
                        this.getElementByName("Height").incrementValue(-5f);
                    } else {
                        this.getElementByName("Height").incrementValue(-1f);
                    }
                }
                break;
        }

    }

    public void setMouseSpringAdded(boolean wasMouseSpringAdded) {
        this.wasMouseSpringAdded = wasMouseSpringAdded;
    }
}
public class UI_QualitySettings {

    public JSONObject settings;
    public JSONObject timePlayed;

    private long startTime;

    private Timer playtimeTimer = new Timer();


    public UI_QualitySettings() {
        this.loadJSON("settings");
        this.loadJSON("timePlayed");
    }

    public UI_QualitySettings(boolean init) {
        this.loadJSON("settings");
        this.loadJSON("timePlayed");
        if(init) {
            this.init();
        } 
    }


/*
====================================== Timing ===============================
*/
    public void startPlaytimeTracking() {
        this.startTime = System.currentTimeMillis();
        
        this.playtimeTimer.scheduleAtFixedRate(new TimerTask() {
            @Override
            public void run() {
                updatePlaytime();
            }
        }, 60000, 60000); 
    }


    public void updatePlaytime() {
        int totalPlayTimeMinutes = this.timePlayed.getInt("TimePlayedMinutes") + 1;
        int totalPlayTimeHours = this.timePlayed.getInt("TimePlayedHours");

        if(totalPlayTimeMinutes >= 60) {
            totalPlayTimeHours += 1;
            totalPlayTimeMinutes = 0;
        }

        String timePlayed = "Time Played: " + totalPlayTimeHours + "h " + totalPlayTimeMinutes + "m";
        
        this.timePlayed.setInt("TimePlayedMinutes", totalPlayTimeMinutes);
        this.timePlayed.setInt("TimePlayedHours", totalPlayTimeHours);
        this.timePlayed.setString("TimePlayed", timePlayed);

        if(UI_Manager.getSettingsWindow() != null) {
            UI_Manager.getSettingsWindow().currentTimePlayed = timePlayed;
        }

        saveJSONObject(this.timePlayed, sketchPath() + "/data/settings/timePlayed.json");
        this.timePlayed = loadJSONObject(sketchPath() + "/data/settings/timePlayed.json");
    }

/*
======================================== File Loading ==============================================
*/  
    public void createDefaultSettingsFile() {
        JSONObject settings = new JSONObject();
            settings.setString("VisualQuality", "High");
            settings.setString("SimulationQuality", "Medium");
            settings.setString("TextQuality", "High");
            settings.setString("ScrollSensitivity", "Medium");
            settings.setBoolean("Show Frame Stats", false);
            settings.setBoolean("Show AABBs", false);
            settings.setBoolean("Show Collision Points", false);
            settings.setFloat("CoefficientOfStaticFriction", 0.8f);
            settings.setFloat("CoefficientOfKineticFriction", 0.3f);
            settings.setFloat("Gravity", 9.81f);

        saveJSONObject(settings, sketchPath() + "/data/settings/settings.json");
        this.settings = settings;
    }


    public void createDefaultTimePlayedFile() {
        JSONObject timePlayed = new JSONObject();
            timePlayed.setInt("TimePlayedMinutes", 0);
            timePlayed.setInt("TimePlayedHours", 0);
            timePlayed.setString("TimePlayed", "Time Played: 0h 0m");

        saveJSONObject(timePlayed, sketchPath() + "/data/settings/timePlayed.json");
        this.timePlayed = timePlayed;
    }

    public void init() {
        try {
            String VisualQuality = settings.getString("VisualQuality");
            String SimulationQuality = settings.getString("SimulationQuality");
            String TextQuality = settings.getString("TextQuality");
            String ScrollSensitivity = settings.getString("ScrollSensitivity");

            boolean Show_Frame_Stats = settings.getBoolean("Show Frame Stats");
            boolean Show_AABBs = settings.getBoolean("Show AABBs");
            boolean Show_Collision_Points = settings.getBoolean("Show Collision Points");

            float CoefficientOfStaticFriction = settings.getFloat("CoefficientOfStaticFriction");
            float CoefficientOfKineticFriction = settings.getFloat("CoefficientOfKineticFriction");
            float Gravity = settings.getFloat("Gravity");

            switch (VisualQuality) {
                case "Low":
                    this.setLowVisualQuality();
                    break;
                case "Medium":
                    this.setMediumVisualQuality();
                    break;
                case "High":
                    this.setHighVisualQuality();
                    break;
            }

            switch (SimulationQuality) {
                case "Low":
                    this.setLowSimulationQuality();
                    break;
                case "Medium":
                    this.setMediumSimulationQuality();
                    break;
                case "High":
                    this.setHighSimulationQuality();
                    break;
            }

            switch(ScrollSensitivity) {
                case "Low":
                    this.setLowScrollSensitivity();
                    break;
                case "Medium":
                    this.setMediumScrollSensitivity();
                    break;
                case "High":
                    this.setHighScrollSensitivity();
                    break;
            }

            switch(TextQuality) {
                case "Low":
                    this.setLowTextQuality();
                    break;
                case "High":
                    this.setHighTextQuality();
            }

            DRAW_CONTACT_POINTS = Show_Collision_Points;;
            DRAW_AABBS = Show_AABBs;
            DRAW_STATS = Show_Frame_Stats;
            COEFFICIENT_OF_STATIC_FRICTION = CoefficientOfStaticFriction;
            COEFFICIENT_OF_KINETIC_FRICTION = CoefficientOfKineticFriction;
            GRAVITY_MAG = Gravity;
            GRAVITY_VECTOR.set(0, GRAVITY_MAG);
        } catch (Exception e) {
            this.createDefaultSettingsFile();
            this.init();
        }
    }

    public void saveSetting(String entry, String value) {
        this.settings.setString(entry, value);
        this.updateSettings();
        saveJSONObject(this.settings, sketchPath() + "/data/settings/settings.json");
    }

    public void saveSetting(String entry, boolean value) {
        this.settings.setBoolean(entry, value);
        this.updateSettings();
        saveJSONObject(this.settings, sketchPath() + "/data/settings/settings.json");
    }

    public void saveSetting(String entry, float value) {
        this.settings.setFloat(entry, value);
        this.updateSettings();
        saveJSONObject(this.settings, sketchPath() + "/data/settings/settings.json");
    }

    public void updateSettings() {
        switch(this.settings.getString("SimulationQuality")) {
            case "Low":
                setLowSimulationQuality();
                break;
            case "Medium":
                setMediumSimulationQuality();
                break;
            case "High":
                setHighSimulationQuality();
                break;
        }
        switch(this.settings.getString("ScrollSensitivity")) {
            case "Low":
                setLowScrollSensitivity();
                break;
            case "Medium":
                setMediumScrollSensitivity();
                break;
            case "High":
                setHighScrollSensitivity();
                break;
        }

        DRAW_CONTACT_POINTS = this.settings.getBoolean("Show Collision Points");
        DRAW_AABBS = this.settings.getBoolean("Show AABBs");
        DRAW_STATS = this.settings.getBoolean("Show Frame Stats");

        COEFFICIENT_OF_KINETIC_FRICTION = this.settings.getFloat("CoefficientOfKineticFriction");
        COEFFICIENT_OF_STATIC_FRICTION = this.settings.getFloat("CoefficientOfStaticFriction");
        GRAVITY_MAG = this.settings.getFloat("Gravity");
        GRAVITY_VECTOR.set(0, GRAVITY_MAG);
    }



/*
======================================= Specific Settings ==========================================
*/
    private void setLowSimulationQuality() {
        SUB_STEP_COUNT = 64;
    }

    private void setMediumSimulationQuality() {
        SUB_STEP_COUNT = 256;
    }

    private void setHighSimulationQuality() {
        SUB_STEP_COUNT = 1024;
    }

    private void setLowVisualQuality() {
        noSmooth();
    }

    private void setMediumVisualQuality() {
        smooth(2);
    }

    private void setHighVisualQuality() {
        smooth(3);
    }

    private void setLowScrollSensitivity() {
        SCROLL_SENSITIVITY = 1.05f;
    }

    private void setMediumScrollSensitivity() {
        SCROLL_SENSITIVITY = 1.1f;
    }

    private void setHighScrollSensitivity() {
        SCROLL_SENSITIVITY = 1.5f;
    }

    private void setLowTextQuality() {
        hint(DISABLE_STROKE_PURE);
        TEXT_SMOOTHING = false;
    }

    private void setHighTextQuality() {
        TEXT_SMOOTHING = true;
    }

    private void loadJSON(String name) {
        String directoryPath = dataPath("settings");
        createPath(directoryPath);

        if(name.equals("settings")) {
            loadSettingsJSON();
        } else if(name.equals("timePlayed")) {
            loadTimePlayedJSON();
        } else {
            throw new IllegalArgumentException("Invalid JSON file name");
        }
    }

    private void loadSettingsJSON() {
        String filePath = sketchPath() + "/data/settings/settings.json";

        JSONObject settings;

        try {
            settings = loadJSONObject(filePath);
            this.settings = settings;
        } catch(Exception e) {
            this.createDefaultSettingsFile();
            settings = loadJSONObject(filePath);
            this.settings = settings;
        }
    }

    private void loadTimePlayedJSON() {
        String filePath = sketchPath() + "/data/settings/timePlayed.json";
        JSONObject timePlayed;
        try {
            timePlayed = loadJSONObject(filePath);
            this.timePlayed = timePlayed;
        } catch(Exception e) {
            this.createDefaultTimePlayedFile();
            timePlayed = loadJSONObject(filePath);
            this.timePlayed = timePlayed;
        }
    }



    public int getPixelDensity() {
        if(this.settings.getString("VisualQuality").equals("Low")) {
            return 1;
        } else if(this.settings.getString("VisualQuality").equals("Medium")) {
            return 1;
        } else if(this.settings.getString("VisualQuality").equals("High")) {
            return displayDensity();
        } else {
            throw new IllegalArgumentException("Invalid visual quality setting");
        }
    }
    
}
public class UI_SettingsWindow extends UI_Window {

    public UI_QualitySettings qualitySettings = new UI_QualitySettings(false);
    public String currentTimePlayed;

    private UI_TickSlider Simulation_Quality;
    private UI_TickSlider Visual_Quality;
    private UI_TickSlider Scroll_Sensitivity;
    private UI_TickSlider Text_Quality;

    private UI_Toggle Show_Frame_Stats;
    private UI_Toggle Show_AABBs;
    private UI_Toggle Show_Collision_Points;

    private UI_Slider Coeff_Static_Friction;
    private UI_Slider Coeff_Kinetic_Friction;
    private UI_Slider Gravity;

    private UI_Button Reset_To_Defaults;

    private String prvSimulationQuality;
    private String prvVisualQuality;
    private String prvScrollSensitivity;
    private String prvTextQuality;

    private boolean prvShowFrameStats;
    private boolean prvShowAABBs;
    private boolean prvShowCollisionPoints;

    private float prvCoeffStaticFriction;
    private float prvCoeffKineticFriction;
    private float prvGravity;




    public UI_SettingsWindow() {
        super("Settings", 4, new PVector(713, 700), new PVector(713, 47), new PVector(713, 653), false);
        this.setWindowPosition(new PVector(displayWidth/2, displayHeight/2 - 35));
        textFont(UI_Constants.INTER_BOLD);
        textSize(25);
        textAlign(CENTER, CENTER);
        this.Window_Text_Width = textWidth(this.Window_Name);
        this.Window_Text_Position.set(0, -(this.Window_Form_Container_Size.y + this.Window_Text_Container_Size.y) / 2 - (textAscent() - textDescent()) * UI_Constants.GLOBAL_TEXT_ALIGN_FACTOR_Y);

        this.initializeSettingsWindow();
    }

    public void initializeSettingsWindow() {
        this.currentTimePlayed = qualitySettings.timePlayed.getString("TimePlayed");
        try {
            String currentSimulationQuality = qualitySettings.settings.getString("SimulationQuality");
            String currentVisualQuality = qualitySettings.settings.getString("VisualQuality");
            String currentScrollSensitivity = qualitySettings.settings.getString("ScrollSensitivity");
            String currentTextQuality = qualitySettings.settings.getString("TextQuality");   
            boolean currentShowFrameStats = qualitySettings.settings.getBoolean("Show Frame Stats");
            boolean currentShowAABBs = qualitySettings.settings.getBoolean("Show AABBs");
            boolean currentShowCollisionPoints = qualitySettings.settings.getBoolean("Show Collision Points");
            float currentCoeffStaticFriction = qualitySettings.settings.getFloat("CoefficientOfStaticFriction");
            float currentCoeffKineticFriction = qualitySettings.settings.getFloat("CoefficientOfKineticFriction");
            float currentGravity = qualitySettings.settings.getFloat("Gravity");

            this.prvSimulationQuality = currentSimulationQuality;
            this.prvVisualQuality = currentVisualQuality;
            this.prvScrollSensitivity = currentScrollSensitivity;
            this.prvTextQuality = currentTextQuality;
            this.prvShowFrameStats = !currentShowFrameStats;
            this.prvShowAABBs = !currentShowAABBs;
            this.prvShowCollisionPoints = currentShowCollisionPoints;
            this.prvCoeffStaticFriction = currentCoeffStaticFriction;
            this.prvCoeffKineticFriction = currentCoeffKineticFriction;
            this.prvGravity = currentGravity;

            /*
            Text
            */
            this.addElement(new UI_Text("Simulation Quality", (UI_Window)this, -this.Window_Form_Container_Size.x / 4, -this.Window_Form_Container_Size.y / 2 + 50, 0, 25, UI_Constants.GRAY_25, true, UI_Constants.INTER_BOLD));
            this.addElement(new UI_Text("Visual Quality", (UI_Window)this, this.Window_Form_Container_Size.x / 4, -this.Window_Form_Container_Size.y / 2 + 50, 0, 25, UI_Constants.GRAY_25, true, UI_Constants.INTER_BOLD));
            this.addElement(new UI_Text("Scroll Sensitivity", (UI_Window)this, -this.Window_Form_Container_Size.x / 4, -this.Window_Form_Container_Size.y / 2 + 200, 0, 25, UI_Constants.GRAY_25, true, UI_Constants.INTER_BOLD));
            this.addElement(new UI_Text("Text Quality", (UI_Window)this, this.Window_Form_Container_Size.x / 4, -this.Window_Form_Container_Size.y / 2 + 200, 0, 25, UI_Constants.GRAY_25, true, UI_Constants.INTER_BOLD));
            this.addElement(new UI_Text("Debugging", (UI_Window)this, 0, -this.Window_Form_Container_Size.y / 2 + 350, 0, 25, UI_Constants.GRAY_25, true, UI_Constants.INTER_BOLD));
            /*
            Toggles
            */  

            float scale = 1.1f;

            float showFrameStatsPosX = this.Window_Form_Container_Size.x / 4f + (280f / 2f) - (265f * scale / 2f);
            float showFrameStatsPosY = -this.Window_Form_Container_Size.y / 2f + 390;
            float showAABBsPosX = this.Window_Form_Container_Size.x / 4f + 280f / 2f - (265f * scale / 2f);
            float showAABBsPosY = -this.Window_Form_Container_Size.y / 2f + 440;
            float showCollisionPointsPosX = this.Window_Form_Container_Size.x / 4f +  280f / 2 - (265f * scale / 2f);
            float showCollisionPointsPosY = -this.Window_Form_Container_Size.y / 2f + 490;


            this.Show_Frame_Stats = new UI_Toggle("Show Frame Stats", (UI_Window)this, showFrameStatsPosX, showFrameStatsPosY, currentShowFrameStats, scale);
            this.Show_AABBs = new UI_Toggle("Show AABB's", (UI_Window)this, showAABBsPosX, showAABBsPosY, currentShowAABBs, scale);
            this.Show_Collision_Points = new UI_Toggle("Show Collision Points", (UI_Window)this, showCollisionPointsPosX, showCollisionPointsPosY, currentShowCollisionPoints, scale);
            this.addElement(this.Show_Frame_Stats);
            this.addElement(this.Show_AABBs);
            this.addElement(this.Show_Collision_Points);

            /*
            Sliders
            */
            this.Simulation_Quality = new UI_TickSlider(new String[]{"Low", "Medium", "High"}, (UI_Window)this, currentSimulationQuality, -this.Window_Form_Container_Size.x / 4,  -this.Window_Form_Container_Size.y / 2 + 125, 3);
            this.Visual_Quality = new UI_TickSlider(new String[]{"Low", "Medium", "High"}, (UI_Window)this, currentVisualQuality, this.Window_Form_Container_Size.x / 4,  -this.Window_Form_Container_Size.y / 2 + 125, 3);
            this.Scroll_Sensitivity = new UI_TickSlider(new String[]{"Low", "Medium", "High"}, (UI_Window)this, currentScrollSensitivity, -this.Window_Form_Container_Size.x / 4,  -this.Window_Form_Container_Size.y / 2 + 275, 3);
            this.Text_Quality = new UI_TickSlider(new String[]{"Low", "High"}, (UI_Window)this, currentTextQuality, this.Window_Form_Container_Size.x / 4,  -this.Window_Form_Container_Size.y / 2 + 275, 3);
            
            this.Simulation_Quality.TickSlider_Name = "Simulation Quality";
            this.Visual_Quality.TickSlider_Name = "Visual Quality";
            this.Scroll_Sensitivity.TickSlider_Name = "Scroll Sensitivity";

            this.addElement(this.Simulation_Quality);
            this.addElement(this.Visual_Quality);
            this.addElement(this.Scroll_Sensitivity);
            this.addElement(this.Text_Quality);


            this.Coeff_Static_Friction = new UI_Slider("Coeff. of static friction", this, 0, 1, currentCoeffStaticFriction);
            this.Coeff_Kinetic_Friction = new UI_Slider("Coeff. of kinetic friction", this, 0, 1, currentCoeffKineticFriction);
            this.Gravity = new UI_Slider("Gravity", this, 0, 100, currentGravity);

            this.addElement(this.Coeff_Static_Friction);
            this.addElement(this.Coeff_Kinetic_Friction);
            this.addElement(this.Gravity);

            /*
            Button
            */
            this.Reset_To_Defaults = new UI_Button("Reset to defaults", this, false);
            this.addElement(this.Reset_To_Defaults);
        } catch (Exception e) {
            this.qualitySettings.createDefaultSettingsFile();
            this.initializeSettingsWindow();
        }

    }

    public void checkWindowElements() {
        if(this.Simulation_Quality.getElementName() != this.prvSimulationQuality) {
            this.qualitySettings.saveSetting("SimulationQuality", this.Simulation_Quality.getElementName());
            this.prvSimulationQuality = this.Simulation_Quality.getElementName();
        } else if(this.Visual_Quality.getElementName() != this.prvVisualQuality) {
            this.qualitySettings.saveSetting("VisualQuality", this.Visual_Quality.getElementName());
            this.prvVisualQuality = this.Visual_Quality.getElementName();
        } else if(this.Text_Quality.getElementName() != this.prvVisualQuality) {
            this.qualitySettings.saveSetting("TextQuality", this.Text_Quality.getElementName());
            this.prvTextQuality = this.Text_Quality.getElementName();
        } else if(this.Scroll_Sensitivity.getElementName() != this.prvScrollSensitivity) {
            this.qualitySettings.saveSetting("ScrollSensitivity", this.Scroll_Sensitivity.getElementName());
            this.prvScrollSensitivity = this.Scroll_Sensitivity.getElementName();
        }

        this.qualitySettings.saveSetting("Show Frame Stats", this.Show_Frame_Stats.getState());
        this.qualitySettings.saveSetting("Show AABBs", this.Show_AABBs.getState());
        this.qualitySettings.saveSetting("Show Collision Points", this.Show_Collision_Points.getState());
        this.qualitySettings.saveSetting("CoefficientOfStaticFriction", this.Coeff_Static_Friction.getValue());
        this.qualitySettings.saveSetting("CoefficientOfKineticFriction", this.Coeff_Kinetic_Friction.getValue());
        this.qualitySettings.saveSetting("Gravity", this.Gravity.getValue());
    }
        

    @Override
    public void drawText() {
        if(this.isActiveWindow) {
            fill(UI_Constants.WHITE);
        } else {
            fill(UI_Constants.GRAY_25);
        }

        textFont(UI_Constants.INTER_BOLD);
        textSize(25);
        textAlign(CENTER, CENTER);

        text(this.Window_Name, this.Window_Text_Position.x, this.Window_Text_Position.y);
        textFont(UI_Constants.INTER_REGULAR);
        textSize(13);
        textLeading(13* 1.286f);
        textAlign(CENTER, CENTER);
        fill(UI_Constants.GRAY_25);
        text(this.currentTimePlayed, 0, this.Window_Form_Container_Size.y / 2 - 17.5f);
    }




    public void open() {
        this.deselectAllWindows();
        this.isActiveWindow = true;
        this.Window_Visibility = true;
        UI_Manager.bringToFront(this);
        this.Window_Container.getChild("Window_Container_Stroke").setStroke(UI_Constants.BLUE_SELECTED);
        this.Window_Container.getChild("Window_Text_Container").setFill(UI_Constants.BLUE_UNSELECTED);
    }



    @Override
    public void interactionDraw() {
        if(UI_Manager.getTabBar().getActiveTabID() == 0) {
            this.lockSelected();
            this.checkWindowElements();
            UI_Manager.closeAllWindows(this);
        }   
    }


    public void lockSelected() {
        this.isActiveWindow = true;
        this.Window_Visibility = true;
        UI_Manager.getHotBar().setActiveSlotID(-1);
        this.Window_Container.getChild("Window_Container_Stroke").setStroke(UI_Constants.BLUE_SELECTED);
        this.Window_Container.getChild("Window_Text_Container").setFill(UI_Constants.BLUE_UNSELECTED);
    }
    
    public void onResetButtonPressed() {
        this.Simulation_Quality.setValue(0.5f);
        this.Visual_Quality.setValue(0.5f);
        this.Scroll_Sensitivity.setValue(0.5f);
        this.Text_Quality.setValue(0.9f);
        this.Show_Frame_Stats.setState(false);
        this.Show_AABBs.setState(false);
        this.Show_Collision_Points.setState(false);
        this.Coeff_Static_Friction.setValue(0.8f);
        this.Coeff_Kinetic_Friction.setValue(0.3f);
        this.Gravity.setValue(9.81f);
        this.qualitySettings.createDefaultSettingsFile();
    }

    @Override
    public boolean onMouseDrag() {
        if(!this.Window_Visibility) {
            return false;
        }
        if(mousePressed && this.isMouseOverWindowFormContainer) {
            this.onElementMouseDrag();
            return true;
        }
        return false;
    }



}
  
public class UI_Slider extends UI_Element {

    public UI_Window Slider_ParentWindow;

    public String Slider_Name;
    public float Slider_Name_Position_X;
    public float Slider_Name_Position_Y;
    public float Slider_Value_Position_X;
    public float Slider_Value_Position_Y;
    
    public float Slider_Min_Value;
    public float Slider_Max_Value;
    public float Slider_Current_Value;


    public float scale = -1;
    public String Slider_GroupName = null;

    public boolean mouseOverSliderOnMouseDown = false;
    public PShape Slider_Shape_Group = createShape(GROUP);


    public UI_Slider(String Slider_Name, UI_Window Slider_ParentWindow, float Slider_Min_Value, float Slider_Max_Value, float Slider_Current_Value) {
        this.Slider_Name = Slider_Name;
        
        this.Slider_Shape_Group.setName(this.Slider_Name + "Group");
        this.Slider_ParentWindow = Slider_ParentWindow;

        this.Slider_Min_Value = Slider_Min_Value;
        this.Slider_Max_Value = Slider_Max_Value;
        this.Slider_Current_Value = Slider_Current_Value;

        this.initializeSlider();
    }


    public UI_Slider(String Slider_Name, UI_Window Slider_ParentWindow, String Slider_GroupName, float Slider_Min_Value, float Slider_Max_Value, float Slider_Current_Value) {
        
        this.Slider_Name = Slider_Name;
        this.Slider_ParentWindow = Slider_ParentWindow;
        this.Slider_GroupName = Slider_GroupName;

        this.Slider_Min_Value = Slider_Min_Value;
        this.Slider_Max_Value = Slider_Max_Value;
        this.Slider_Current_Value = Slider_Current_Value;

        this.initializeSlider();
    }


    public void initializeSlider() {
        rectMode(CENTER);
        this.createElementBaseShape();
        this.createElementText();
    }




/*
======================================= Slider Creation ============================================
*/  
    @Override
    public void createElementBaseShape() {
        rectMode(CENTER);
        int numElements = this.Slider_ParentWindow.getWindowElementArrayListSize();

        float sliderShapeX;
        float sliderShapeY;
        float sliderShapeWidth;
        float sliderShapeHeight;

        if(this.Slider_Name.equals("Coeff. of static friction")) {
            this.scale = 1.1f;
            sliderShapeX = -this.Slider_ParentWindow.getWindowFormContainerDimensions().x / 4f - (280f / 2f) + (this.Element_Width * scale / 2f);
            sliderShapeY = -this.Slider_ParentWindow.getWindowFormContainerDimensions().y / 2f + 390;

            // this.Element_Width = 310f;
            // this.Element_Height = 34f;
            sliderShapeWidth = this.Element_Width;
            sliderShapeHeight = this.Element_Height;
        } else if(this.Slider_Name.equals("Coeff. of kinetic friction")) {
            this.scale = 1.1f;
            sliderShapeX = -this.Slider_ParentWindow.getWindowFormContainerDimensions().x / 4f - 280f / 2f + (this.Element_Width * scale / 2f);
            sliderShapeY = -this.Slider_ParentWindow.getWindowFormContainerDimensions().y / 2f + 440;

            // this.Element_Width = 310f;
            // this.Element_Height = 34f;
            sliderShapeWidth = this.Element_Width;
            sliderShapeHeight = this.Element_Height;
        } else if(this.Slider_Name.equals("Gravity")) {
            this.scale = 1.1f;
            sliderShapeX = -this.Slider_ParentWindow.getWindowFormContainerDimensions().x / 4f - 280f / 2 + (this.Element_Width * scale / 2f);
            sliderShapeY = -this.Slider_ParentWindow.getWindowFormContainerDimensions().y / 2f + 490;

            // this.Element_Width = 310f;
            // this.Element_Height = 34f;
            sliderShapeWidth = this.Element_Width;
            sliderShapeHeight = this.Element_Height;
        } else if(numElements == 0) {
            sliderShapeX = 0;
            sliderShapeY = -this.Slider_ParentWindow.getWindowFormContainerHeight() / 2 + this.Element_Container_Top_Padding_Y + this.Element_Height / 2;

            sliderShapeWidth = this.Element_Width;
            sliderShapeHeight = this.Element_Height;

        } else {
            sliderShapeX = 0;
            sliderShapeY = (this.Element_Height - this.Slider_ParentWindow.getWindowFormContainerHeight()) /2 + (this.Element_Height + this.Element_Element_Padding_Y) * numElements + this.Element_Container_Top_Padding_Y;
            sliderShapeWidth = this.Element_Width;
            sliderShapeHeight = this.Element_Height;
        }

        PShape Slider_Shape_Base = createShape(RECT, sliderShapeX, sliderShapeY, sliderShapeWidth, sliderShapeHeight, this.Element_Rounding);
            Slider_Shape_Base.setName("Slider_Shape_Base");
            Slider_Shape_Base.setStrokeWeight(this.Element_Stroke_Weight);
            Slider_Shape_Base.setFill(this.Element_Base_Unselected_Color);
            Slider_Shape_Base.setStroke(this.Element_Base_Unselected_Stroke_Color);
            if(this.scale != -1) {
                Slider_Shape_Base.scale(this.scale);
            }

        PShape Slider_Shape_Base_Listener = UI_Constants.createElementListener(Slider_Shape_Base);
            Slider_Shape_Base_Listener.setName("Slider_Shape_Base_Listener");

        this.Slider_Shape_Group.addChild(Slider_Shape_Base);
        this.Slider_Shape_Group.addChild(Slider_Shape_Base_Listener);

        this.initializeSliderShape();
    }

    @Override 
    public void createElementText() {
        textFont(this.Element_Font);
        textSize(this.Element_Text_Size);
        textAlign(CENTER, CENTER);
        float[] sliderShapeParams = this.Slider_Shape_Group.getChild("Slider_Shape_Base").getParams();

        this.Slider_Name_Position_X = sliderShapeParams[0] - sliderShapeParams[2] / 2 + textWidth(this.Slider_Name) / 2 + 10;
        this.Slider_Name_Position_Y = sliderShapeParams[1] - (textAscent() - textDescent()) * UI_Constants.GLOBAL_TEXT_ALIGN_FACTOR_Y;

        this.Slider_Value_Position_X = sliderShapeParams[0] + sliderShapeParams[2] / 2 - textWidth(nf(this.Slider_Current_Value, 0, 2)) / 2 - 10;
        this.Slider_Value_Position_Y = sliderShapeParams[1] - (textAscent() - textDescent()) * UI_Constants.GLOBAL_TEXT_ALIGN_FACTOR_Y;
    }


    public void updateValueTextPosition() {
        textFont(this.Element_Font);
        textSize(this.Element_Text_Size);
        textAlign(CENTER, CENTER);

        float[] sliderShapeParams = this.Slider_Shape_Group.getChild("Slider_Shape_Base").getParams();

        this.Slider_Value_Position_X = sliderShapeParams[0] + sliderShapeParams[2] / 2 - textWidth(nf(this.Slider_Current_Value, 0, 2)) / 2 - 10;
        this.Slider_Value_Position_Y = sliderShapeParams[1] - (textAscent() - textDescent()) * UI_Constants.GLOBAL_TEXT_ALIGN_FACTOR_Y;

    }

    

/*
======================================= Slider Interaction =========================================
*/  
    @Override
    public boolean onMousePress() {
        if(this.scale != -1) {
            float x = (mouseX - this.Slider_ParentWindow.getWindowPosition().x) / this.scale;
            float y = (mouseY - this.Slider_ParentWindow.getWindowPosition().y) / this.scale;
            return this.Slider_Shape_Group.getChild("Slider_Shape_Base_Listener").contains(x, y);
        } else {
            float x = mouseX - this.Slider_ParentWindow.getWindowPosition().x;
            float y = mouseY - this.Slider_ParentWindow.getWindowPosition().y;
            return this.Slider_Shape_Group.getChild("Slider_Shape_Base_Listener").contains(x, y);
        }
    }

    @Override
    public void onMouseDrag() {
        if(this.mouseOverSliderOnMouseDown) {
            float x = mouseX - this.Slider_ParentWindow.getWindowPosition().x;
            float[] baseShapeParams = this.Slider_Shape_Group.getChild("Slider_Shape_Base").getParams();
            this.Slider_Current_Value = map(x, baseShapeParams[0] - baseShapeParams[2] / 2, baseShapeParams[0] + baseShapeParams[2] / 2, this.Slider_Min_Value, this.Slider_Max_Value);
            this.Slider_Current_Value = constrain(this.Slider_Current_Value, this.Slider_Min_Value, this.Slider_Max_Value);
            this.updateSliderShape();
        }
    }

    @Override 
    public void onMouseRelease() {
        this.mouseOverSliderOnMouseDown = false;
    }
    

    @Override
    public void onSelect() {
        this.mouseOverSliderOnMouseDown = true;
    }

    @Override
    public void onDeselect() {
        this.mouseOverSliderOnMouseDown = false;
    }

/*
==================================== Slider Methods ================================================
*/
    public void initializeSliderShape() {
        rectMode(CORNER);
        float[] sliderShapeParams = this.Slider_Shape_Group.getChild("Slider_Shape_Base").getParams();
        float sliderShapeX = sliderShapeParams[0] - sliderShapeParams[2] / 2;
        float sliderShapeY = sliderShapeParams[1] - sliderShapeParams[3] / 2;
        float sliderShapeHeight = sliderShapeParams[3];

        float sliderShapeWidth = map(this.Slider_Current_Value, this.Slider_Min_Value, this.Slider_Max_Value, 0, sliderShapeParams[2]);

        PShape Slider_Shape = createShape(RECT, sliderShapeX, sliderShapeY, sliderShapeWidth, sliderShapeHeight, this.Element_Rounding);
            Slider_Shape.setName("Slider_Value_Shape");
            Slider_Shape.setStrokeWeight(this.Element_Stroke_Weight);
            Slider_Shape.setFill(this.Element_Base_Selected_Color);
            Slider_Shape.setStroke(this.Element_Base_Selected_Stroke_Color);
            if(this.scale != -1) {
                Slider_Shape.scale(this.scale);
            }

        this.Slider_Shape_Group.addChild(Slider_Shape);
    }

    public void updateSliderShape() {
        this.Slider_Shape_Group.removeChild(this.Slider_Shape_Group.getChildIndex(this.Slider_Shape_Group.getChild("Slider_Value_Shape")));

        rectMode(CORNER);
        float[] sliderShapeParams = this.Slider_Shape_Group.getChild("Slider_Shape_Base").getParams();
        float sliderShapeX = sliderShapeParams[0] - sliderShapeParams[2] / 2;
        float sliderShapeY = sliderShapeParams[1] - sliderShapeParams[3] / 2;
        float sliderShapeHeight = sliderShapeParams[3];

        float sliderShapeWidth = map(this.Slider_Current_Value, this.Slider_Min_Value, this.Slider_Max_Value, 0, sliderShapeParams[2]);

        PShape Slider_Shape = createShape(RECT, sliderShapeX, sliderShapeY, sliderShapeWidth, sliderShapeHeight, this.Element_Rounding);
            Slider_Shape.setName("Slider_Value_Shape");
            Slider_Shape.setStrokeWeight(this.Element_Stroke_Weight);
            Slider_Shape.setFill(this.Element_Base_Selected_Color);
            Slider_Shape.setStroke(this.Element_Base_Selected_Stroke_Color);
        if(this.scale != -1) {
            Slider_Shape.scale(this.scale);
        }
        
        this.Slider_Shape_Group.addChild(Slider_Shape);

        this.updateValueTextPosition();

    }

/*
===================================== Slider Draw ==================================================
*/

    @Override
    public void drawText() {
        fill(this.Element_Text_Color);
        textFont(this.Element_Font);
        textSize(this.Element_Text_Size);
        textAlign(CENTER, CENTER);
        if(this.scale != -1) {
            pushMatrix();
            scale(this.scale);
            text(this.Slider_Name, this.Slider_Name_Position_X, this.Slider_Name_Position_Y);
            text(nf(this.Slider_Current_Value, 0, 2), this.Slider_Value_Position_X, this.Slider_Value_Position_Y);
            popMatrix();
        } else {
            text(this.Slider_Name, this.Slider_Name_Position_X, this.Slider_Name_Position_Y);
            text(nf(this.Slider_Current_Value, 0, 2), this.Slider_Value_Position_X, this.Slider_Value_Position_Y);
        }
    }


/*
======================================= Toggle Getters and Setters =================================
*/  
    @Override   
    public String getElementName() {
        return this.Slider_Name;
    }
    @Override
    public String getGroupName() {
        return this.Slider_GroupName;
    }

    @Override
    public PShape getShape() {
        return this.Slider_Shape_Group;
    }

    @Override
    public float getValue() {
        return this.Slider_Current_Value;
    }

    @Override
    public boolean getState() {
        return false;
    }

    @Override
    public void setValue(float value) {
        this.Slider_Current_Value = constrain(value, this.Slider_Min_Value, this.Slider_Max_Value);
        this.updateSliderShape();
    }

    @Override
    public void incrementValue(float amount) {
        this.Slider_Current_Value = constrain(this.Slider_Current_Value + amount, this.Slider_Min_Value, this.Slider_Max_Value);
        this.updateSliderShape();
    }

    @Override
    public void setState(boolean state) {
        return;
    }

}   
public enum UI_State {
    SAVE_LEVEL,
    FILE_SELECTED,
    RENAME_LEVEL,
    DEFAULT,

}
public class UI_TabBar {


    private PShape TAB_SHAPE;
    private PShape[] TAB_SELECTOR;
    private PShape[] TAB_SELECTOR_LISTENERS;
    private float[] TEXT_POSITION;
    private float TEXT_POSITION_Y;
    private float BUTTON_TEXT_POSITION_Y;
    private float SCALE_FACTOR = width/1512f;
    private int activeTabID = 1;



    public UI_TabBar() {
        textFont(UI_Constants.TAB_TEXT_FONT);
        textAlign(CENTER, CENTER);
        textSize(UI_Constants.TAB_TEXT_SIZE);
        this.TEXT_POSITION_Y = UI_Constants.TAB_POSITION_Y - (textAscent() - textDescent()) * UI_Constants.GLOBAL_TEXT_ALIGN_FACTOR_Y;

        textFont(UI_Constants.TAB_BUTTON_TEXT_FONT);
        textAlign(CENTER, CENTER);
        textSize(UI_Constants.TAB_BUTTON_TEXT_SIZE);
        this.BUTTON_TEXT_POSITION_Y = UI_Constants.TAB_POSITION_Y - (textAscent() - textDescent()) * UI_Constants.GLOBAL_TEXT_ALIGN_FACTOR_Y;
        this.initializeTabBar();
    }

    public void draw() {
        this.drawTabGraphics();
    }


/*
=========================================== Initialization =========================================
*/
    public void initializeTabBar() {   

        rectMode(CENTER);

        this.TEXT_POSITION = new float[UI_Constants.TAB_NAME.length];
        this.TAB_SELECTOR = new PShape[UI_Constants.TAB_NAME.length];
        this.TAB_SELECTOR_LISTENERS = new PShape[UI_Constants.TAB_NAME.length];


        PShape TAB_SHAPE = createShape(RECT, UI_Constants.TAB_POSITION_X, 
                                             UI_Constants.TAB_POSITION_Y,
                                             UI_Constants.TAB_WIDTH, 
                                             UI_Constants.TAB_HEIGHT, 
                                             UI_Constants.TAB_ROUNDING);
            TAB_SHAPE.setName("TAB_SHAPE");
            TAB_SHAPE.setFill(UI_Constants.TAB_FILL);
            TAB_SHAPE.setStroke(UI_Constants.TAB_STROKE);
            TAB_SHAPE.setStrokeWeight(1.5f);


        PShape Q = createShape(RECT, UI_Constants.TAB_BUTTON_Q_POSITION_X,
                                     UI_Constants.TAB_POSITION_Y,
                                     UI_Constants.TAB_BUTTON_WIDTH,
                                     UI_Constants.TAB_BUTTON_HEIGHT,
                                     UI_Constants.TAB_BUTTON_ROUNDING);
            Q.setName("Q_Button");
            Q.setFill(UI_Constants.TAB_BUTTON_UNSELECTED_FILL);
            Q.setStroke(UI_Constants.TAB_BUTTON_UNSELECTED_STROKE);
            Q.setStrokeWeight(UI_Constants.TAB_BUTTON_STROKE_WEIGHT);


        PShape E = createShape(RECT, UI_Constants.TAB_BUTTON_E_POSITION_X,
                                     UI_Constants.TAB_POSITION_Y,
                                     UI_Constants.TAB_BUTTON_WIDTH,
                                     UI_Constants.TAB_BUTTON_HEIGHT,
                                     UI_Constants.TAB_BUTTON_ROUNDING);
            E.setName("E_Button");
            E.setFill(UI_Constants.TAB_BUTTON_UNSELECTED_FILL);
            E.setStroke(UI_Constants.TAB_BUTTON_UNSELECTED_STROKE);
            E.setStrokeWeight(UI_Constants.TAB_BUTTON_STROKE_WEIGHT);
        
        PShape TAB_SELECTOR_GROUP = createShape(GROUP);
            TAB_SELECTOR_GROUP.setName("TAB_SELECTOR_GROUP");


        this.TAB_SHAPE = createShape(GROUP);
            this.TAB_SHAPE.addChild(TAB_SHAPE);
            this.TAB_SHAPE.addChild(Q);
            this.TAB_SHAPE.addChild(E);
            this.TAB_SHAPE.addChild(TAB_SELECTOR_GROUP);

        this.TAB_SHAPE.translate(UI_Constants.TAB_POSITION_X, UI_Constants.TAB_POSITION_Y - UI_Constants.TAB_PADDING_Y);
        this.TAB_SHAPE.scale(SCALE_FACTOR);
        this.TAB_SHAPE.translate(-UI_Constants.TAB_POSITION_X, -UI_Constants.TAB_POSITION_Y + UI_Constants.TAB_PADDING_Y);
        this.initializeTextAndTabSelector();
    }


    public void initializeTextAndTabSelector() {
        textFont(UI_Constants.TAB_TEXT_FONT);
        textAlign(CENTER, CENTER);
        textSize(UI_Constants.TAB_TEXT_SIZE);

        float totalTextWidth = 0;
        for(String text: UI_Constants.TAB_NAME) {
            totalTextWidth += textWidth(text);
        
        }

        float padding = (UI_Constants.TAB_WIDTH - totalTextWidth) / (UI_Constants.TAB_NAME.length + 1);
        float x = padding + UI_Constants.TAB_POSITION_X - UI_Constants.TAB_WIDTH / 2;

        for(int i = 0; i < UI_Constants.TAB_NAME.length; i++) {
            String text = UI_Constants.TAB_NAME[i];

            float textPositionX = x + textWidth(text) / 2;
            float tabSelectorWidthPadding = padding;

            PShape TabSelectorShape = createShape(RECT, textPositionX, UI_Constants.TAB_POSITION_Y, 
                                                        textWidth(text) + tabSelectorWidthPadding, UI_Constants.TAB_SELECTOR_HEIGHT,
                                                        UI_Constants.TAB_SELECTOR_ROUNDING);

            TabSelectorShape.setFill(UI_Constants.TAB_SELECTOR_FILL);
            TabSelectorShape.setStroke(UI_Constants.TAB_SELECTOR_STROKE);


            this.TAB_SELECTOR[i] = TabSelectorShape;
            this.TAB_SELECTOR_LISTENERS[i] = UI_Constants.createElementListener(TabSelectorShape);

            this.TEXT_POSITION[i] = (textPositionX);

            x += textWidth(text) + padding;
        }

        this.initializeTabSelector();
    }


    public void initializeTabSelector() {
        PShape TAB_SELECTOR_GROUP = this.TAB_SHAPE.getChild("TAB_SELECTOR_GROUP");
        TAB_SELECTOR_GROUP.addChild(this.TAB_SELECTOR[this.activeTabID]);
    }
/*
====================================== Element Updates =============================================
*/

    public void handleActiveTabIDChangesFromKeyPress(int newActiveTabID) {
        this.activeTabID = (newActiveTabID < 0) ? UI_Constants.TAB_NAME.length - 1 : (newActiveTabID >= UI_Constants.TAB_NAME.length) ? 0 : newActiveTabID;
        this.updateWindows();
        this.updateTabSelector();
    }
    public void handleActiveTabIDChange(int newActiveTabID) {
        this.activeTabID = newActiveTabID;
        this.updateWindows();
        this.updateTabSelector();
    }
    public void onQPressed() {
        PShape Q_Shape = this.TAB_SHAPE.getChild("Q_Button");
        Q_Shape.setFill(UI_Constants.TAB_BUTTON_SELECTED_FILL);
        this.handleActiveTabIDChangesFromKeyPress(this.activeTabID - 1);
    }

    public void onQReleased() {
        PShape Q_Shape = this.TAB_SHAPE.getChild("Q_Button");
        Q_Shape.setFill(UI_Constants.TAB_BUTTON_UNSELECTED_FILL);
    }

    public void onEPressed() {
        PShape E_Shape = this.TAB_SHAPE.getChild("E_Button");
        E_Shape.setFill(UI_Constants.TAB_BUTTON_SELECTED_FILL);
        this.handleActiveTabIDChangesFromKeyPress(this.activeTabID + 1);
    }

    public void onEReleased() {
        PShape E_Shape = this.TAB_SHAPE.getChild("E_Button");
        E_Shape.setFill(UI_Constants.TAB_BUTTON_UNSELECTED_FILL);
    }

    
    public void updateTabSelector() {
        this.TAB_SHAPE.getChild("TAB_SELECTOR_GROUP").removeChild(0);
        this.TAB_SHAPE.getChild("TAB_SELECTOR_GROUP").addChild(this.TAB_SELECTOR[this.activeTabID]);
    }


    public void updateWindows() {
        switch(this.activeTabID) {
            case 0:
                UI_Manager.closeAllWindows();
                UI_Manager.getSettingsWindow().open();
                break;
            case 1:
                UI_Manager.closeAllWindows();
                UI_Manager.getHotBar().onSlotChange(UI_Manager.getHotBar().getActiveSlotID());
                break;
            case 2:
                UI_Manager.closeAllWindows();
                UI_Manager.getCreationWindow().open();
                break;
            case 3:
                UI_Manager.closeAllWindows();
                UI_Manager.getHelpWindow().open();
                break;
        }

    }


    public boolean onMousePress() {
        for(int i = 0; i < this.TAB_SELECTOR_LISTENERS.length; i++) {
            if(this.TAB_SELECTOR_LISTENERS[i].contains(mouseX, mouseY)) {
                this.handleActiveTabIDChange(i);
                return true;
            }
        }
        return false;

    }


/*
=========================================== Drawing ================================================
*/
    public void drawTabText() {
        pushMatrix();
        translate(UI_Constants.TAB_POSITION_X, UI_Constants.TAB_POSITION_Y - UI_Constants.TAB_PADDING_Y);
        scale(SCALE_FACTOR);
        translate(-UI_Constants.TAB_POSITION_X, -UI_Constants.TAB_POSITION_Y + UI_Constants.TAB_PADDING_Y);

        fill(UI_Constants.TAB_BUTTON_TEXT_COLOR);
        textFont(UI_Constants.TAB_BUTTON_TEXT_FONT);
        textAlign(CENTER, CENTER);
        textSize(UI_Constants.TAB_BUTTON_TEXT_SIZE);
        text("Q", UI_Constants.TAB_BUTTON_Q_POSITION_X, this.BUTTON_TEXT_POSITION_Y);
        text("E", UI_Constants.TAB_BUTTON_E_POSITION_X, this.BUTTON_TEXT_POSITION_Y);


        textFont(UI_Constants.TAB_TEXT_FONT);
        textAlign(CENTER, CENTER);
        textSize(UI_Constants.TAB_TEXT_SIZE);

        for(int i = 0; i < UI_Constants.TAB_NAME.length; i++) {
            if(i == this.activeTabID) {
                fill(UI_Constants.TAB_TEXT_SELECTED_COLOR);
            } else {
                fill(UI_Constants.TAB_TEXT_UNSELECTED_COLOR);
            }

            text(UI_Constants.TAB_NAME[i], this.TEXT_POSITION[i], this.TEXT_POSITION_Y);
        }
        popMatrix();
    }

    public void drawTabGraphics() {
        shape(this.TAB_SHAPE, 0, 0);
        this.drawTabText();
    }

/*
=========================================== Getters and Setters ====================================
*/
    public PShape getTabShape() {
        return this.TAB_SHAPE;
    }

    public int getActiveTabID() {
        return this.activeTabID;
    }

    public void setActiveTabID(int id) {
        this.activeTabID = id;
        updateTabSelector();
    }
}

public class UI_Text extends UI_Element {

    private float Text_Leading = 1;
    private UI_Window Text_ParentWindow;

    private String Text_Name = "";
    private float Text_Position_X;
    private float Text_Position_Y;

    private float Text_BoxWidth = -1;
    private float Text_BoxHeight = -1;

    private PFont Text_Font = UI_Constants.INTER_BOLD;
    private int Text_AlignMode = 0;
    private int Text_Size = 12;
    private int Text_Color = color(255, 255, 255);

    private boolean Text_ShowName = true;
    
    public UI_Text(String Text_Name, UI_Window Text_ParentWindow, float Text_Position_X, float Text_Position_Y, int Text_AlignMode, int Text_Size, int Text_Color, boolean Text_ShowName, PFont Text_Font) {
        this.Text_Name = Text_Name;
        this.Text_Font = Text_Font;
        this.Text_ParentWindow = Text_ParentWindow;
        this.Text_Position_X = Text_Position_X;
        this.Text_Position_Y = Text_Position_Y;
        this.Text_AlignMode = Text_AlignMode;
        this.Text_Size = Text_Size;
        this.Text_Color = Text_Color;
        this.Text_ShowName = Text_ShowName;

        this.createElementText();
    }

    public UI_Text(String Text_Name, UI_Window Text_ParentWindow, PVector Text_Position, PVector Text_BoxDimensions, int Text_AlignMode, int Text_Size, int Text_Color, boolean Text_ShowName, PFont Text_Font) {
        this.Text_Name = Text_Name;
        this.Text_Font = Text_Font;
        this.Text_ParentWindow = Text_ParentWindow;
        this.Text_Position_X = Text_Position.x;
        this.Text_Position_Y = Text_Position.y;

        this.Text_BoxWidth = Text_BoxDimensions.x;
        this.Text_BoxHeight = Text_BoxDimensions.y;

        this.Text_AlignMode = Text_AlignMode;
        this.Text_Size = Text_Size;
        this.Text_Color = Text_Color;
        this.Text_ShowName = Text_ShowName;

        this.createElementText();
    }

    @Override
    public void createElementBaseShape() {

    }

    @Override
    public void createElementText() {
        textFont(this.Text_Font);
        textSize(this.Text_Size);

        if(this.Text_AlignMode == 0) {
            textAlign(CENTER, CENTER);
        } else if(this.Text_AlignMode == 1) {
            textAlign(LEFT, CENTER);
        } else if(this.Text_AlignMode == 2) {
            textAlign(RIGHT, CENTER);
        } else if(this.Text_AlignMode == 3) {
            textAlign(RIGHT, TOP);
        } else {
            throw new IllegalArgumentException("Invalid Text Alignment Mode");
        }

        this.Text_Position_Y -= (textAscent() - textDescent()) * UI_Constants.GLOBAL_TEXT_ALIGN_FACTOR_Y;
        this.Text_Leading = (textAscent() + textDescent()) * 1.2f;
    }   


    @Override
    public void drawText() {
        if(!this.Text_ShowName) {
            return;
        }
        textFont(this.Text_Font);
        textSize(this.Text_Size);
        fill(this.Text_Color);
        textLeading(this.Text_Leading);

        if(this.Text_AlignMode == 0) {
            textAlign(CENTER, CENTER);
        } else if(this.Text_AlignMode == 1) {
            textAlign(LEFT, CENTER);
        } else if(this.Text_AlignMode == 2) {
            textAlign(RIGHT, CENTER);
        } else if(this.Text_AlignMode == 3) {
            textAlign(LEFT, TOP);
        } else {
            throw new IllegalArgumentException("Invalid Text Alignment Mode");
        }

        if(this.Text_BoxWidth != -1 && this.Text_BoxHeight != -1) {
            rectMode(CORNER);
            text(this.Text_Name, this.Text_Position_X, this.Text_Position_Y, this.Text_BoxWidth, this.Text_BoxHeight);
        } else {
            text(this.Text_Name, this.Text_Position_X, this.Text_Position_Y);
        }

    }
   
   
    
    @Override
    public boolean onMousePress() {
        return false;

    }

    @Override
    public void onMouseRelease() {

    }

    @Override
    public void onMouseDrag() {

    }

    @Override
    public void onSelect() {

    }

    @Override
    public void onDeselect() {
    
    }

    @Override
    public boolean getState() {
        return false;
    }

    @Override
    public void setState(boolean state) {

    }

    @Override
    public float getValue() {
        return -1;
    }

    @Override
    public void setValue(float value) {

    }

    @Override
    public void incrementValue(float amount) {

    }

    @Override
    public String getElementName() {
        return this.Text_Name;
    }

    @Override
    public String getGroupName() {
        return null;
    }

    @Override
    public PShape getShape() {
        return null;
    }
}
public class UI_TextField extends UI_Element {


    private UI_Window TextField_ParentWindow;
    private float TextField_Position_X;
    private float TextField_Position_Y;

    private float TextField_Width = 304f;
    private float TextField_Height = 31f;
   
    private boolean TextField_Stroke_Enabled = false;

    private String TextField_Name = "";
    public String TextField_Text = "";

    public boolean TextField_ShowName = true;

    public boolean TextField_CenterX = false;

    private float TextField_Text_Position_X;
    private float TextField_Text_Position_Y;

    private int TextField_TextLength = 0;

    private boolean selected = false;

    private PShape TextField_Shape_Group = createShape(GROUP);
   

    public UI_TextField(String TextField_Name, UI_Window TextField_ParentWindow, float TextField_Position_X, float TextField_Position_Y, float TextField_Width, float TextField_Height) {
        this.TextField_Name = TextField_Name;
        this.TextField_ParentWindow = TextField_ParentWindow;
        this.TextField_Position_X = TextField_Position_X;
        this.TextField_Position_Y = TextField_Position_Y;

        this.Element_Width = (int)TextField_Width;
        this.Element_Height = (int)TextField_Height;
        this.TextField_Width = TextField_Width;
        this.TextField_Height = TextField_Height;

        this.TextField_Shape_Group.setName(this.TextField_Name + "Group");

        this.initializeTextField();
      
   }

   public UI_TextField(String TextField_Name, UI_Window TextField_ParentWindow, float TextField_Position_X, float TextField_Position_Y, float TextField_Width, float TextField_Height, boolean TextField_CenterX) {
        this.TextField_Name = TextField_Name;
        this.TextField_ParentWindow = TextField_ParentWindow;
        this.TextField_Position_X = TextField_Position_X;
        this.TextField_Position_Y = TextField_Position_Y;

        this.TextField_CenterX = TextField_CenterX;

        this.Element_Width = (int)TextField_Width;
        this.Element_Height = (int)TextField_Height;
        this.TextField_Width = TextField_Width;
        this.TextField_Height = TextField_Height;

        this.TextField_Shape_Group.setName(this.TextField_Name + "Group");

        this.initializeTextField();
      
   }

    public UI_TextField(String TextField_Name, UI_Window TextField_ParentWindow, float TextField_Position_X, float TextField_Position_Y) {
        this.TextField_Name = TextField_Name;   

        this.TextField_ParentWindow = TextField_ParentWindow;

        this.TextField_Position_X = TextField_Position_X;
        this.TextField_Position_Y = TextField_Position_Y;

        this.Element_Width = 290;
        this.Element_Height = 31;

        this.TextField_Width = this.Element_Width;
        this.TextField_Height = this.Element_Height;

        this.initializeTextField();
    }


    public void initializeTextField() {
        rectMode(CENTER);
        this.createElementBaseShape();
        this.createElementText();

        if(!this.TextField_Name.equals("Level Name")) {
            this.onSelect();
        }
    }
    @Override
    public void createElementBaseShape() {
        PShape TextField_Shape_Base = createShape(RECT, TextField_Position_X, TextField_Position_Y, TextField_Width, TextField_Height, this.Element_Rounding);
            TextField_Shape_Base.setName("Base");
            TextField_Shape_Base.setFill(false);
            TextField_Shape_Base.setStroke(this.Element_Base_Unselected_Stroke_Color);

        PShape TextField_Shape_Base_Listener = UI_Constants.createElementListener(TextField_Shape_Base);
            TextField_Shape_Base_Listener.setName("Listener");

        this.TextField_Shape_Group.addChild(TextField_Shape_Base);
        this.TextField_Shape_Group.addChild(TextField_Shape_Base_Listener);
    }

    @Override
    public void createElementText() {
        textFont(this.Element_Font);
        textSize(this.Element_Text_Size);
        if(this.TextField_CenterX) {
            textAlign(CENTER, CENTER);
            this.TextField_Text_Position_X = this.TextField_Position_X;
            this.TextField_Text_Position_Y = this.TextField_Position_Y - (textAscent() - textDescent()) * UI_Constants.GLOBAL_TEXT_ALIGN_FACTOR_Y;
        } else {
            textAlign(LEFT, CENTER);
            this.TextField_Text_Position_X = this.TextField_Position_X - (this.TextField_Width/2) + 17;
            this.TextField_Text_Position_Y = this.TextField_Position_Y - (textAscent() - textDescent()) * UI_Constants.GLOBAL_TEXT_ALIGN_FACTOR_Y;
        }
    }


    @Override
    public void drawText() {
        textFont(this.Element_Font);
        textSize(this.Element_Text_Size);
        if(this.TextField_CenterX) {
            textAlign(CENTER, CENTER);
        } else {
            textAlign(LEFT, CENTER);
        }

        if(!this.selected && this.TextField_Text.equals("") && this.TextField_ShowName) {
            fill(color(255, 255, 255, 166));
            text(this.TextField_Name, this.TextField_Text_Position_X, this.TextField_Text_Position_Y);
        } else {
            fill(color(255, 255, 255, 255));
            text(this.TextField_Text, this.TextField_Text_Position_X, this.TextField_Text_Position_Y);
        }
    }
   
   // IF THE KEYCODE IS ENTER RETURN 1
   // ELSE RETURN 0

    public boolean keyPress(char Key, int KeyCode) {
        if(this.selected) {
            if(KeyCode == BACKSPACE) {
                this.Backspace();
            } else if(KeyCode == 32) {
                this.addText(' ');
            } else if(KeyCode == ENTER) {
                if(this.TextField_Name.equals("Level Name")) {
                    UI_CreationWindow creationWindow = (UI_CreationWindow)this.TextField_ParentWindow;
                    creationWindow.onLevelSaved();
                    this.onDeselect();
                    return true;
                } else if(this.TextField_Name.equals("Rename Level TextField")){
                    UI_CreationWindow creationWindow = (UI_CreationWindow)this.TextField_ParentWindow;
                    creationWindow.onLevelRenamed();
                    this.onDeselect();
                    return true;
                }
            } else {
                boolean isKeyLetter = (Character.toLowerCase(Key) >= 'a' && Character.toLowerCase(Key) <= 'z');
                boolean isKeyNumber = (Key >= '0' && Key <= '9');


                if(isKeyLetter || isKeyNumber) {
                    if(KeyHandler.isKeyDown(KeyEvent.VK_SHIFT)) {
                        this.addText(Character.toUpperCase(Key));
                    } else {
                        this.addText(Character.toLowerCase(Key));
                    }
                }
            }
        }
        return false;
    }

   
   private void addText(char text) {
      if (textWidth(this.TextField_Text + text) < this.TextField_Width - 20) {
         this.TextField_Text += text;
         this.TextField_TextLength++;
      }
   }
   
   private void Backspace() {
      if (this.TextField_TextLength - 1 >= 0) {
         this.TextField_Text = this.TextField_Text.substring(0, this.TextField_TextLength - 1);
         this.TextField_TextLength--;
      }
   }
    
    @Override
    public boolean onMousePress() {
        float x = mouseX - this.TextField_ParentWindow.getWindowPosition().x;
        float y = mouseY - this.TextField_ParentWindow.getWindowPosition().y;

        if(this.TextField_Shape_Group.getChild("Listener").contains(x, y)) {
            this.onSelect();
            return true;
        } else {
            this.onDeselect();
            return false;
        }
    }

    @Override
    public void onMouseRelease() {

    }

    @Override
    public void onMouseDrag() {

    }

    @Override
    public void onSelect() {
        this.selected = true;
        IS_TEXTFIELD_ACTIVE = true;

        this.TextField_Shape_Group.getChild("Base").setStroke(UI_Constants.GRAY_300);
    }

    @Override
    public void onDeselect() {
        this.TextField_Text = "";
        this.TextField_TextLength = 0;
        this.selected = false;
        IS_TEXTFIELD_ACTIVE = false;
        this.TextField_Shape_Group.getChild("Base").setStroke(UI_Constants.GRAY_500);
        
        if(this.TextField_Name.equals("Rename Level TextField")) {
            UI_CreationWindow creationWindow = (UI_CreationWindow)this.TextField_ParentWindow;
            creationWindow.state = UI_State.DEFAULT;
            creationWindow.previousState = UI_State.DEFAULT;
            creationWindow.redrawState();
        } else if (this.TextField_Name.equals("Level Name")) {
            UI_CreationWindow creationWindow = (UI_CreationWindow)this.TextField_ParentWindow;
            creationWindow.previousState = UI_State.DEFAULT;
            creationWindow.state = UI_State.DEFAULT;
            creationWindow.redrawState();
        }
    }

    
    private void onHover() {
        this.TextField_Shape_Group.getChild("Base").setStroke(UI_Constants.GRAY_400);
    }

    @Override
    public boolean getState() {
        return this.selected;
    }

    @Override
    public void setState(boolean state) {
        this.selected = state;
    }

    @Override
    public float getValue() {
        return 0;
    }

    @Override
    public void setValue(float value) {

    }

    @Override
    public void incrementValue(float amount) {

    }

    @Override
    public String getElementName() {
        return this.TextField_Name;
    }

    @Override
    public String getGroupName() {
        return null;
    }

    @Override
    public PShape getShape() {
        return this.TextField_Shape_Group;
    }
}
public class UI_TickSlider extends UI_Element {

    private UI_Window TickSlider_ParentWindow;

    public String TickSlider_Name;
    private String[] TickSlider_Names;

    private float[] TickSlider_Names_Position_X;
    private float TickSlider_Names_Position_Y;
    private int TickSlider_NumNames;

    private String TickSlider_CurrentValue;
    private int TickSlider_CurrentValue_Index = -1;
    private int TickSlider_PreviousValue_Index = -1;

    private float TickSlider_Width = 280;
    private float TickSlider_Height = 30;

    private float TickSlider_Position_X;
    private float TickSlider_Position_Y;
    private float TickSlider_Tick_Width;


    private boolean mouseOverTickSliderOnMouseDown = false;

    public PShape TickSlider_Shape_Group = createShape(GROUP);


    public UI_TickSlider(String[] TickSlider_Names, UI_Window TickSlider_ParentWindow, String TickSlider_CurrentValue, float TickSlider_Position_X, float TickSlider_Position_Y, float TickSlider_Tick_Width) {
        
        this.TickSlider_ParentWindow = TickSlider_ParentWindow;

        this.TickSlider_Names = TickSlider_Names;
        this.TickSlider_Names_Position_X = new float[TickSlider_Names.length];
        this.TickSlider_NumNames = TickSlider_Names.length;


        this.TickSlider_CurrentValue = TickSlider_CurrentValue;

        for (int i = 0; i < this.TickSlider_Names.length; i++) {
            if (this.TickSlider_Names[i].equals(TickSlider_CurrentValue)) {
                this.TickSlider_CurrentValue_Index = i;
                break;
            }
        }

        this.TickSlider_PreviousValue_Index = this.TickSlider_CurrentValue_Index;

        this.TickSlider_Position_X = TickSlider_Position_X;
        this.TickSlider_Position_Y = TickSlider_Position_Y;
        this.TickSlider_Tick_Width = TickSlider_Tick_Width;

        if(this.TickSlider_CurrentValue_Index == -1) {
            this.TickSlider_CurrentValue = this.TickSlider_Names[0];
            this.TickSlider_CurrentValue_Index = 0;
        }

        this.initializeTickSlider();
    }




    public void initializeTickSlider() {
        rectMode(CENTER);
        this.createElementBaseShape();
        this.createElementText();
    }




/*
======================================= Slider Creation ============================================
*/  
    @Override
    public void createElementBaseShape() {
        rectMode(CENTER);

        float tickSliderShapeX = this.TickSlider_Position_X;
        float tickSliderShapeY = this.TickSlider_Position_Y;

        float tickSliderShapeWidth = this.TickSlider_Width;
        float tickSliderShapeHeight = this.TickSlider_Height;


        PShape TickSlider_Shape_Base = createShape(RECT, tickSliderShapeX, tickSliderShapeY, tickSliderShapeWidth, tickSliderShapeHeight, this.Element_Rounding);
            TickSlider_Shape_Base.setName("TickSlider_Shape_Base");
            TickSlider_Shape_Base.setStrokeWeight(this.Element_Stroke_Weight);
            TickSlider_Shape_Base.setFill(this.Element_Base_Unselected_Color);
            TickSlider_Shape_Base.setStroke(this.Element_Base_Unselected_Stroke_Color);

        PShape TickSlider_Shape_Base_Listener = UI_Constants.createElementListener(TickSlider_Shape_Base);
            TickSlider_Shape_Base_Listener.setName("TickSlider_Shape_Base_Listener");

        PShape TickSlider_Indicator_Left = createShape(TRIANGLE, tickSliderShapeX - tickSliderShapeWidth/2, tickSliderShapeY + tickSliderShapeHeight/2, tickSliderShapeX - tickSliderShapeWidth/2 - 8, tickSliderShapeY + tickSliderShapeHeight/2 + 17, tickSliderShapeX - tickSliderShapeWidth/2 + 8,tickSliderShapeY + tickSliderShapeHeight/2 + 17);
            TickSlider_Indicator_Left.setName("TickSlider_Indicator_Left");
            TickSlider_Indicator_Left.setStrokeWeight(0);
            TickSlider_Indicator_Left.setFill(UI_Constants.WHITE);
            TickSlider_Indicator_Left.setStroke(false);
            TickSlider_Indicator_Left.setVisible(false);
            TickSlider_Indicator_Left.translate(2, 0);

        PShape TickSlider_Indicator_Right = createShape(TRIANGLE, tickSliderShapeX + tickSliderShapeWidth/2, tickSliderShapeY + tickSliderShapeHeight/2, tickSliderShapeX + tickSliderShapeWidth/2 - 8, tickSliderShapeY + tickSliderShapeHeight/2 + 17, tickSliderShapeX + tickSliderShapeWidth/2 + 8,tickSliderShapeY + tickSliderShapeHeight/2 + 17);
            TickSlider_Indicator_Right.setName("TickSlider_Indicator_Right");
            TickSlider_Indicator_Right.setStrokeWeight(0);
            TickSlider_Indicator_Right.setFill(UI_Constants.WHITE);
            TickSlider_Indicator_Right.setStroke(false);
            TickSlider_Indicator_Right.setVisible(false);
            TickSlider_Indicator_Right.translate(-2, 0);

        PShape TickSlider_Indicator_Middle = createShape(TRIANGLE, tickSliderShapeX, tickSliderShapeY + tickSliderShapeHeight/2, tickSliderShapeX - 8, tickSliderShapeY + tickSliderShapeHeight/2 + 17, tickSliderShapeX + 8,tickSliderShapeY + tickSliderShapeHeight/2 + 17);
            TickSlider_Indicator_Middle.setName("TickSlider_Indicator_Middle");
            TickSlider_Indicator_Middle.setStrokeWeight(0);
            TickSlider_Indicator_Middle.setFill(UI_Constants.WHITE);
            TickSlider_Indicator_Middle.setVisible(false);
            TickSlider_Indicator_Middle.setStroke(false);
            TickSlider_Indicator_Middle.translate(0, 0);


        if(this.TickSlider_Names.length == 3) {
            PShape TickSlider_Shape_Tick = createShape(RECT, tickSliderShapeX, tickSliderShapeY, this.TickSlider_Tick_Width, tickSliderShapeHeight - 2, this.Element_Rounding);
                TickSlider_Shape_Tick.setName("TickSlider_Shape_Tick");
                TickSlider_Shape_Tick.setStrokeWeight(0);
                TickSlider_Shape_Tick.setStroke(false);

            if(this.TickSlider_CurrentValue_Index == 1) {
                TickSlider_Shape_Tick.setFill(UI_Constants.WHITE);
            } else {
                TickSlider_Shape_Tick.setFill(UI_Constants.GRAY_25);
            }

            this.TickSlider_Shape_Group.addChild(TickSlider_Shape_Base);
            this.TickSlider_Shape_Group.addChild(TickSlider_Shape_Base_Listener);
            this.TickSlider_Shape_Group.addChild(TickSlider_Indicator_Left);
            this.TickSlider_Shape_Group.addChild(TickSlider_Indicator_Middle);
            this.TickSlider_Shape_Group.addChild(TickSlider_Indicator_Right);
            this.TickSlider_Shape_Group.addChild(TickSlider_Shape_Tick);
        } else {
            this.TickSlider_Shape_Group.addChild(TickSlider_Shape_Base);
            this.TickSlider_Shape_Group.addChild(TickSlider_Shape_Base_Listener);
            this.TickSlider_Shape_Group.addChild(TickSlider_Indicator_Left);
            this.TickSlider_Shape_Group.addChild(TickSlider_Indicator_Middle);
            this.TickSlider_Shape_Group.addChild(TickSlider_Indicator_Right);

        }
        this.initializeTickSliderShape();
    }

    @Override 
    public void createElementText() {
        float[] tickSliderShapeParams = this.TickSlider_Shape_Group.getChild("TickSlider_Shape_Base").getParams();
        if(this.TickSlider_NumNames == 2) {
            this.TickSlider_Names_Position_X[0] = tickSliderShapeParams[0] - tickSliderShapeParams[2] / 2;
            this.TickSlider_Names_Position_X[1] = tickSliderShapeParams[0] + tickSliderShapeParams[2] / 2; 

            this.TickSlider_Names_Position_Y = tickSliderShapeParams[1] - tickSliderShapeParams[3] / 2 - 11;
        } else if(this.TickSlider_NumNames == 3) {
            this.TickSlider_Names_Position_X[0] = tickSliderShapeParams[0] - tickSliderShapeParams[2] / 2;
            this.TickSlider_Names_Position_X[1] = tickSliderShapeParams[0];
            this.TickSlider_Names_Position_X[2] = tickSliderShapeParams[0] + tickSliderShapeParams[2] / 2;

            this.TickSlider_Names_Position_Y = tickSliderShapeParams[1] - tickSliderShapeParams[3] / 2 - 11;
        }
    }


    

/*
======================================= Slider Interaction =========================================
*/  
    @Override
    public boolean onMousePress() {
        float x = mouseX - this.TickSlider_ParentWindow.getWindowPosition().x;
        float y = mouseY - this.TickSlider_ParentWindow.getWindowPosition().y;
        return this.TickSlider_Shape_Group.getChild("TickSlider_Shape_Base_Listener").contains(x, y);
    }

    @Override
    public void onMouseDrag() {
        if(this.mouseOverTickSliderOnMouseDown) {
            float x = mouseX - this.TickSlider_ParentWindow.getWindowPosition().x;
            float[] baseShapeParams = this.TickSlider_Shape_Group.getChild("TickSlider_Shape_Base").getParams();
            

            //The 1/2 is there because you need to shift over by width/2 
            float relativePosition = constrain((x - baseShapeParams[0] + baseShapeParams[2]*0.5f) / baseShapeParams[2], 0, 1);

            if(this.TickSlider_NumNames == 3) {
                if(relativePosition < 0.25f) {
                    this.TickSlider_CurrentValue = this.TickSlider_Names[0];
                    this.TickSlider_CurrentValue_Index = 0;
                } else if(relativePosition < 0.75f) {
                    this.TickSlider_CurrentValue = this.TickSlider_Names[1];
                    this.TickSlider_CurrentValue_Index = 1;
                } else {
                    this.TickSlider_CurrentValue = this.TickSlider_Names[2];
                    this.TickSlider_CurrentValue_Index = 2;
                }
            } else {
                if(relativePosition < 0.5f) {
                    this.TickSlider_CurrentValue = this.TickSlider_Names[0];
                    this.TickSlider_CurrentValue_Index = 0;
                } else {
                    this.TickSlider_CurrentValue = this.TickSlider_Names[1];
                    this.TickSlider_CurrentValue_Index = 1;
                }
            }
            this.updateTickSliderShape();
        }
    }

    @Override 
    public void onMouseRelease() {
        this.mouseOverTickSliderOnMouseDown = false;
    }
    

    @Override
    public void onSelect() {
        this.mouseOverTickSliderOnMouseDown = true;
    }

    @Override
    public void onDeselect() {
        this.mouseOverTickSliderOnMouseDown = false;
    }

/*
==================================== Slider Methods ================================================
*/
    public void initializeTickSliderShape() {
        rectMode(CORNER);
        boolean createShape = true;
        int roundingLT = this.Element_Rounding;
        int roundingRT = this.Element_Rounding;
        int roundingLB = this.Element_Rounding;
        int roundingRB = this.Element_Rounding;

        float[] tickSliderShapeParams = this.TickSlider_Shape_Group.getChild("TickSlider_Shape_Base").getParams();
        float tickSliderShapeX = tickSliderShapeParams[0] - tickSliderShapeParams[2] / 2;
        float tickSliderShapeY = tickSliderShapeParams[1] - tickSliderShapeParams[3] / 2;
        float tickSliderShapeHeight = tickSliderShapeParams[3];
        float tickSliderShapeWidth;

        if(this.TickSlider_Names.length == 3) {
            if(this.TickSlider_CurrentValue_Index == 0) {
                tickSliderShapeWidth = 0;
                createShape = false;
                this.TickSlider_Shape_Group.getChild("TickSlider_Indicator_Left").setVisible(true);
            } else if(this.TickSlider_CurrentValue_Index == 1) {
                roundingRT = 0;
                roundingRB = 0;
                tickSliderShapeWidth = tickSliderShapeParams[2] / 2;
                this.TickSlider_Shape_Group.getChild("TickSlider_Indicator_Middle").setVisible(true);
            } else {
                tickSliderShapeWidth = tickSliderShapeParams[2];
                this.TickSlider_Shape_Group.getChild("TickSlider_Indicator_Right").setVisible(true);
            }
        } else {
            if(this.TickSlider_CurrentValue_Index == 0) {
                tickSliderShapeWidth = 0;
                createShape = false;
                this.TickSlider_Shape_Group.getChild("TickSlider_Indicator_Left").setVisible(true);
            } else {
                tickSliderShapeWidth = tickSliderShapeParams[2];
                this.TickSlider_Shape_Group.getChild("TickSlider_Indicator_Right").setVisible(true);
            }
        }

        if(createShape) {
            PShape TickSlider_Value_Shape = createShape(RECT, tickSliderShapeX, tickSliderShapeY, tickSliderShapeWidth, tickSliderShapeHeight, roundingLT, roundingRT, roundingRB, roundingLB);
                TickSlider_Value_Shape.setName("TickSlider_Value_Shape");
                TickSlider_Value_Shape.setStrokeWeight(this.Element_Stroke_Weight);
                TickSlider_Value_Shape.setFill(this.Element_Base_Selected_Color);
                TickSlider_Value_Shape.setStroke(false);
                this.TickSlider_Shape_Group.addChild(TickSlider_Value_Shape);
        }

        this.addTick();
    }

    private void addTick() {
        if(this.TickSlider_Shape_Group.getChild("TickSlider_Shape_Tick") == null) {
            return;
        }

        rectMode(CENTER);
        this.TickSlider_Shape_Group.removeChild(this.TickSlider_Shape_Group.getChildIndex(this.TickSlider_Shape_Group.getChild("TickSlider_Shape_Tick")));

        PShape TickSlider_Shape_Tick = createShape(RECT, this.TickSlider_Position_X, this.TickSlider_Position_Y, this.TickSlider_Tick_Width, this.TickSlider_Height - 2, this.Element_Rounding);
                TickSlider_Shape_Tick.setName("TickSlider_Shape_Tick");
                TickSlider_Shape_Tick.setStrokeWeight(0);
                TickSlider_Shape_Tick.setStroke(false);
        if(this.TickSlider_CurrentValue_Index == 1) {
            TickSlider_Shape_Tick.setFill(UI_Constants.WHITE);
        } else {
            TickSlider_Shape_Tick.setFill(UI_Constants.GRAY_25);
        }

        this.TickSlider_Shape_Group.addChild(TickSlider_Shape_Tick);
    }

    public void updateTickSliderShape() {
        if(this.TickSlider_PreviousValue_Index == this.TickSlider_CurrentValue_Index) {
            return;
        }

        if(this.TickSlider_Shape_Group.getChild("TickSlider_Value_Shape") != null) {
            this.TickSlider_Shape_Group.removeChild(this.TickSlider_Shape_Group.getChildIndex(this.TickSlider_Shape_Group.getChild("TickSlider_Value_Shape")));
        }

        rectMode(CORNER);
        boolean createShape = true;

        int roundingLT = this.Element_Rounding;
        int roundingRT = this.Element_Rounding;
        int roundingLB = this.Element_Rounding;
        int roundingRB = this.Element_Rounding;

        float[] tickSliderShapeParams = this.TickSlider_Shape_Group.getChild("TickSlider_Shape_Base").getParams();
        float tickSliderShapeX = tickSliderShapeParams[0] - tickSliderShapeParams[2] / 2;
        float tickSliderShapeY = tickSliderShapeParams[1] - tickSliderShapeParams[3] / 2;
        float tickSliderShapeHeight = tickSliderShapeParams[3];

        float tickSliderShapeWidth;

        if(this.TickSlider_NumNames == 3) {
            if(this.TickSlider_CurrentValue_Index == 0) {
                tickSliderShapeWidth = 0;
                createShape = false;

                switch(this.TickSlider_PreviousValue_Index) {
                    case 1:
                        this.TickSlider_Shape_Group.getChild("TickSlider_Indicator_Middle").setVisible(false);
                        break;
                    case 2:
                        this.TickSlider_Shape_Group.getChild("TickSlider_Indicator_Right").setVisible(false);
                        break;
                }

                this.TickSlider_Shape_Group.getChild("TickSlider_Indicator_Left").setVisible(true);
            } else if(this.TickSlider_CurrentValue_Index == 1) {
                tickSliderShapeWidth = tickSliderShapeParams[2] / 2;
                roundingRT = 0;
                roundingRB = 0;

                switch(this.TickSlider_PreviousValue_Index){
                    case 0:
                        this.TickSlider_Shape_Group.getChild("TickSlider_Indicator_Left").setVisible(false);
                        break;
                    case 2:
                        this.TickSlider_Shape_Group.getChild("TickSlider_Indicator_Right").setVisible(false);
                        break;
                }

                this.TickSlider_Shape_Group.getChild("TickSlider_Indicator_Middle").setVisible(true);
            } else {
                tickSliderShapeWidth = tickSliderShapeParams[2];

                switch(this.TickSlider_PreviousValue_Index){
                    case 0:
                        this.TickSlider_Shape_Group.getChild("TickSlider_Indicator_Left").setVisible(false);
                        break;
                    case 1:
                        this.TickSlider_Shape_Group.getChild("TickSlider_Indicator_Middle").setVisible(false);
                        break;
                }

                this.TickSlider_Shape_Group.getChild("TickSlider_Indicator_Right").setVisible(true);
            }
        } else {
            if(this.TickSlider_CurrentValue_Index == 0) {
                tickSliderShapeWidth = 0;
                createShape = false;
                this.TickSlider_Shape_Group.getChild("TickSlider_Indicator_Right").setVisible(false);
                this.TickSlider_Shape_Group.getChild("TickSlider_Indicator_Left").setVisible(true);
            } else {
                tickSliderShapeWidth = tickSliderShapeParams[2];
                this.TickSlider_Shape_Group.getChild("TickSlider_Indicator_Left").setVisible(false);
                this.TickSlider_Shape_Group.getChild("TickSlider_Indicator_Right").setVisible(true);
            }
        }

        if(createShape) {
            PShape TickSlider_Value_Shape = createShape(RECT, tickSliderShapeX, tickSliderShapeY, tickSliderShapeWidth, tickSliderShapeHeight, roundingLT, roundingRT, roundingRB, roundingLB);
                TickSlider_Value_Shape.setName("TickSlider_Value_Shape");
                TickSlider_Value_Shape.setStrokeWeight(this.Element_Stroke_Weight);
                TickSlider_Value_Shape.setFill(this.Element_Base_Selected_Color);
                TickSlider_Value_Shape.setStroke(this.Element_Base_Selected_Stroke_Color);
            this.TickSlider_Shape_Group.addChild(TickSlider_Value_Shape);
        }

        this.addTick();

        this.TickSlider_PreviousValue_Index = this.TickSlider_CurrentValue_Index;
    }

/*
===================================== Slider Draw ==================================================
*/

    @Override
    public void drawText() {
        for(int i = 0; i < this.TickSlider_NumNames; i++) {
            if(i == this.TickSlider_CurrentValue_Index) {
                fill(UI_Constants.WHITE);
            } else {
                fill(UI_Constants.GRAY_25);
            }

            textFont(UI_Constants.INTER_BOLD);
            textSize(11);

            if(i == 0) {
                textAlign(LEFT, BASELINE);
            } else if(i == this.TickSlider_NumNames - 1) {
                textAlign(RIGHT, BASELINE);
            } else {
                textAlign(CENTER, BASELINE);
            }

            text(this.TickSlider_Names[i], this.TickSlider_Names_Position_X[i], this.TickSlider_Names_Position_Y);

        }
    }


/*
======================================= Toggle Getters and Setters =================================
*/  
    @Override   
    public String getElementName() {
        return this.TickSlider_CurrentValue;
    }
    @Override
    public String getGroupName() {
        return null;
    }

    @Override
    public PShape getShape() {
        return this.TickSlider_Shape_Group;
    }

    @Override
    public float getValue() {
        return -1;
    }

    @Override
    public boolean getState() {
        return false;
    }

    @Override
    public void setValue(float value) {
        if(this.TickSlider_NumNames == 2) {
            if(value < 0.5f) {
                this.TickSlider_CurrentValue = this.TickSlider_Names[0];
                this.TickSlider_CurrentValue_Index = 0;
            } else {
                this.TickSlider_CurrentValue = this.TickSlider_Names[1];
                this.TickSlider_CurrentValue_Index = 1;
            }
        } else if(this.TickSlider_NumNames == 3) {
            if(value < 0.25f) {
                this.TickSlider_CurrentValue = this.TickSlider_Names[0];
                this.TickSlider_CurrentValue_Index = 0;
            } else if(value < 0.75f) {
                this.TickSlider_CurrentValue = this.TickSlider_Names[1];
                this.TickSlider_CurrentValue_Index = 1;
            } else {
                this.TickSlider_CurrentValue = this.TickSlider_Names[2];
                this.TickSlider_CurrentValue_Index = 2;
            }
        }
        this.updateTickSliderShape();
    }

    @Override
    public void incrementValue(float amount) {
        return;
    }

    @Override
    public void setState(boolean state) {
        return;
    }

}   
public class UI_Toggle extends UI_Element {
    

    public UI_Window Toggle_ParentWindow;

    public String Toggle_Name;
    public float Toggle_Name_Position_X;
    public float Toggle_Name_Position_Y;


    public float Toggle_Position_X = -1;
    public float Toggle_Position_Y = -1;

    public String Toggle_GroupName = null;
    public boolean Toggle_State;

    public float Toggle_Scale = -1;

    public PShape Toggle_Shape_Group = createShape(GROUP);


    public UI_Toggle(String Toggle_Name, UI_Window Toggle_ParentWindow, boolean Toggle_State) {
        this.Toggle_Name = Toggle_Name;
        this.Toggle_Shape_Group.setName(this.Toggle_Name + "Group");
        this.Toggle_ParentWindow = Toggle_ParentWindow;

        this.Toggle_State = Toggle_State;

        this.initializeToggle();
    }

    public UI_Toggle(String Toggle_Name, UI_Window Toggle_ParentWindow, float Toggle_Position_X, float Toggle_Position_Y, boolean Toggle_State, float Toggle_Scale) {
        this.Toggle_Name = Toggle_Name;
        this.Toggle_Shape_Group.setName(this.Toggle_Name + "Group");
        this.Toggle_ParentWindow = Toggle_ParentWindow;

        this.Toggle_Scale = Toggle_Scale;
        this.Toggle_State = Toggle_State;

        this.Toggle_Position_X = Toggle_Position_X;
        this.Toggle_Position_Y = Toggle_Position_Y;

        this.initializeToggle();
    }


    public UI_Toggle(String Toggle_Name, UI_Window Toggle_ParentWindow, String Toggle_GroupName, boolean Toggle_State) {

        this.Toggle_Shape_Group.setName(this.Toggle_Name + "Group");
        
        this.Toggle_Name = Toggle_Name;
        this.Toggle_ParentWindow = Toggle_ParentWindow;
        this.Toggle_GroupName = Toggle_GroupName;

        this.Toggle_State = Toggle_State;

        this.initializeToggle();
    }


    public void initializeToggle() {
        rectMode(CENTER);
        this.createElementBaseShape();
        this.createElementText();
    }




/*
======================================= Toggle Creation ============================================
*/  
    @Override
    public void createElementBaseShape() {
        rectMode(CENTER);
        int numElements = this.Toggle_ParentWindow.getWindowElementArrayListSize();

        float toggleShapeX;
        float toggleShapeY;
        float toggleShapeWidth;
        float toggleShapeHeight;

        float toggleTickboxX;
        float toggleTickboxY;
        float toggleTickboxWidth;
        float toggleTickboxHeight;

        if(this.Toggle_Position_X == -1 && this.Toggle_Position_Y == -1) {
            if(numElements == 0) {
                toggleShapeX = 0;
                toggleShapeY = -this.Toggle_ParentWindow.getWindowFormContainerHeight() / 2 + this.Element_Container_Top_Padding_Y + this.Element_Height / 2;
                toggleShapeWidth = this.Element_Width;
                toggleShapeHeight = this.Element_Height;

                toggleTickboxX = toggleShapeX - toggleShapeWidth / 2 + this.Element_Tickbox_Padding_X + this.Element_Tickbox_Width / 2;
                toggleTickboxY = toggleShapeY;
                toggleTickboxWidth = this.Element_Tickbox_Width;
                toggleTickboxHeight = this.Element_Tickbox_Height;
                
            } else {
                toggleShapeX = 0;
                toggleShapeY = (this.Element_Height - this.Toggle_ParentWindow.getWindowFormContainerHeight()) /2 + (this.Element_Height + this.Element_Element_Padding_Y) * numElements + this.Element_Container_Top_Padding_Y;
                toggleShapeWidth = this.Element_Width;
                toggleShapeHeight = this.Element_Height;

                toggleTickboxX = toggleShapeX - toggleShapeWidth / 2 + this.Element_Tickbox_Padding_X + this.Element_Tickbox_Width / 2;
                toggleTickboxY = toggleShapeY;
                toggleTickboxWidth = this.Element_Tickbox_Width;
                toggleTickboxHeight = this.Element_Tickbox_Height;

            }
        } else {
            toggleShapeX = this.Toggle_Position_X;
            toggleShapeY = this.Toggle_Position_Y;
            toggleShapeWidth = this.Element_Width;
            toggleShapeHeight = this.Element_Height;

            toggleTickboxX = toggleShapeX - toggleShapeWidth / 2 + this.Element_Tickbox_Padding_X + this.Element_Tickbox_Width / 2;
            toggleTickboxY = toggleShapeY;
            toggleTickboxWidth = this.Element_Tickbox_Width;
            toggleTickboxHeight = this.Element_Tickbox_Height;
        }

        PShape Toggle_Shape_Base = createShape(RECT, toggleShapeX, toggleShapeY, toggleShapeWidth, toggleShapeHeight, this.Element_Rounding);
            Toggle_Shape_Base.setName("Toggle_Shape_Base");
            Toggle_Shape_Base.setStrokeWeight(this.Element_Stroke_Weight);
            Toggle_Shape_Base.setFill(this.Element_Base_Unselected_Color);
            Toggle_Shape_Base.setStroke(this.Element_Base_Unselected_Stroke_Color);

        PShape Toggle_TickBox = createShape(RECT, toggleTickboxX, toggleTickboxY, toggleTickboxWidth, toggleTickboxHeight, this.Element_Rounding);
            Toggle_TickBox.setName("Toggle_Shape_TickBox");
            Toggle_TickBox.setStrokeWeight(this.Element_Stroke_Weight);
            Toggle_TickBox.setFill(UI_Constants.GRAY_600);
            Toggle_TickBox.setStroke(UI_Constants.GRAY_600);

        PShape Toggle_TickMark = createShape();
            Toggle_TickMark.beginShape();
                Toggle_TickMark.vertex(toggleTickboxX + 8, toggleTickboxY - 5);
                Toggle_TickMark.vertex(toggleTickboxX - 2, toggleTickboxY + 5);
                Toggle_TickMark.vertex(toggleTickboxX - 7, toggleTickboxY);
            Toggle_TickMark.endShape();

            Toggle_TickMark.setName("Toggle_Shape_TickMark");
            Toggle_TickMark.setFill(false);
            Toggle_TickMark.setStroke(UI_Constants.GRAY_150);

            Toggle_TickMark.setStrokeWeight(2);

        PShape Toggle_Shape_Base_Listener = UI_Constants.createElementListener(Toggle_Shape_Base);


        this.Toggle_Shape_Group.addChild(Toggle_Shape_Base);
        this.Toggle_Shape_Group.addChild(Toggle_TickBox);
        this.Toggle_Shape_Group.addChild(Toggle_Shape_Base_Listener);
        this.Toggle_Shape_Group.addChild(Toggle_TickMark);

        if(this.Toggle_State) {
            this.onSelect();
        } else {
            this.onDeselect();
        }

        if(this.Toggle_Scale != -1) {
            this.Toggle_Shape_Group.resetMatrix();
            this.Toggle_Shape_Group.scale(this.Toggle_Scale);
        }
    }

    @Override 
    public void createElementText() {
        textFont(this.Element_Font);
        textSize(this.Element_Text_Size);
        textAlign(CENTER, CENTER);

        float[] TickboxParams = this.Toggle_Shape_Group.getChild("Toggle_Shape_TickBox").getParams();
        this.Toggle_Name_Position_X = TickboxParams[0] + TickboxParams[2] / 2 + 10 + textWidth(this.Toggle_Name) / 2 + 5;
        this.Toggle_Name_Position_Y = this.Toggle_Shape_Group.getChild("Toggle_Shape_Base").getParam(1) - (textAscent() - textDescent()) * UI_Constants.GLOBAL_TEXT_ALIGN_FACTOR_Y;
    }

    

/*
======================================= Toggle Interaction =========================================
*/  
    @Override
    public boolean onMousePress() {
        if(this.Toggle_Scale != -1) {
            float x = (mouseX - this.Toggle_ParentWindow.getWindowPosition().x) / this.Toggle_Scale;
            float y = (mouseY - this.Toggle_ParentWindow.getWindowPosition().y) / this.Toggle_Scale;

            return this.Toggle_Shape_Group.getChild("Toggle_Shape_Base_Listener").contains(x, y);
        } else {
            float x = (mouseX - this.Toggle_ParentWindow.getWindowPosition().x);
            float y = (mouseY - this.Toggle_ParentWindow.getWindowPosition().y);

            return this.Toggle_Shape_Group.getChild("Toggle_Shape_Base_Listener").contains(x, y);
        }
    }

    @Override 
    public void onMouseRelease() {

    }

    @Override
    public void onMouseDrag() {
        
    }
    

    @Override
    public void onSelect() {
        this.Toggle_State = true;
        this.Toggle_Shape_Group.getChild("Toggle_Shape_Base").setStroke(this.Element_Base_Selected_Stroke_Color);
        this.Toggle_Shape_Group.getChild("Toggle_Shape_Base").setFill(this.Element_Base_Selected_Color);
        this.Toggle_Shape_Group.getChild("Toggle_Shape_TickMark").setVisible(true);

    }

    @Override
    public void onDeselect() {
        this.Toggle_State = false;
        this.Toggle_Shape_Group.getChild("Toggle_Shape_Base").setStroke(this.Element_Base_Unselected_Stroke_Color);
        this.Toggle_Shape_Group.getChild("Toggle_Shape_Base").setFill(this.Element_Base_Unselected_Color);
        this.Toggle_Shape_Group.getChild("Toggle_Shape_TickMark").setVisible(false);
    }

/*
===================================== Toggle Draw ==================================================
*/

    @Override
    public void drawText() {
        fill(this.Element_Text_Color);
        textFont(this.Element_Font);
        textSize(this.Element_Text_Size);
        textAlign(CENTER, CENTER);

        if(this.Toggle_Scale != -1) {
            pushMatrix();
            scale(this.Toggle_Scale);
            text(this.Toggle_Name, this.Toggle_Name_Position_X, this.Toggle_Name_Position_Y);
            popMatrix();
        } else {
            text(this.Toggle_Name, this.Toggle_Name_Position_X, this.Toggle_Name_Position_Y);
        }

    }


/*
======================================= Toggle Getters and Setters =================================
*/  
    @Override   
    public String getElementName() {
        return this.Toggle_Name;
    }
    @Override
    public String getGroupName() {
        return this.Toggle_GroupName;
    }

    @Override
    public PShape getShape() {
        return this.Toggle_Shape_Group;
    }

    @Override 
    public float getValue() {
        if(this.Toggle_State) {
            return 1;
        } else {
            return 0;
        }
    }

    @Override
    public void setValue(float value) {
        if(PhysEngMath.Equals(value, 1f)) {
            this.onSelect();
        } else {
            this.onDeselect();
        }
    }

    @Override
    public void incrementValue(float amount) {

    }

    @Override
    public boolean getState() {
        return this.Toggle_State;
    }

    @Override
    public void setState(boolean state) {
        if(state) {
            this.onSelect();
        } else {
            this.onDeselect();
        }
    }

}   
public class UI_Window {
    
    public final String Window_Name;
    public String HotBarSlotRepresentation;
    public PVector Window_Position = new PVector(500, 400);
    public final int Window_ID;

    public boolean Window_Visibility = true;
    public float Window_Scale = displayWidth / 1512;

    public PShape Window_Container;

    /*
    Visuals
    */
    public final PVector Window_Container_Size = new PVector(285, 407);
    public final PVector Window_Text_Container_Size = new PVector(285, 35);
    public final PVector Window_Form_Container_Size = new PVector(285, 407-35);
    public final PVector Window_Text_Position = new PVector();
    public float Window_Text_Width;
    public final int Window_Text_Size = 18;
    public final float Window_Rounding = 7;

    public boolean hasCloseButton = true;

    /*
    Elements
    */
    public ArrayList<UI_Element> Window_Elements = new ArrayList<UI_Element>();



    /*
    Interaction
    */
    public PVector initialMouseDragPosition = new PVector();
    

    public boolean isActiveWindow = false;
    public boolean isMouseOverWindow = false;
    public boolean isMouseOverWindowTextContainer = false;
    public boolean isMouseOverWindowFormContainer = false;

    public boolean isDragging = false;
    public boolean wasMousePressedOverWindow = false;
    /*
    For Testing
    */

    public UI_Window(String Window_Name, int Window_ID) {
        this.Window_Name = Window_Name;
        this.Window_ID = Window_ID;
        this.initializeWindow();
    }

     public UI_Window(String Window_Name, int Window_ID, PVector Window_Position) {
        this.Window_Name = Window_Name;
        this.Window_ID = Window_ID;
        this.Window_Position.set(Window_Position);
        this.initializeWindow();
    }


    public UI_Window(String Window_Name, int Window_ID, PVector Window_Container_Size, PVector Window_Text_Container_Size, PVector Window_Form_Container_Size, boolean hasCloseButton) {
        this.Window_Name = Window_Name;
        this.Window_ID = Window_ID;
        this.Window_Container_Size.set(Window_Container_Size);
        this.Window_Text_Container_Size.set(Window_Text_Container_Size);
        this.Window_Form_Container_Size.set(Window_Form_Container_Size);
        this.hasCloseButton = hasCloseButton;
        this.initializeWindow();
    }

    public UI_Window(String Window_Name, int Window_ID, PVector Window_Container_Size, PVector Window_Text_Container_Size, PVector Window_Form_Container_Size, PVector Window_Position, boolean hasCloseButton) {
        this.Window_Name = Window_Name;
        this.Window_ID = Window_ID;
        this.Window_Container_Size.set(Window_Container_Size);
        this.Window_Position.set(Window_Position);
        this.Window_Text_Container_Size.set(Window_Text_Container_Size);
        this.Window_Form_Container_Size.set(Window_Form_Container_Size);
        this.hasCloseButton = hasCloseButton;
        this.initializeWindow();
    }


/*
============================================= Initialization =======================================
*/
    public void initializeWindow() {
        textFont(UI_Constants.INTER_BOLD);
        textSize(this.Window_Text_Size);
        textAlign(CENTER, CENTER);
        rectMode(CENTER);
        this.Window_Container = createShape(GROUP);

        PShape Element_Group = createShape(GROUP);
            Element_Group.setName("Element_Group");

        PShape Window_Text_Container = createShape(RECT, 0, -this.Window_Form_Container_Size.y / 2 - this.Window_Text_Container_Size.y / 2 + 0.5f, 
                                                             this.Window_Text_Container_Size.x, 
                                                             this.Window_Text_Container_Size.y, 
                                                             this.Window_Rounding, 
                                                             this.Window_Rounding, 
                                                             0, 0);
            Window_Text_Container.setName("Window_Text_Container");
            Window_Text_Container.setStroke(false);
            Window_Text_Container.setFill(UI_Constants.GRAY_500);

        PShape Window_Form_Container = createShape(RECT, 0, 0, this.Window_Form_Container_Size.x,
                                                               this.Window_Form_Container_Size.y, 
                                                               0, 0, 
                                                               this.Window_Rounding,
                                                               this.Window_Rounding);
            Window_Form_Container.setName("Window_Form_Container");
            Window_Form_Container.setStroke(false);
            Window_Form_Container.setFill(UI_Constants.GRAY_600);
        
        PShape Window_Container_Stroke = createShape(RECT, 0, -this.Window_Text_Container_Size.y / 2, this.Window_Container_Size.x, this.Window_Container_Size.y, this.Window_Rounding);
            Window_Container_Stroke.setName("Window_Container_Stroke");
            Window_Container_Stroke.setStroke(UI_Constants.GRAY_400);
            Window_Container_Stroke.setStrokeWeight(2);
            Window_Container_Stroke.setFill(false);
        
        PShape Window_Container_TickMark = createShape(GROUP);
            Window_Container_TickMark.setName("Window_Container_TickMark");

            PShape TickMark_LineOne = createShape();
                TickMark_LineOne.beginShape();
                    TickMark_LineOne.vertex(this.Window_Text_Container_Size.x / 2 - 17, Window_Text_Container.getParam(1) - 6);
                    TickMark_LineOne.vertex(this.Window_Text_Container_Size.x / 2 - 29, Window_Text_Container.getParam(1) + 6);
                TickMark_LineOne.endShape();
                TickMark_LineOne.setFill(false);
                TickMark_LineOne.setStrokeWeight(2);
                TickMark_LineOne.setStroke(UI_Constants.GRAY_25);

            PShape TickMark_LineTwo = createShape();
                TickMark_LineTwo.beginShape();
                    TickMark_LineTwo.vertex(this.Window_Text_Container_Size.x / 2 - 29, Window_Text_Container.getParam(1) - 6);
                    TickMark_LineTwo.vertex(this.Window_Text_Container_Size.x / 2 - 17, Window_Text_Container.getParam(1) + 6);
                TickMark_LineTwo.endShape();
                TickMark_LineTwo.setFill(false);
                TickMark_LineTwo.setStrokeWeight(2);
                TickMark_LineTwo.setStroke(UI_Constants.GRAY_25);
            
            Window_Container_TickMark.addChild(TickMark_LineOne);
            Window_Container_TickMark.addChild(TickMark_LineTwo);

            PShape Window_Container_TickMark_Listener = createShape();
                Window_Container_TickMark_Listener.beginShape();
                    Window_Container_TickMark_Listener.vertex(this.Window_Text_Container_Size.x / 2 - 29, Window_Text_Container.getParam(1) - 6);
                    Window_Container_TickMark_Listener.vertex(this.Window_Text_Container_Size.x / 2 - 17, Window_Text_Container.getParam(1) - 6);
                    Window_Container_TickMark_Listener.vertex(this.Window_Text_Container_Size.x / 2 - 17, Window_Text_Container.getParam(1) + 6);
                    Window_Container_TickMark_Listener.vertex(this.Window_Text_Container_Size.x / 2 - 29, Window_Text_Container.getParam(1) + 6);
                Window_Container_TickMark_Listener.endShape(CLOSE);
                Window_Container_TickMark_Listener.setName("Window_Container_TickMark_Listener");
                Window_Container_TickMark_Listener.setFill(false);
                Window_Container_TickMark_Listener.setStroke(false);   

        PShape Window_Container_Listener = UI_Constants.createElementListener(Window_Container_Stroke);
                Window_Container_Listener.setName("Window_Container_Listener");
        PShape Window_Form_Container_Listener = UI_Constants.createElementListener(Window_Form_Container);
                Window_Form_Container_Listener.setName("Window_Form_Container_Listener");
        PShape Window_Text_Container_Listener = UI_Constants.createElementListener(Window_Text_Container);
                Window_Text_Container_Listener.setName("Window_Text_Container_Listener");
            
        this.Window_Container.addChild(Window_Form_Container);
        this.Window_Container.addChild(Window_Text_Container);
        this.Window_Container.addChild(Window_Container_Stroke);
        
        if(this.hasCloseButton) {
             this.Window_Container.addChild(Window_Container_TickMark);
        }

        this.Window_Container.addChild(Window_Container_Listener);
        this.Window_Container.addChild(Window_Form_Container_Listener);
        this.Window_Container.addChild(Window_Text_Container_Listener);

        if(this.hasCloseButton) {
            this.Window_Container.addChild(Window_Container_TickMark_Listener);
        }

        this.Window_Container.addChild(Element_Group);

        this.Window_Container.resetMatrix();
        this.Window_Container.translate(this.Window_Position.x, this.Window_Position.y);
        this.Window_Container.scale(this.Window_Scale);


        this.Window_Text_Width = textWidth(this.Window_Name);

        textFont(UI_Constants.INTER_BOLD);
        textSize(this.Window_Text_Size);
        this.Window_Text_Position.set(-this.Window_Text_Container_Size.x / 2 + textWidth(this.Window_Name) / 2 + 15, -(this.Window_Form_Container_Size.y + this.Window_Text_Container_Size.y) / 2 - (textAscent() - textDescent()) * UI_Constants.GLOBAL_TEXT_ALIGN_FACTOR_Y);

    }

/*
============================================= Draw =================================================
*/  


    public void draw() {
        if(!this.Window_Visibility) {
            return;
        }
        shape(this.Window_Container, 0, 0);
        pushMatrix();
        translate(this.Window_Position.x, this.Window_Position.y);
        scale(this.Window_Scale);
            this.drawText();
            this.drawElementText();
        popMatrix();
        this.updateIsMouseOverWindow();
    }



    public void drawElementText() {
        for(UI_Element element : this.Window_Elements) {
            element.drawText();
        }
    }

    public void drawText() {
        if(this.isActiveWindow) {
            fill(UI_Constants.WHITE);
        } else {
            fill(UI_Constants.GRAY_25);
        }
        textFont(UI_Constants.INTER_BOLD);
        textSize(this.Window_Text_Size);
        textAlign(CENTER, CENTER);
        text(this.Window_Name, this.Window_Text_Position.x, this.Window_Text_Position.y);
    }


/*
============================================= Interaction ==========================================
*/
    public void onMouseRelease() {
        if(!this.Window_Visibility) {
            return;
        }

        if(this.wasMousePressedOverWindow) {
            Mouse.getMouseObjectResults().clear();
        }

        this.onElementMouseRelease();
        this.isDragging = false;
        this.wasMousePressedOverWindow = false;
    }

    public void interactionMouseRelease() {

    }


    public boolean onMouseDrag() {
        if(!this.Window_Visibility) {
            return false;
        }

        if(mousePressed && this.isMouseOverWindowFormContainer) {
            this.onElementMouseDrag();
            return true;
        }
        
        if (mousePressed && this.isMouseOverWindowTextContainer && this.wasMousePressedOverWindow) {
            if (!this.isDragging) {
                this.initialMouseDragPosition.set(mouseX, mouseY);
                this.isDragging = true;
            } else {
                PVector mouseDragDifference = PVector.sub(new PVector(mouseX, mouseY), this.initialMouseDragPosition);
                this.Window_Position.add(mouseDragDifference);
                this.Window_Container.resetMatrix();
                this.Window_Container.translate(this.Window_Position.x, this.Window_Position.y);
                this.initialMouseDragPosition.set(mouseX, mouseY);
            }
            return true;
        } else {
            this.isDragging = false;
            return false;
        }
    }

    public void interactionMouseDrag() {

    }

    public boolean onMousePress() {
        if(!this.Window_Visibility) {
            return false;
        }

        if(mouseButton == LEFT) {
            if(this.isMouseOverWindow) {
                this.wasMousePressedOverWindow = true;
                this.checkWindowClose();

                if(!this.Window_Visibility) {
                    return true;
                }

                this.onWindowSelectHotbarCaller();
                this.onElementMousePress();
                return true;
            } else {
                this.wasMousePressedOverWindow = false;
                this.onWindowDeselect();
                return false;
            }
        } else {
            return false;
        }
    }

    public void interactionMousePress() {

    }


    public void onElementMousePress() {
        ArrayList<UI_Element> copyList = new ArrayList<UI_Element>(this.Window_Elements);
        for(UI_Element element : copyList) {
            if(!element.onMousePress()) {
                continue;
            }
            if(element instanceof UI_Toggle) {
                this.handleToggleElement((UI_Toggle)element);
            } else if(element instanceof UI_Slider) {
                element.onSelect();
            } else if(element instanceof UI_FileButton) {
                this.handleFileButtonElement((UI_FileButton)element);
            } else if(element instanceof UI_TickSlider) {
                element.onSelect();
            } 
        }
    }

    private void handleToggleElement(UI_Toggle toggleElement) {
        if(toggleElement.getState()) {
            toggleElement.onDeselect();
        } else {
            deselectGroupElements(toggleElement.getGroupName(), toggleElement);
            toggleElement.onSelect();
        }
    }

    private void handleFileButtonElement(UI_FileButton fileButtonElement) {
        if(fileButtonElement.getState()) {
            fileButtonElement.onDeselect();
        } else {
            deselectGroupElements(fileButtonElement.getGroupName(), fileButtonElement);
            fileButtonElement.onSelect();
        }
    }

    private void deselectGroupElements(String groupName, UI_Element selectedElement) {
        if(groupName == null) {
            return;
        }

        for(UI_Element element : this.Window_Elements) {
            if(element != selectedElement && groupName.equals(element.getGroupName())) {
                element.onDeselect();
            }
        }
    }
    public void onElementMouseDrag() {
        for(UI_Element element : this.Window_Elements) {
            element.onMouseDrag();
        }
    }

    public void onElementMouseRelease() {
        ArrayList<UI_Element> copyList = new ArrayList<UI_Element>(this.Window_Elements);
        for(UI_Element element : copyList) {
            element.onMouseRelease();
        }
    }

    public void onWindowSelect() {
        this.deselectAllWindows();
        this.isActiveWindow = true;
        UI_Manager.bringToFront(this);
        this.Window_Container.getChild("Window_Container_Stroke").setStroke(UI_Constants.BLUE_SELECTED);
        this.Window_Container.getChild("Window_Text_Container").setFill(UI_Constants.BLUE_UNSELECTED);
    }


    public void onWindowSelectHotbarCaller() {
        this.deselectAllWindows();
        this.isActiveWindow = true;
        UI_Manager.bringToFront(this);
        this.Window_Container.getChild("Window_Container_Stroke").setStroke(UI_Constants.BLUE_SELECTED);
        this.Window_Container.getChild("Window_Text_Container").setFill(UI_Constants.BLUE_UNSELECTED);
        
        if(this.HotBarSlotRepresentation != null) {
            switch(this.HotBarSlotRepresentation) {
                case "Editor":
                    UI_Manager.HOT_BAR.onSlotChange(1);
                    this.onWindowSelect();
                    break;
                case "Circle":
                    UI_Manager.HOT_BAR.onSlotChange(2);
                    this.onWindowSelect();
                    break;
                case "Rectangle":
                    UI_Manager.HOT_BAR.onSlotChange(3);
                    this.onWindowSelect();
                    break;
                case "Spring":
                    UI_Manager.HOT_BAR.onSlotChange(4);
                    this.onWindowSelect();
                    break;
                case "Rod":
                    UI_Manager.HOT_BAR.onSlotChange(5);
                    this.onWindowSelect();
                    break;
                case "Motor":
                    UI_Manager.HOT_BAR.onSlotChange(6);
                    this.onWindowSelect();
                    break;
            }
        }

    }

    public void onWindowDeselect() {
        int activeSlotID = UI_Manager.getHotBar().getActiveSlotID();
        if(this instanceof UI_PropertiesForceWindow) {
            if(activeSlotID == 4 || activeSlotID == 5 || activeSlotID == 6) {
                return;
            }
        } else if(this instanceof UI_PropertiesRigidbodyWindow) {
            if(activeSlotID == 2 || activeSlotID == 3) {
                return;
            }
        }
        this.isActiveWindow = false;
        this.Window_Container.getChild("Window_Container_Stroke").setStroke(UI_Constants.GRAY_400);
        this.Window_Container.getChild("Window_Text_Container").setFill(UI_Constants.GRAY_500);
    }

    public void onWindowClose() {
        this.Window_Visibility = false;
        this.isMouseOverWindow = false;
        this.isMouseOverWindowTextContainer = false;
        this.isMouseOverWindowFormContainer = false;
        this.wasMousePressedOverWindow = false;
        this.isActiveWindow = false;
    }

    public void updateIsMouseOverWindow() {

        if(!this.Window_Visibility) {
            return;
        }

        float x = mouseX - this.Window_Position.x;
        float y = mouseY - this.Window_Position.y;

        if(this.Window_Container.getChild("Window_Container_Listener").contains(x, y)) {
            if(this.Window_Container.getChild("Window_Text_Container_Listener").contains(x, y)) {
                this.isMouseOverWindowTextContainer = true;
                this.isMouseOverWindowFormContainer = false;
            } else {
                this.isMouseOverWindowTextContainer = false;
                this.isMouseOverWindowFormContainer = true;
            }
            this.isMouseOverWindow = true;
        } else {
            this.isMouseOverWindow = false;
            this.isMouseOverWindowTextContainer = false;
            this.isMouseOverWindowFormContainer = false;
        }
    }

    public void deselectAllWindows() {
        for (int i = 0; i < UI_Manager.WINDOWS.size(); i++) {
            UI_Manager.WINDOWS.get(i).onWindowDeselect();
        }
    }

    public void checkWindowClose() {
        if(this.hasCloseButton) {
            if(this.Window_Container.getChild("Window_Container_TickMark_Listener").contains(mouseX - this.Window_Position.x, mouseY - this.Window_Position.y)) {
                this.onWindowClose();
            }  
        }
    }


/*
============================================= Methods ==============================================
*/

    public void addElement(UI_Element element) {
        this.Window_Elements.add(element);
        if(element.getShape() != null) {
            this.Window_Container.getChild("Element_Group").addChild(element.getShape());
        }
    }

    public void clearAllElements() {
        this.Window_Container.removeChild(this.Window_Container.getChildIndex(this.Window_Container.getChild("Element_Group")));
        this.Window_Elements.clear();

        PShape Element_Group = createShape(GROUP);
            Element_Group.setName("Element_Group");

        this.Window_Container.addChild(Element_Group);
        // for(UI_Element element : this.Window_Elements) {
        //     if(element.getShape() == null) {
        //         continue;
        //     }
        //     this.Window_Container.getChild("Element_Group").removeChild(this.Window_Container.getChild("Element_Group").getChildIndex(element.getShape()));
        // }
        // this.Window_Elements.clear();
    }

    public void onKeyPress(int keyCode) {

    }

/*
======================================== Getters & Setters =========================================
*/

    public float getWindowContainerWidth() {
        return this.Window_Container_Size.x;
    }
    public float getWindowContainerHeight() {
        return this.Window_Container_Size.y;
    }
    public PVector getWindowContainerDimensions() {
        return this.Window_Container_Size;
    }
    public float getWindowTextContainerWidth() {
        return this.Window_Text_Container_Size.x;
    }
    public float getWindowTextContainerHeight() {
        return this.Window_Text_Container_Size.y;
    }
    public PVector getWindowTextContainerDimensions() {
        return this.Window_Text_Container_Size;
    }
    public float getWindowFormContainerWidth() {
        return this.Window_Form_Container_Size.x;
    }
    public float getWindowFormContainerHeight() {
        return this.Window_Form_Container_Size.y;
    }
    public PVector getWindowFormContainerDimensions() {
        return this.Window_Form_Container_Size;
    }
    public float getWindowContainerCenterPositionX () {
        return this.Window_Position.x;
    }
    public float getWindowContainerCenterPositionY() {
        return this.Window_Position.y;
    }
    public float getWindowPositionX() {
        return this.Window_Position.x;
    }
    public float getWindowPositionY() {
        return this.Window_Position.y;
    }
    public PVector getWindowPosition() {
        return this.Window_Position;
    }

    public UI_Element getElement(int index) {
        return this.Window_Elements.get(index);
    }

    public int getWindowElementArrayListSize() {
        return this.Window_Elements.size();
    }

    public ArrayList<UI_Element> getWindowElements() {
        return this.Window_Elements;
    }
    
    public int getWindowID() {
        return this.Window_ID;
    }

    public UI_Element getElementByName(String elementName) {
        for(UI_Element element : this.Window_Elements) {
            if(element.getElementName().equals(elementName)) {
                return element;
            }
        }
        throw new IllegalArgumentException("Element with name " + elementName + " does not exist in window " + this.Window_Name);
    }

    public UI_Element getElementByNameNullReturn(String elementName) {
        for(UI_Element element : this.Window_Elements) {
            if(element.getElementName().equals(elementName)) {
                return element;
            }
        }
       return null;
    }

    public String getWindowName() {
        return this.Window_Name;
    }

    public void setWindowPosition(PVector position) {
        this.Window_Position.set(position);
        this.Window_Container.resetMatrix();
        this.Window_Container.translate(this.Window_Position.x, this.Window_Position.y);
        this.Window_Container.scale(this.Window_Scale);
    }

    public void setWindowPositionX(float posX) {
        this.Window_Position.set(new PVector(posX, this.Window_Position.y));
        this.Window_Container.resetMatrix();
        this.Window_Container.translate(this.Window_Position.x, this.Window_Position.y);
        this.Window_Container.scale(this.Window_Scale);
    }

    public void setWindowVisibility(boolean Window_Visibility) {
        this.Window_Visibility = Window_Visibility;
    }




    public void interactionDraw() {

    }

    public void interactionMouseClick() {

    }

    public void onSlotChange(int previousSlotID) {
        
    }

}


  static public void main(String[] passedArgs) {
    String[] appletArgs = new String[] { "PhysicsEngine" };
    if (passedArgs != null) {
      PApplet.main(concat(appletArgs, passedArgs));
    } else {
      PApplet.main(appletArgs);
    }
  }
}
