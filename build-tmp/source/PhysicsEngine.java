/* autogenerated by Processing revision 1293 on 2024-01-22 */
import processing.core.*;
import processing.data.*;
import processing.event.*;
import processing.opengl.*;

import java.util.*;
import java.util.concurrent.*;
import java.util.Stack;
import java.math.*;
import java.lang.Enum;
import controlP5.*;

import java.util.HashMap;
import java.util.ArrayList;
import java.io.File;
import java.io.BufferedReader;
import java.io.PrintWriter;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.IOException;

public class PhysicsEngine extends PApplet {



GUI gui;
PShape background;
Softbody softbody;
Cloth cloth;


public void setup() {
/*--------------------- Timing Utilities ---------------------*/
    lastFrameTime = millis();
/*------------------------------------------------------------*/


/*--------------------- Camera Utilities ---------------------*/
    /* size commented out by preprocessor */;
    
    windowMove(10, 4);
    frameRate(240);
    interactivityListener = new InteractivityListener();
    
/*------------------------------------------------------------*/

/*---------------------------- UI ----------------------------*/
  userInterface = new ControlP5(this);
  gui = new GUI(userInterface);
/*------------------------------------------------------------*/

/*------------------- Background ---------------------------*/
    //background = loadShape("background.svg");
/*-------------------------- Rigidbodies ------------------------*/
  rigidbodyList = new ArrayList<Rigidbody>();
/*------------------------------------------------------------*/


    Rigidbody springBody = RigidbodyGenerator.CreateBoxBody(4f, 1f, 1f, 0.5f, false, true,
                                                          0.05f, new PVector(0, 0, 0),
                                                           new PVector(255, 255, 255));
    Rigidbody test = RigidbodyGenerator.CreateCircleBody(1f, 1f, 0.5f, false, true,
                                                            0.05f, new PVector(0, 0, 0),
                                                            new PVector(255, 255, 255));

    Rigidbody spinningBody = RigidbodyGenerator.CreateCircleBody(2f, 1f, 0.5f, false, true,
                                                            0.05f, new PVector(0, 0, 0),
                                                            new PVector(255, 255, 255));
    
    spinningBody.SetInitialPosition(new PVector(0, -5));
    Motor motor = new Motor(spinningBody, 0.5f);

    //spinningBody.addForceToForceRegistry(motor);
    spinningBody.setIsTranslationallyStatic(true);

    test.SetInitialPosition(new PVector(-10, -5.1f));

    springBody.SetInitialPosition(new PVector(-10, -5));
    springBody.setIsRotationallyStatic(false);

    Spring springLeft = new Spring(springBody, new PVector(2,0), new PVector(-8, -10));
    Spring springRight = new Spring(springBody, new PVector(-2,0), new PVector(-12, -10));
    //Rod connectingRod = new Rod(test, spinningBody, new PVector(0,0), new PVector(2f,0));

    springLeft.setSpringLength(10);
    springLeft.setEquilibriumLength(0.5f);
    springLeft.setSpringConstant(100);
    springLeft.setLockTranslationToYAxis(true);



    springRight.setSpringLength(10);
    springRight.setSpringConstant(100);
    springRight.setEquilibriumLength(0.5f);
    springRight.setLockTranslationToYAxis(true);
    

    
    springBody.addForceToForceRegistry(springLeft);
    springBody.addForceToForceRegistry(springRight);

    //test.addForceToForceRegistry(connectingRod);

    test.addForceToForceRegistry(new Gravity(test));
    springBody.addForceToForceRegistry(new Gravity(springBody));


    AddBodyToBodyEntityList(springBody);
    AddBodyToBodyEntityList(test);
    AddBodyToBodyEntityList(spinningBody);


    //softbody = new Softbody(new PVector(-50, -50), 0.0f, 2, 2);
    //softbody.CreateBoxSoftbody();
    //softbody = new Softbody(new PVector(-20, -50), 0.0f, 2, 2);
    //softbody.CreateBoxSoftbody();

    //cloth = new Cloth(new PVector(-50,-50), new PVector(-20, -50), 30);
    //cloth.CreateCloth();

}


public void draw() {
  int currentFrameTime = millis();

  /*NEVER DELETE THIS */
  gui.getActiveTab();
  /* PLEASE */

  interactivityListener.applyTransform();
  pushMatrix();
  translate(-1920/12.5f, -1080/12.5f);
  scale(0.05f);
  //shape(background, 0, 0);
  popMatrix();
  render.draw();
  
  for(Softbody softbody : softbodyList) {
    softbody.draw();
  }
  //cloth.updateCloth();

  /*--------------------- Cursor Trail ---------------------*/

  if(IsMouseOverUI()) {
    interactivityListener.setDrawCursorTrail(false);
    cursor();
} else {
    interactivityListener.setDrawCursorTrail(true);
    interactivityListener.drawInteractions();
    noCursor();
  }

  dt = (currentFrameTime - lastFrameTime) / 1000f;
  Step(dt, 128);

  interactivityListener.resetTransform();

  displayTimings();

  lastFrameTime = currentFrameTime;


}



public class AABB {

  private final PVector Min;
  private final PVector Max;

/*
====================================================================================================
========================================== Constructors ============================================
====================================================================================================
*/

public AABB(PVector min, PVector max) {
    this.Min = min;
    this.Max = max;
}


/*-------------------------------------Overloaded Constructor-------------------------------------*/
public AABB(float minX, float minY, float maxX, float maxY) {
    this.Min = new PVector(minX, maxY);
    this.Max = new PVector(maxX, maxY);
}


/*
====================================================================================================
==============================================GETTERS & SETTERS=====================================
====================================================================================================
*/
  public PVector getMin() {
    return Min;
  }

  public PVector getMax() {
    return Max;
  }

}
public class Cloth {

    private PVector initialLeftCornerPosition;
    private PVector initialRightCornerPosition;

    private float clothWidth;
    private float clothHeight;

    private float stiffness = 300f;
    private float damping = 1f;

    private int numRowParticles;
    private int numColumnParticles;
    private int spacing = 2;
    private float particleRadius = 0.5f;

    private Rigidbody[][] clothBodyParticles;

    public Cloth(PVector initialLeftCornerPosition, PVector initialRightCornerPosition, float length) {

        this.initialLeftCornerPosition = initialLeftCornerPosition;
        this.initialRightCornerPosition = initialRightCornerPosition;
        this.clothWidth = (int)round(PVector.sub(initialLeftCornerPosition, initialRightCornerPosition).mag() / 5.0f) * 5;
        this.clothHeight = (int)round(length / spacing) * spacing;

        this.numRowParticles = (int)clothWidth/spacing;
        this.numColumnParticles = (int)clothHeight/spacing;
        clothBodyParticles = new Rigidbody[numRowParticles][numColumnParticles];
    }


    public void CreateCloth() {
        float initialParticlePositionX = this.initialLeftCornerPosition.x;
        float initialParticlePositionY = this.initialLeftCornerPosition.y;

        for(int row = 0; row < numRowParticles; row++) {
            for(int column = 0; column < numColumnParticles; column++) {

                PVector currentParticlePosition = new PVector(initialParticlePositionX + row*spacing, initialParticlePositionY + column*spacing);

                Rigidbody currentParticle = RigidbodyGenerator.CreateCircleBody(particleRadius, 0.5f, 0.02f, false, true, 0.1f, new PVector(0,0,0), new PVector(255,255,255));
                currentParticle.setPosition(currentParticlePosition);
                currentParticle.previousPosition = currentParticlePosition.copy();

                clothBodyParticles[row][column] = currentParticle;

                currentParticle.addForceToForceRegistry(new Gravity(currentParticle));
                currentParticle.setIsVisible(false);
                AddBodyToBodyEntityList(currentParticle);
            }
        }

        clothBodyParticles[0][0].setIsVisible(true);
        clothBodyParticles[numRowParticles - 1][0].setIsVisible(true);

        clothBodyParticles[0][0].setIsStatic(true);
        clothBodyParticles[numRowParticles - 1][0].setIsStatic(true);


        for(int row = 0; row < numRowParticles; row++) {
            for(int column = 0; column < numColumnParticles; column++) {
            
                Rigidbody currentParticle = clothBodyParticles[row][column];

                // Link to particle below if it exists
                if(row < numRowParticles - 1) {
                    Rigidbody particleToLinkTo = clothBodyParticles[row+1][column];
                    addSpringBetweenParticles(currentParticle, particleToLinkTo);
                }

                // Link to particle to the right if it exists
                if(column < numColumnParticles - 1) {
                    Rigidbody particleToLinkTo = clothBodyParticles[row][column+1];
                    addSpringBetweenParticles(currentParticle, particleToLinkTo);
                }

                if (row == 0 || row == numRowParticles - 1 || column == 0 || column == numColumnParticles - 1) {
                    // If the particle is on the edge, set its collidability to true
                    currentParticle.setCollidability(true);
                } else {
                    // If the particle is not on the edge, set its collidability to false
                    currentParticle.setCollidability(false);
                }
                
            }
        }
    }

    private void addSpringBetweenParticles(Rigidbody particleA, Rigidbody particleB) {
        Spring spring = new Spring(particleA, particleB, new PVector(), new PVector());
        spring.setSpringLength(PVector.dist(particleA.getPosition(), particleB.getPosition()));
        spring.setSpringConstant(this.stiffness);
        spring.setDamping(this.damping);
        spring.drawSpring = false;

        particleA.addForceToForceRegistry(spring);
        particleB.addForceToForceRegistry(spring);
    }

    public void updateCloth() {
      draw();
    }




    public void draw() {
beginShape(LINES);
for (int row = 0; row < numRowParticles; row++) {
    for (int column = 0; column < numColumnParticles - 1; column++) {
        PVector pos = clothBodyParticles[row][column].getPosition();
        PVector rightPos = clothBodyParticles[row][column + 1].getPosition();
        vertex(pos.x, pos.y);
        vertex(rightPos.x, rightPos.y);
    }
}
endShape();

// Draw vertical lines
beginShape(LINES);
for (int column = 0; column < numColumnParticles; column++) {
    for (int row = 0; row < numRowParticles - 1; row++) {
        PVector pos = clothBodyParticles[row][column].getPosition();
        PVector bottomPos = clothBodyParticles[row + 1][column].getPosition();
        vertex(pos.x, pos.y);
        vertex(bottomPos.x, bottomPos.y);
    }
}
endShape();


    }


}

public class CollisionManifold {

    private final Rigidbody RigidbodyA;
    private final Rigidbody RigidbodyB;
    private final PVector Normal;
    private final float Depth;

    private final PVector[] PointsOfContact;
    private final int ContactCount;

    public CollisionManifold(Rigidbody rigidbodyA, Rigidbody rigidbodyB,
                             CollisionResult collisionResult) {

        this.RigidbodyA = rigidbodyA;
        this.RigidbodyB = rigidbodyB;
        this.Normal = collisionResult.getNormal();
        this.Depth = collisionResult.getDepth();
        this.PointsOfContact = collisionResult.getPointsOfContact();
        this.ContactCount = collisionResult.getContactCount();
    }
    

    public Rigidbody getRigidbodyA() {
        return RigidbodyA;
    }

    public Rigidbody getRigidbodyB() {
        return RigidbodyB;
    }

    public PVector getNormal() {
        return Normal;
    }

    public float getDepth() {
        return Depth;
    }

    public PVector[] getPointsOfContact() {
        return PointsOfContact;
    }

    public int getContactCount() {
        return ContactCount;
    }


}
public class CollisionResult {
 
  private boolean isColliding;
  private PVector normal = new PVector();
  private float depth;

  private float distanceSquared;

  private PVector[] pointsOfContact;

  private int contactCount;

  


/*
====================================================================================================
================================ PointSegmentDistance Constructor ==================================
====================================================================================================
*/

//Default constructor for no collision
  public CollisionResult(){

    this.isColliding = false;
    this.normal.set(0,0,0);
    this.depth = 0f;
    this.pointsOfContact = null;
    this.contactCount = 0;
  }


  public CollisionResult(float distanceSquared, PVector pointOfContact) {


    this.distanceSquared = distanceSquared;

    this.pointsOfContact = new PVector[] {pointOfContact};
  }



  public CollisionResult(PVector[] pointsOfContact) {
    this.isColliding = true;

    this.pointsOfContact = pointsOfContact;
    this.contactCount = pointsOfContact.length;
  }

  public CollisionResult(boolean isColliding, PVector normal, float depth, PVector[] pointsOfContact) {
    this.isColliding = isColliding;
    this.normal = normal;
    this.depth = depth;

    this.pointsOfContact = pointsOfContact;
    this.contactCount = pointsOfContact.length;
  }

  
  public CollisionResult(boolean isColliding, PVector normal, float depth) {
    this.isColliding = isColliding;
    this.normal = normal;
    this.depth = depth;
    this.pointsOfContact = null;
    this.contactCount = 0;
  }
 
  /*
  =====================================================================================================
  =========================================== Getters/Setters =========================================
  =====================================================================================================
  */

  public boolean getIsColliding() {
    return isColliding;
  }
  
  public PVector getNormal() {
    return normal;
  }

  public float getDepth() {
    return depth;
  }

  public PVector[] getPointsOfContact() {
    return pointsOfContact;
  }

  public int getContactCount() {
    return contactCount;
  }
  
  public float getDistanceSquared() {
    return distanceSquared;
  }


  public void setIsColliding(boolean isColliding) {
    this.isColliding = isColliding;
  }

  public void setNormal(PVector normal) {
    this.normal = normal;
  }

  public void setDepth(float depth) {
    this.depth = depth;
  }
  public void setDistanceSquared(float distanceSquared) {
    this.distanceSquared = distanceSquared;
  }

  //Overloaded Methods
  public void setPointsOfContact(PVector[] pointsOfContact) {
    this.pointsOfContact = pointsOfContact;
  }
  
  public void setPointsOfContact(PVector pointOfContact) {
    this.pointsOfContact = new PVector[] {pointOfContact};
  }

  public void setPointsOfContact(PVector pointOfContactA, PVector pointOfContactB) {
    this.pointsOfContact = new PVector[] {pointOfContactA, pointOfContactB};
  }

  public void setContactCount(int contactCount) {
    this.contactCount = contactCount;
  }

}
public static class Collisions {
  CollisionResult collisionResult;

  //This is required as there is no enclosing instance of physics class for collisionResult
  public static PhysicsEngine physicsEngine = new PhysicsEngine();




  /*------------------- Reusable  ------------------- */
  public static PVector ZeroNormal = new PVector();
/*
====================================================================================================
===================================== COLLIDE INFO =================================================
====================================================================================================
*/

/*optimizied*/
public static CollisionResult Collide(Rigidbody rigidbodyA, Rigidbody rigidbodyB) {

    ShapeType shapeTypeA = rigidbodyA.getShapeType();
    ShapeType shapeTypeB = rigidbodyB.getShapeType();

    if(shapeTypeA == ShapeType.BOX) {

      if(shapeTypeB == ShapeType.BOX) {

        return IntersectPolygon(rigidbodyA.getPosition(),
                                           rigidbodyA.GetTransformedVertices(),
                                           rigidbodyB.getPosition(),
                                           rigidbodyB.GetTransformedVertices());

      } else if(shapeTypeB == ShapeType.CIRCLE) {
        CollisionResult result = Collisions.IntersectCirclePolygon(rigidbodyB.getPosition(),
                                                                   rigidbodyB.getRadius(),
                                                                   rigidbodyA.getPosition(),
                                                                   rigidbodyA.GetTransformedVertices()
                                                                   );
        result.setNormal(result.getNormal().mult(-1));
        return result;

      }

    }
  if (shapeTypeA == ShapeType.CIRCLE) {
        
        if(shapeTypeB == ShapeType.BOX) {

          return IntersectCirclePolygon(rigidbodyA.getPosition(), 
                                                   rigidbodyA.getRadius(), 
                                                   rigidbodyB.getPosition(), 
                                                   rigidbodyB.GetTransformedVertices());

        } else if(shapeTypeB == ShapeType.CIRCLE) {

          return IntersectCircle(rigidbodyA.getPosition(), rigidbodyB.getPosition(), rigidbodyA.getRadius(), rigidbodyB.getRadius());

        }
      }

    return physicsEngine.new CollisionResult();
  }


/*
====================================================================================================
===================================== CONTACT-POINTS COLLISIONS ====================================
======================================= COLLISION-RESULT ===========================================
*/

/*optimized*/

public static void FindCollisionPoints(Rigidbody rigidbodyA, Rigidbody rigidbodyB,
                                                  CollisionResult collisionResult) {
    int contactCount = 0;

    ShapeType shapeTypeA = rigidbodyA.getShapeType();
    ShapeType shapeTypeB = rigidbodyB.getShapeType();

    if(shapeTypeA == ShapeType.BOX) {

      if(shapeTypeB == ShapeType.BOX) {
        PVector[] pointsOfContact = FindPolygonsCollisionPoints(rigidbodyA.GetTransformedVertices(),
                                                                rigidbodyB.GetTransformedVertices());
        collisionResult.setPointsOfContact(pointsOfContact);
        collisionResult.setContactCount(pointsOfContact.length);
        return;

      } else if(shapeTypeB == ShapeType.CIRCLE) {
        PVector[] pointsOfContact = FindCirclePolygonCollisionPoint(rigidbodyB.getPosition(),
                                                                    rigidbodyB.getRadius(),
                                                                    rigidbodyA.getPosition(),
                                                                    rigidbodyA.GetTransformedVertices());
        collisionResult.setPointsOfContact(pointsOfContact);
        collisionResult.setContactCount(1);
        return;
      }

    }
  if (shapeTypeA == ShapeType.CIRCLE) {
        
        if(shapeTypeB == ShapeType.BOX) {
          PVector[] pointsOfContact = FindCirclePolygonCollisionPoint(rigidbodyA.getPosition(),
                                                                      rigidbodyA.getRadius(),
                                                                      rigidbodyB.getPosition(),
                                                                      rigidbodyB.GetTransformedVertices());
          collisionResult.setPointsOfContact(pointsOfContact);
          collisionResult.setContactCount(1);
          return;

        } else if(shapeTypeB == ShapeType.CIRCLE) {
           PVector[] pointsOfContact = FindCirclesCollisionPoint(rigidbodyA.getPosition(),
                                                                 rigidbodyA.getRadius(),
                                                                 rigidbodyB.getPosition(),
                                                                 rigidbodyB.getRadius());
            collisionResult.setPointsOfContact(pointsOfContact);
            collisionResult.setContactCount(1);
            return;
        }
      }

    /*
    For displaying the points of contact
        for(PVector point : pointsOfContact) {
             //pointsOfContactList.add(point);
        }
   */

}
/*
====================================================================================================
============================== CIRCLE-CIRCLE COLLISION CONTACT POINT ===============================
======================================= COLLISION-RESULT ===========================================
====================================================================================================
*/
 private static PVector[] FindCirclesCollisionPoint(PVector centerA, float radiusA,
                                                         PVector centerB, float radiusB) {
    
    /*
    PVector direction = PVector.sub(centerB, centerA).normalize();
    PVector collisionPoint = PVector.add(centerA, PVector.mult(direction, radiusA));
    return new PVector[] {collisionPoint};
    */


    return new PVector[] {PVector.add(centerA, PVector.sub(centerB, centerA).normalize().mult(radiusA))};
    }
/*
====================================================================================================
=============================POLYGON-POLYGON COLLISION CONTACT POINT ===============================
======================================= COLLISION-RESULT ===========================================
====================================================================================================
*/

/*
private static PVector[] FindPolygonsCollisionPoints(PVector[] transformedVerticesA,
                                                           PVector[] transformedVerticesB) {
  PVector contactPointA = new PVector();
  PVector contactPointB = new PVector();
  int contactCount = 0;

  float minDistanceSquared = Float.MAX_VALUE;

  for(int i = 0; i < transformedVerticesA.length; i++) {

      PVector point = transformedVerticesA[i];

      for(int j = 0; j < transformedVerticesB.length; j++) {
          
          PVector vertexA = transformedVerticesB[j];
          PVector vertexB = transformedVerticesB[(j + 1) % transformedVerticesB.length];
  
          CollisionResult pointSegmentDistanceResult = PointSegmentDistance(point, vertexA, vertexB);

        if(PhysEngMath.Equals(pointSegmentDistanceResult.getDistanceSquared(),minDistanceSquared)) {

            if(!PhysEngMath.Equals(pointSegmentDistanceResult.getPointsOfContact()[0], contactPointA)) {

              contactPointB = pointSegmentDistanceResult.getPointsOfContact()[0];
              contactCount = 2;

            }
        } else if(pointSegmentDistanceResult.getDistanceSquared() < minDistanceSquared) {

            minDistanceSquared = pointSegmentDistanceResult.getDistanceSquared();
            contactPointA = pointSegmentDistanceResult.getPointsOfContact()[0];
            contactCount = 1;
        }
      }
    }

  for(int i = 0; i < transformedVerticesB.length; i++) {

      PVector point = transformedVerticesB[i];

      for(int j = 0; j < transformedVerticesA.length; j++) {
          
          PVector vertexA = transformedVerticesA[j];
          PVector vertexB = transformedVerticesA[(j + 1) % transformedVerticesA.length];
  
          CollisionResult pointSegmentDistanceResult = PointSegmentDistance(point, vertexA, vertexB);

        if(PhysEngMath.Equals(pointSegmentDistanceResult.getDistanceSquared(),minDistanceSquared)) {

            if(!PhysEngMath.Equals(pointSegmentDistanceResult.getPointsOfContact()[0], contactPointA)) {

              contactPointB = pointSegmentDistanceResult.getPointsOfContact()[0];
              contactCount = 2;

            }
        } else if(pointSegmentDistanceResult.getDistanceSquared() < minDistanceSquared) {

            minDistanceSquared = pointSegmentDistanceResult.getDistanceSquared();
            contactPointA = pointSegmentDistanceResult.getPointsOfContact()[0];
            contactCount = 1;
        }
      }
    }

    if(contactCount == 1){
      return new PVector[] {contactPointA};
    }
  return new PVector[] {contactPointA, contactPointB};
  
}
*/

private static PVector[] FindPolygonsCollisionPoints(PVector[] transformedVerticesA,
                                                           PVector[] transformedVerticesB) {
  PVector contactPointA = new PVector();
  PVector contactPointB = new PVector();

  PVector vertexA = new PVector();
  PVector vertexB = new PVector();
  
  PVector point = new PVector();
  int contactCount = 0;

  float minDistanceSquared = Float.MAX_VALUE;

  for(int i = 0; i < transformedVerticesA.length; i++) {

      point.set(transformedVerticesA[i]);

      for(int j = 0; j < transformedVerticesB.length; j++) {
        
        CollisionResult pointSegmentDistanceResult = PointSegmentDistance(point, transformedVerticesB[j], transformedVerticesB[(j + 1) % transformedVerticesB.length]);

        if(PhysEngMath.Equals(pointSegmentDistanceResult.getDistanceSquared(),minDistanceSquared)) {

            if(!PhysEngMath.Equals(pointSegmentDistanceResult.getPointsOfContact()[0], contactPointA)) {

              contactPointB.set(pointSegmentDistanceResult.getPointsOfContact()[0]);
              contactCount = 2;

            }
            
        } else if(pointSegmentDistanceResult.getDistanceSquared() < minDistanceSquared) {

            minDistanceSquared = pointSegmentDistanceResult.getDistanceSquared();
            contactPointA.set(pointSegmentDistanceResult.getPointsOfContact()[0]);
            contactCount = 1;
        }
      }
    }


  for(int i = 0; i < transformedVerticesB.length; i++) {

      point.set(transformedVerticesB[i]);

      for(int j = 0; j < transformedVerticesA.length; j++) {
          
          vertexA.set(transformedVerticesA[j]);
          vertexB.set(transformedVerticesA[(j + 1) % transformedVerticesA.length]);
  
          CollisionResult pointSegmentDistanceResult = PointSegmentDistance(point, transformedVerticesA[j], transformedVerticesA[(j + 1) % transformedVerticesA.length]);

        if(PhysEngMath.Equals(pointSegmentDistanceResult.getDistanceSquared(),minDistanceSquared)) {

            if(!PhysEngMath.Equals(pointSegmentDistanceResult.getPointsOfContact()[0], contactPointA)) {
              contactPointB.set(pointSegmentDistanceResult.getPointsOfContact()[0]);
              contactCount = 2;
            }

        } else if(pointSegmentDistanceResult.getDistanceSquared() < minDistanceSquared) {
            minDistanceSquared = pointSegmentDistanceResult.getDistanceSquared();
            contactPointA.set(pointSegmentDistanceResult.getPointsOfContact()[0]);
            contactCount = 1;
        }
      }
    }

    if(contactCount == 1){
      return new PVector[] {contactPointA};
    }
    
    return new PVector[] {contactPointA, contactPointB};
  
}

/*
====================================================================================================
=============================CIRCLE-POLYGON COLLISION CONTACT POINT ===============================
======================================= COLLISION-RESULT ===========================================
====================================================================================================
*/

/*Somewhat optimized */

private static PVector[] FindCirclePolygonCollisionPoint(PVector circleCenter,
                                                         float circleRadius,
                                                         PVector polygonCenter,
                                                         PVector[] transformedVertices) {

    float minDistanceSquared = Float.MAX_VALUE;
    PVector contactPoint = new PVector();

    for(int i = 0; i < transformedVertices.length; i++) {

        CollisionResult pointSegmentDistanceResult = PointSegmentDistance(circleCenter, transformedVertices[i], transformedVertices[(i + 1) % transformedVertices.length]); 

        if(pointSegmentDistanceResult.getDistanceSquared() < minDistanceSquared) {

            minDistanceSquared = pointSegmentDistanceResult.getDistanceSquared();
            contactPoint.set(pointSegmentDistanceResult.getPointsOfContact()[0]);
        }
    }

    return new PVector[] {contactPoint};
  }


/*
====================================================================================================
===================================== AABB-AABB COLLISIONS =========================================
====================================================================================================
*/
public static boolean IntersectAABB (AABB aabbA, AABB aabbB) {

  if(aabbA.getMax().x <= aabbB.getMin().x || aabbB.getMax().x <= aabbA.getMin().x
    || aabbA.getMax().y <= aabbB.getMin().y || aabbB.getMax().y <= aabbA.getMin().y) {

    return false;
  }

  return true;
}
/*
====================================================================================================
===================================== CIRCLE-CIRCLE COLLISIONS =====================================
======================================= COLLISION-RESULT ===========================================
====================================================================================================
*/
/*somewhat Optimized*/
  public static CollisionResult IntersectCircle(PVector centerA, PVector centerB,
                                                float radiusA, float radiusB) {

    PVector direction = PVector.sub(centerB, centerA);
    float distance = direction.mag();
    float radiusSum = (radiusA + radiusB);
    
    if(distance < radiusSum) {
      return physicsEngine.new CollisionResult(true, direction.normalize(), radiusSum - distance);
    } else {
      return physicsEngine.new CollisionResult();
    }
  }
  
                                             

/*
====================================================================================================
===================================== POLYGON-POLYGON COLLISIONS ===================================
======================================= COLLISION-RESULT============================================
====================================================================================================
*/

/*Optimized somewhat*/
public static CollisionResult IntersectPolygon(PVector centerA,
                                               PVector[] transformedVerticesA,
                                               PVector centerB,
                                               PVector[] transformedVerticesB) {

    float depth = Float.MAX_VALUE;

    PVector axis = new PVector();
    PVector normal = new PVector();
    PVector edge = new PVector();

    PVector transformedVertexA = new PVector();
    PVector transformedVertexB = new PVector();

    PVector secondTransformedVertexA = new PVector();
    PVector secondTransformedVertexB = new PVector();


    for(int vertexIndexA = 0; vertexIndexA < transformedVerticesA.length; vertexIndexA++) {
 

      //Gets the transformed vertices in polygon A, when at the end of the list, loops back to the start
      transformedVertexA.set(transformedVerticesA[vertexIndexA]);
      transformedVertexB.set(transformedVerticesA[(vertexIndexA + 1) % transformedVerticesA.length]);

      //Finds the edge between the two vertices,
      edge.set(PVector.sub(transformedVertexB, transformedVertexA));

      //Finds the normal or "axis" from the edge vector
      axis.set(-edge.y, edge.x);
      axis.normalize();

      //Projects the vertices of polygon A onto the axis. Format is [min, max]
      float[] minMaxA = ProjectVertices(transformedVerticesA, axis);
      float[] minMaxB = ProjectVertices(transformedVerticesB, axis);

      if(minMaxA[0] >= minMaxB[1] || minMaxB[0] >= minMaxA[1]) {
        return physicsEngine.new CollisionResult();
      }

      float axisDepth = min(minMaxB[1]-minMaxA[0], minMaxA[1]-minMaxB[0]);

      if(axisDepth < depth) {
        depth = axisDepth;
        normal.set(axis);
      }
    }

    for(int vertexIndexB = 0; vertexIndexB < transformedVerticesB.length; vertexIndexB++) {
      //!!!ALL OF THIS ASSUMES A CLOCKWISE WINDING ORDER!!!

      //Gets the transformed vertices in polygon A, when at the end of the list, loops back to the start
      secondTransformedVertexA.set(transformedVerticesB[vertexIndexB]);
      secondTransformedVertexB.set(transformedVerticesB[(vertexIndexB + 1) % transformedVerticesB.length]);

      //Finds the edge between the two vertices, 
      edge.set(PVector.sub(secondTransformedVertexB, secondTransformedVertexA));

      //Finds the normal or "axis" from the edge vector
      axis.set(-edge.y, edge.x);
      axis.normalize();

      //Projects the vertices of polygon A onto the axis. Format is [min, max]
      float[] minMaxA = ProjectVertices(transformedVerticesA, axis);
      float[] minMaxB = ProjectVertices(transformedVerticesB, axis);

      if(minMaxA[0] >= minMaxB[1] || minMaxB[0] >= minMaxA[1]) {        
        return physicsEngine.new CollisionResult();
      }

      float axisDepth = min(minMaxB[1]-minMaxA[0], minMaxA[1]-minMaxB[0]);
      
      if(axisDepth < depth) {
        depth = axisDepth;
        normal.set(axis);
      }
    }

    //This is correction code so that the normal points in the correct direction
    //If its not pointing in the correct direction, flip the normal
  
    if(PVector.dot(PVector.sub(centerB, centerA), normal) < 0) {
      normal.mult(-1);
    }

    return physicsEngine.new CollisionResult(true, normal, depth);
  }

//The overloaded method is used when the center of the polygon is not known


/*
====================================================================================================
===================================== CIRCLE-POLYGON COLLISIONS ====================================
======================================= COLLISION-RESULT ===========================================
====================================================================================================
*/


public static CollisionResult IntersectCirclePolygon(PVector circleCenter, float circleRadius,
                                                     PVector polygonCenter,
                                                     PVector[] transformedVertices){
    boolean isColliding;
    float depth = Float.MAX_VALUE;
    PVector normal = new PVector();

    PVector edge = new PVector();
    PVector axis = new PVector();

    float axisDepth = 0f;

    for(int vertexIndex = 0; vertexIndex < transformedVertices.length; vertexIndex++) {
      //!!!ALL OF THIS ASSUMES A CLOCKWISE WINDING ORDER!!!

      //Finds the edge between the two vertices,
      edge.set(PVector.sub(transformedVertices[(vertexIndex + 1) % transformedVertices.length], transformedVertices[vertexIndex]));
      
      //Finds the normal or "axis" from the edge vector
       axis.set(-edge.y, edge.x);
       axis.normalize();

      //Projects the vertices of polygon A onto the axis. Format is [min, max]
      float[] minMaxA = ProjectVertices(transformedVertices, axis);

      //Projects the circle onto the axis. Format is [min, max]
      float[] minMaxB = ProjectCircle(circleCenter, axis, circleRadius);

      if(minMaxA[0] >= minMaxB[1] || minMaxB[0] >= minMaxA[1]) {

        return physicsEngine.new CollisionResult();
      }

       axisDepth = min(minMaxB[1]-minMaxA[0], minMaxA[1]-minMaxB[0]);
        if(axisDepth < depth) {
            depth = axisDepth;
            normal.set(axis);
        }
  }

    /*
    int closestPointIndex = FindClosestPointOnPolygon(circleCenter, transformedVertices);
    PVector closestPoint = transformedVertices[closestPointIndex];
    axis = PVector.sub(closestPoint, circleCenter).normalize();
    */

    axis.set(PVector.sub(transformedVertices[FindClosestPointOnPolygon(circleCenter, transformedVertices)], circleCenter).normalize());

     //Projects the vertices of polygon A onto the axis. Format is [min, max]
      float[] minMaxA = ProjectVertices(transformedVertices, axis);
      //Projects the circle onto the axis. Format is [min, max]
      float[] minMaxB = ProjectCircle(circleCenter, axis, circleRadius);


      if(minMaxA[0] >= minMaxB[1] || minMaxB[0] >= minMaxA[1]) {
        
        return physicsEngine.new CollisionResult();
      }

      axisDepth = min(minMaxB[1]-minMaxA[0], minMaxA[1]-minMaxB[0]);

      if(axisDepth < depth) {
        depth = axisDepth;
        normal.set(axis);
      }

        if(PVector.dot(PVector.sub(polygonCenter, circleCenter), normal) < 0) {
          normal.mult(-1);
        }
  
        isColliding = true;

        return physicsEngine.new CollisionResult(isColliding, normal, depth);
}




/*
====================================================================================================
========================================= HELPER-METHODS ===========================================
====================================================================================================
*/

//Returns an array with array = [min, max]
private static float[] ProjectVertices(PVector[] vertices, PVector axis){

  float min = Float.MAX_VALUE;
  float max = Float.MIN_VALUE;

  for(PVector vertex : vertices) {

    float projectedVertex = PVector.dot(vertex, axis);

    if(projectedVertex < min) {
      min = projectedVertex;
    }

    if(projectedVertex > max) {
      max = projectedVertex;
    }

  }
  return new float[] {min, max};
}

private static float[] ProjectCircle(PVector center, PVector axis, float radius) {
  
  PVector directionAndRadius = PVector.mult(axis, radius);

  float min = PVector.dot(PVector.add(center, directionAndRadius), axis);
  float max = PVector.dot(PVector.sub(center, directionAndRadius), axis);
   
  if(min > max){
    float temp = min;
    min = max;
    max = temp;
  }

  return new float[] {min, max};
}

private static int FindClosestPointOnPolygon(PVector circleCenter, PVector[] transformedVertices) {
/*
  int result = -1;
  float minDistance = Float.MAX_VALUE;

  for(int vertexIndex = 0; vertexIndex < transformedVertices.length; vertexIndex++) {

    float distance = PVector.sub(circleCenter, transformedVertices[vertexIndex]).magSq();

    if(distance < minDistance) {
      minDistance = distance;
      result = vertexIndex;
    }

  }

  return result;
  */

  int result = -1;
  float minDistanceSq = Float.MAX_VALUE;

  for(int vertexIndex = 0; vertexIndex < transformedVertices.length; vertexIndex++) {

    float distanceSq = PVector.sub(circleCenter, transformedVertices[vertexIndex]).magSq();

    if(distanceSq < minDistanceSq) {
      minDistanceSq = distanceSq;
      result = vertexIndex;
    }

  }

  return result;
}

public static CollisionResult PointSegmentDistance(PVector point, PVector lineSegmentStart, PVector lineSegmentEnd) {
    //PVector.sub(point, lineSegmentStart) is equivalent to pointToLineSegment

    PVector lineSegment = new PVector();
    lineSegment.set(PVector.sub(lineSegmentEnd, lineSegmentStart));

    float projection = PVector.dot(PVector.sub(point, lineSegmentStart), lineSegment);
    float lineSegmentLengthSquared = lineSegment.magSq();

    float distance = projection / lineSegmentLengthSquared;

    PVector closestPoint = new PVector();

    if (distance <= 0f) {
        closestPoint.set(lineSegmentStart);
    } else if (distance >= 1f) {
        closestPoint.set(lineSegmentEnd);
    } else {
        closestPoint.set(PVector.add(lineSegmentStart, PVector.mult(lineSegment, distance)));
    }

    float distanceSquared = PVector.sub(point, closestPoint).magSq();

    return physicsEngine.new CollisionResult(distanceSquared, closestPoint);
}
} 
public interface ForceRegistry {
    public PVector getForce(Rigidbody rigidbody, PVector position);
    public void draw();
    public PVector getApplicationPoint(Rigidbody rigidbody, PVector position);
}

public enum ForceType {
  SPRING,
  ROD,
  MOTOR
}
    public class GUI {
        
        //The size of the group
        public int globalGroupHeight = 225;
        public int globalGroupWidth = 230;
        private int globalGroupBarHeight = 20;

        //The padding of the group from the edges of the screen
        public int globalScreenGroupPaddingX = 40;
        public int globalScreenGroupPaddingY = 40;


        
        //The padding for elements from the edge of the group
        private int globalGroupPaddingX = 10;
        private int globalGroupPaddingY = 10;
        
        //The padding between elements in the group
        private int globalInterElementPaddingX = 10;
        private int globalInterElementPaddingY = 10;

    
        //the group background color
        private int globalGroupColor = color(250, 50);

        private int rowCount = 10;

        //Checks which tab is open
        private boolean isRigidbodiesTabOpen;
        private boolean isForcesTabOpen;
     
        /*---------------------------- Default Values Initialization ------------------------*/
        private Tab defaultTab = userInterface.getTab("Rigidbodies");
        private Tab currentTab = defaultTab;
        /*---------------------------- Rigidbodies Tab -------------------------------------*/
        private boolean defaultCircleSelector = false;
        private boolean defaultRectangleSelector = false;
        private boolean defaultPolygonSelector = false;

        private float defaultRectangleWidth = 2f;
        private float defaultRectangleHeight = 2f;
        private float defaultCircleRadius = 1f;

        private float defaultDensity = 10f;
        private float defaultRestitution = 0.5f;

        private PVector defaultFillColour = new PVector(255, 255, 255);
        private PVector defaultStrokeColour = new PVector(0, 0, 0);
        private float defaultStrokeWeight = 0.05f;

        private boolean defaultIsStatic = false;
        private boolean defaultIsTransStatic = false;
        private boolean defaultIsRotStatic = false;

        private boolean defaultAddGravity = true;
        private float defaultAngle = 0f;
        private float defaultAngularVelocity = 0f;

        private boolean isFillColourSelectedDefault = true;

    /*---------------------------- Forces Tab -------------------------------------*/
        private boolean defaultSpringSelector = false;
        private boolean defaultRodSelector = false;
        private boolean defaultMotorSelector = false;

        private float defaultSpringConstant = 50f;
        private float defaultSpringDamping = 0.5f;
        private float defaultSpringEquilibriumLength = 1f;

        private boolean defaultLockToXAxis = false;
        private boolean defaultLockToYAxis = false;

        private boolean defaultSpringIsPerfect = false;
        private boolean defaultSpringIsHingeable = true;

        private boolean defaultRodIsHingeable = true;

        private boolean defaultSnapToCenter = true;
        private boolean defaultSnapToEdge = false;

        private float defaultMotorTargetAngularVelocity = 0f;
        private boolean defaultMotorDrawMotor = false;
        private boolean defaultMotorDrawMotorForce = true;

    /*---------------------------- Editor Tab ----------------------- */


/*
====================================================================================================
========================================= User Interface ===========================================
====================================================================================================
*/
        public GUI(ControlP5 userInterface) {
    /*---------------------- Interactivity Listener Initialization -----------------*/
        if(defaultCircleSelector == true){
            interactivityListener.setShapeType(ShapeType.CIRCLE);
        } else if(defaultRectangleSelector == true){

            interactivityListener.setShapeType(ShapeType.BOX);
        } else if(defaultPolygonSelector == true){

            interactivityListener.setShapeType(ShapeType.POLYGON);
        }

        if(defaultSpringSelector) {
            interactivityListener.setForceType(ForceType.SPRING);
        } else if(defaultRodSelector) {

            interactivityListener.setForceType(ForceType.ROD);
        } else if(defaultMotorSelector) {
            interactivityListener.setForceType(ForceType.MOTOR);
        }



        interactivityListener.setWidth(defaultRectangleWidth);
        interactivityListener.setHeight(defaultRectangleHeight);
        interactivityListener.setRadius(defaultCircleRadius);

        interactivityListener.setDensity(defaultDensity);
        interactivityListener.setRestitution(defaultRestitution);

        interactivityListener.setFillColor(defaultFillColour);
        interactivityListener.setStrokeColor(defaultStrokeColour);
        interactivityListener.setStrokeWeight(defaultStrokeWeight);

        interactivityListener.setAngle(defaultAngle);
        interactivityListener.setAngularVelocity(defaultAngularVelocity);

        interactivityListener.setIsStatic(defaultIsStatic);
        interactivityListener.setIsTranslationallyStatic(defaultIsTransStatic);
        interactivityListener.setIsRotationallyStatic(defaultIsRotStatic);
        interactivityListener.setAddGravity(defaultAddGravity);
        
        interactivityListener.setSpringConstant(defaultSpringConstant);
        interactivityListener.setSpringDamping(defaultSpringDamping);
        interactivityListener.setSpringEquilibriumLength(defaultSpringEquilibriumLength);

        interactivityListener.setLockToXAxis(defaultLockToXAxis);
        interactivityListener.setLockToYAxis(defaultLockToYAxis);

        interactivityListener.setSpringIsPerfect(defaultSpringIsPerfect);
        interactivityListener.setSpringIsHingeable(defaultSpringIsHingeable);
        interactivityListener.setRodIsHingeable(defaultRodIsHingeable);
        
        interactivityListener.setSnapToCenter(defaultSnapToCenter);
        interactivityListener.setSnapToEdge(defaultSnapToEdge);


        interactivityListener.setMotorTargetAngularVelocity(defaultMotorTargetAngularVelocity);
        interactivityListener.setMotorDrawMotor(defaultMotorDrawMotor);
        interactivityListener.setMotorDrawMotorForce(defaultMotorDrawMotorForce);

    /*----------------------------------------------------------------------------*/

                Tab Rigidbodies = userInterface.addTab("Rigidbodies")
                                .setLabel("Rigidbodies")
                                .setId(0)
                                .activateEvent(true)
                                .addListener(new ControlListener() {
                                    public void controlEvent(ControlEvent theEvent) {
                                        if(theEvent.isTab() && theEvent.getTab().getId() == 0) {
                                            interactivityListener.setGenerateRigidbodies(true);
                                            interactivityListener.setGenerateForces(false);
                                        }
                                    }
                                })
                                ;
                
  

                Tab Forces = userInterface.addTab("Forces")
                                .setLabel("Forces")
                                .setId(1)
                                .activateEvent(true)
                                .addListener(new ControlListener() {
                                    public void controlEvent(ControlEvent theEvent) {
                                        if(theEvent.isTab() && theEvent.getTab().getId() == 1) {
                                            interactivityListener.setGenerateRigidbodies(false);
                                            interactivityListener.setGenerateForces(true);
                                        }
                                    }
                                })
                                ;

                Tab Editor = userInterface.addTab("Editor")
                                .setLabel("Editor")
                                .setId(2);

                Tab Debug = userInterface.addTab("Debug")
                                .setLabel("Debug")
                                .setId(2);

/*----------------------------------- Rigidbodies Tab ------------------------------------------*/
                Group RigidbodyGeneration = userInterface.addGroup("Rigidbody")
                                .setPosition(calculateGroupPositionX(), calculateGroupPositionY())
                                .setBackgroundHeight(globalGroupHeight)
                                .setBarHeight(globalGroupBarHeight)
                                .setBackgroundColor(globalGroupColor)
                                .setWidth(globalGroupWidth)
                                 //.disableCollapse()
                                .setTab("Rigidbodies")
                                ;

                        Toggle Circle = userInterface.addToggle("Circle")
                                        .setPosition(calculateButtonPositionX(1, calculateButtonWidth(2)), calculateButtonPositionY(1, calculateButtonHeight(rowCount)))
                                        .setSize(calculateButtonWidth(2), calculateButtonHeight(rowCount))
                                        .setLabel("Circle")
                                        .setGroup(RigidbodyGeneration)
                                        .setValue(defaultCircleSelector)
                                        .onChange(new CallbackListener() {
                                                public void controlEvent(CallbackEvent theEvent) {

                                                        CircleShapeSelectorOnChange();
                                                    }
                                                })
                                            ;

                        Toggle Rectangle = userInterface.addToggle("Box")
                                        .setPosition(calculateButtonPositionX(2, calculateButtonWidth(2)), calculateButtonPositionY(1, calculateButtonHeight(rowCount)))
                                        .setSize(calculateButtonWidth(2), calculateButtonHeight(rowCount))
                                        .setLabel("Rectangle")
                                        .setGroup(RigidbodyGeneration)
                                        .setValue(defaultRectangleSelector)
                                        .onChange(new CallbackListener() {
                                                public void controlEvent(CallbackEvent theEvent) {

                                                        RectangleShapeSelectorOnChange();
                                                    }
                                                })
                                            ;

                                        
                        Slider Density = userInterface.addSlider("Density")
                                        .setPosition(calculateButtonPositionX(1, calculateButtonWidth(2)), calculateButtonPositionY(2, calculateButtonHeight(rowCount)))
                                        .setSize(calculateButtonWidth(2),calculateButtonHeight(rowCount))
                                        .setLabel("Density")
                                        .setVisible(false)
                                        .setRange(MIN_BODY_DENSITY, MAX_BODY_DENSITY)
                                        .setValue(defaultDensity)
                                        .setGroup(RigidbodyGeneration)
                                        .onChange(new CallbackListener() {
                                                public void controlEvent(CallbackEvent theEvent) {

                                                        DensityElementOnChange();
                                                    }
                                                })
                                            ;

                        Slider Restitution = userInterface.addSlider("Restitution")
                                        .setPosition(calculateButtonPositionX(2, calculateButtonWidth(2)), calculateButtonPositionY(2, calculateButtonHeight(rowCount)))
                                        .setSize(calculateButtonWidth(2),calculateButtonHeight(rowCount))
                                        .setLabel("Restitution")
                                        .setVisible(false)
                                        .setRange(0.01f, 1)
                                        .setValue(defaultRestitution)
                                        .setGroup(RigidbodyGeneration)
                                        .onChange(new CallbackListener() {
                                                public void controlEvent(CallbackEvent theEvent) {

                                                        RestitutionElementOnChange();
                                                    }
                                                })
                                            ;

                        Slider RectangleWidth = userInterface.addSlider("RectangleWidth")
                                        .setPosition(calculateButtonPositionX(1, calculateButtonWidth(2)), calculateButtonPositionY(3, calculateButtonHeight(rowCount)))
                                        .setSize(calculateButtonWidth(2),calculateButtonHeight(rowCount))
                                        .setLabel("Width")
                                        .setVisible(false)
                                        .setRange(MIN_BODY_WIDTH, MAX_BODY_WIDTH)
                                        .setValue(defaultRectangleWidth)
                                        .setGroup(RigidbodyGeneration)
                                        .onChange(new CallbackListener() {
                                                public void controlEvent(CallbackEvent theEvent) {
                                                        RectangleWidthElementOnChange();
                                                    }
                                                })
                                            ;

                        Slider RectangleHeight = userInterface.addSlider("RectangleHeight")
                                        .setPosition(calculateButtonPositionX(2, calculateButtonWidth(2)), calculateButtonPositionY(3, calculateButtonHeight(rowCount)))
                                        .setSize(calculateButtonWidth(2),calculateButtonHeight(rowCount))
                                        .setLabel("Height")
                                        .setVisible(false)
                                        .setRange(MIN_BODY_HEIGHT, MAX_BODY_HEIGHT)
                                        .setValue(defaultRectangleHeight)
                                        .setGroup(RigidbodyGeneration)
                                        .onChange(new CallbackListener() {
                                                public void controlEvent(CallbackEvent theEvent) {

                                                        RectangleHeightElementOnChange();
                                                    }
                                                })
                                            ;

                        Slider CircleRadius = userInterface.addSlider("CircleRadius")
                                        .setPosition(calculateButtonPositionX(1, calculateButtonWidth(1)), calculateButtonPositionY(3, calculateButtonHeight(rowCount)))
                                        .setSize(calculateButtonWidth(1),calculateButtonHeight(rowCount))
                                        .setLabel("Radius")
                                        .setVisible(false)
                                        .setRange(MIN_BODY_RADIUS, MAX_BODY_RADIUS)
                                        .setValue(defaultCircleRadius)
                                        .setGroup(RigidbodyGeneration)
                                        .onChange(new CallbackListener() {
                                                public void controlEvent(CallbackEvent theEvent) {

                                                        CircleRadiusElementOnChange();
                                                    }
                                                })
                                            ;

                        Toggle fillColour = userInterface.addToggle("FillColour")
                                        .setPosition(calculateButtonPositionX(1, calculateButtonWidth(3)), calculateButtonPositionY(4, calculateButtonHeight(rowCount)))
                                        .setSize(calculateButtonWidth(3),calculateButtonHeight(rowCount))
                                        .setLabel("Fill Colour")
                                        .setVisible(false)
                                        .setGroup(RigidbodyGeneration)
                                        .setValue(false)
                                        .onChange(new CallbackListener() {
                                                public void controlEvent(CallbackEvent theEvent) {

                                                       FillColourSelectorOnChange();
                                                    }
                                                })
                                            ;

                        Toggle strokeColour = userInterface.addToggle("StrokeColour")
                                        .setPosition(calculateButtonPositionX(2, calculateButtonWidth(3)), calculateButtonPositionY(4, calculateButtonHeight(rowCount)))
                                        .setSize(calculateButtonWidth(3),calculateButtonHeight(rowCount))
                                        .setLabel("Stroke Colour")
                                        .setVisible(false)
                                        .setGroup(RigidbodyGeneration)
                                        .setValue(false)
                                        .onChange(new CallbackListener() {
                                                public void controlEvent(CallbackEvent theEvent) {

                                                        StrokeColourSelectorOnChange();
                                                    }
                                                })
                                            ;

                        Slider strokeWeight = userInterface.addSlider("StrokeWeight")
                                        .setPosition(calculateButtonPositionX(3, calculateButtonWidth(3)), calculateButtonPositionY(4, calculateButtonHeight(rowCount)))
                                        .setSize(calculateButtonWidth(3),calculateButtonHeight(rowCount))
                                        .setLabel("Stroke")
                                        .setVisible(false)
                                        .setRange(0, 0.5f)
                                        .setValue(0.05f)
                                        .setGroup(RigidbodyGeneration)
                                        .onChange(new CallbackListener() {
                                                public void controlEvent(CallbackEvent theEvent) {

                                                        StrokeWeightElementOnChange();
                                                    }
                                                })
                                            ;

                        Slider redSliderFill = userInterface.addSlider("RedFill")
                                        .setPosition(calculateButtonPositionX(1, calculateButtonWidth(3)), calculateButtonPositionY(5, calculateButtonHeight(rowCount)))
                                        .setSize(calculateButtonWidth(3),calculateButtonHeight(rowCount))
                                        .setLabel("Red")
                                        .setVisible(false)
                                        .setRange(0, 255)
                                        .setValue(defaultFillColour.x)
                                        .setGroup(RigidbodyGeneration)
                                        .onChange(new CallbackListener() {
                                                public void controlEvent(CallbackEvent theEvent) {
                        
                                                        FillSliderElementOnChange();
                                                    }
                                                })
                                            ;

                        Slider greenSliderFill = userInterface.addSlider("GreenFill")
                                        .setPosition(calculateButtonPositionX(2, calculateButtonWidth(3)), calculateButtonPositionY(5, calculateButtonHeight(rowCount)))
                                        .setSize(calculateButtonWidth(3),calculateButtonHeight(rowCount))
                                        .setLabel("Green")
                                        .setVisible(false)
                                        .setRange(0, 255)
                                        .setValue(defaultFillColour.y)
                                        .setGroup(RigidbodyGeneration)
                                        .onChange(new CallbackListener() {
                                                public void controlEvent(CallbackEvent theEvent) {

                                                        FillSliderElementOnChange();
                                                    }
                                                })
                                            ;

                        Slider blueSliderFill = userInterface.addSlider("BlueFill")
                                        .setPosition(calculateButtonPositionX(3, calculateButtonWidth(3)), calculateButtonPositionY(5, calculateButtonHeight(rowCount)))
                                        .setSize(calculateButtonWidth(3),calculateButtonHeight(rowCount))
                                        .setLabel("Blue")
                                        .setVisible(false)
                                        .setRange(0, 255)
                                        .setValue(defaultFillColour.z)
                                        .setGroup(RigidbodyGeneration)
                                        .onChange(new CallbackListener() {
                                                public void controlEvent(CallbackEvent theEvent) {
                                                        
                                                        FillSliderElementOnChange();
                                                    }
                                                })
                                            ;

                        Slider redSliderStroke = userInterface.addSlider("RedStroke")
                                        .setPosition(calculateButtonPositionX(1, calculateButtonWidth(3)), calculateButtonPositionY(5, calculateButtonHeight(rowCount)))
                                        .setSize(calculateButtonWidth(3),calculateButtonHeight(rowCount))
                                        .setLabel("Red")
                                        .setVisible(false)
                                        .setRange(0, 255)
                                        .setValue(defaultStrokeColour.x)
                                        .setGroup(RigidbodyGeneration)
                                        .onChange(new CallbackListener() {
                                                public void controlEvent(CallbackEvent theEvent) {

                                                        StrokeSliderElementOnChange();
                                                    }
                                                })
                                            ;

                        Slider greenSliderStroke = userInterface.addSlider("GreenStroke")
                                        .setPosition(calculateButtonPositionX(2, calculateButtonWidth(3)), calculateButtonPositionY(5, calculateButtonHeight(rowCount)))
                                        .setSize(calculateButtonWidth(3),calculateButtonHeight(rowCount))
                                        .setLabel("Green")
                                        .setVisible(false)
                                        .setRange(0, 255)
                                        .setValue(defaultStrokeColour.y)
                                        .setGroup(RigidbodyGeneration)
                                        .onChange(new CallbackListener() {
                                                public void controlEvent(CallbackEvent theEvent) {
                                                        
                                                        StrokeSliderElementOnChange();
                                                    }
                                                })
                                            ;

                        Slider blueSliderStroke = userInterface.addSlider("BlueStroke")
                                        .setPosition(calculateButtonPositionX(3, calculateButtonWidth(3)), calculateButtonPositionY(5, calculateButtonHeight(rowCount)))
                                        .setSize(calculateButtonWidth(3),calculateButtonHeight(rowCount))
                                        .setLabel("Blue")
                                        .setVisible(false)
                                        .setRange(0, 255)
                                        .setValue(defaultStrokeColour.z)
                                        .setGroup(RigidbodyGeneration)
                                        .onChange(new CallbackListener() {
                                                public void controlEvent(CallbackEvent theEvent) {
                                                        
                                                        StrokeSliderElementOnChange();
                                                    }
                                                })
                                            ;

                        Bang colorBox = userInterface.addBang("ColorBox")
                                        .setPosition(calculateButtonPositionX(1, calculateButtonWidth(1)), calculateButtonPositionY(6, calculateButtonHeight(rowCount)))
                                        .setSize(calculateButtonWidth(1),calculateButtonHeight(rowCount))
                                        .setLabel("Color")
                                        .setColorForeground(color(defaultFillColour.x, defaultFillColour.y, defaultFillColour.z))
                                        .setColorActive(color(defaultFillColour.x, defaultFillColour.y, defaultFillColour.z))
                                        .setVisible(false)
                                        .setLabelVisible(false)
                                        .setGroup(RigidbodyGeneration)
                                        ;

                        Toggle isStatic = userInterface.addToggle("isStatic")
                                        .setPosition(calculateButtonPositionX(1, calculateButtonWidth(3)), calculateButtonPositionY(7, calculateButtonHeight(rowCount)))
                                        .setSize(calculateButtonWidth(3),calculateButtonHeight(rowCount))
                                        .setLabel("Static")
                                        .setVisible(false)
                                        .setGroup(RigidbodyGeneration)
                                        .setValue(defaultIsStatic)
                                        .onChange(new CallbackListener() {
                                                public void controlEvent(CallbackEvent theEvent) {
                                                        IsStaticSelectorElementOnChange();
                                                    }
                                                })
                                            ;

                        Toggle isTranslationallyStatic = userInterface.addToggle("transStatic")
                                        .setPosition(calculateButtonPositionX(2, calculateButtonWidth(3)), calculateButtonPositionY(7, calculateButtonHeight(rowCount)))
                                        .setSize(calculateButtonWidth(3),calculateButtonHeight(rowCount))
                                        .setLabel("TransStatic")
                                        .setVisible(false)
                                        .setGroup(RigidbodyGeneration)
                                        .setValue(defaultIsTransStatic)
                                        .onChange(new CallbackListener() {
                                                public void controlEvent(CallbackEvent theEvent) {
                                                        IsTransStaticSelectorElementOnChange();
                                                    }
                                                })
                                            ;

                        Toggle isRotationallyStatic = userInterface.addToggle("rotStatic")
                                        .setPosition(calculateButtonPositionX(3, calculateButtonWidth(3)), calculateButtonPositionY(7, calculateButtonHeight(rowCount)))
                                        .setSize(calculateButtonWidth(3),calculateButtonHeight(rowCount))
                                        .setLabel("RotStatic")
                                        .setVisible(false)
                                        .setGroup(RigidbodyGeneration)
                                        .setValue(defaultIsRotStatic)
                                        .onChange(new CallbackListener() {
                                                public void controlEvent(CallbackEvent theEvent) {
                                                        IsRotStaticSelectorElementOnChange();
                                                    }
                                                })
                                            ;

                        Slider angle = userInterface.addSlider("Angle")
                                        .setPosition(calculateButtonPositionX(1, calculateButtonWidth(2)), calculateButtonPositionY(8, calculateButtonHeight(rowCount)))
                                        .setSize(calculateButtonWidth(2),calculateButtonHeight(rowCount))
                                        .setLabel("Angle")
                                        .setVisible(false)
                                        .setRange(0, 360)
                                        .setValue(defaultAngle)
                                        .setGroup(RigidbodyGeneration)
                                        .onChange(new CallbackListener() {
                                                public void controlEvent(CallbackEvent theEvent) {

                                                       AngleSliderElementOnChange();
                                                    }
                                                })
                                            ;

                        Slider angularVelocity = userInterface.addSlider("AngularVelocity")
                                        .setPosition(calculateButtonPositionX(2, calculateButtonWidth(2)), calculateButtonPositionY(8, calculateButtonHeight(rowCount)))
                                        .setSize(calculateButtonWidth(2),calculateButtonHeight(rowCount))
                                        .setLabel("Angular Vel")
                                        .setVisible(false)
                                        .setRange(-10, 10)
                                        .setValue(defaultAngularVelocity)
                                        .setGroup(RigidbodyGeneration)
                                        .onChange(new CallbackListener() {
                                                public void controlEvent(CallbackEvent theEvent) {
                                                            
                                                        AngularVelocitySliderElementOnChange();
                                                    }
                                                })
                                        ;
                        Toggle addGravity = userInterface.addToggle("AddGravity")
                                        .setPosition(calculateButtonPositionX(1, calculateButtonWidth(1)), calculateButtonPositionY(9, calculateButtonHeight(rowCount)))
                                        .setSize(calculateButtonWidth(1),calculateButtonHeight(rowCount))
                                        .setLabel("Add Gravity")
                                        .setVisible(false)
                                        .setValue(defaultAddGravity)
                                        .setGroup(RigidbodyGeneration)
                                        .onChange(new CallbackListener() {
                                                public void controlEvent(CallbackEvent theEvent) {
                                                        AddGravitySelectorElementOnChange();
                                                    }
                                                })
                                            ;

                        

/*----------------------------------- Forces Tab ------------------------------------------*/
            Group ForceGeneration = userInterface.addGroup("Force")
                            .setPosition(calculateGroupPositionX(), calculateGroupPositionY())
                            .setBackgroundHeight(globalGroupHeight)
                            .setBarHeight(globalGroupBarHeight)
                            .setBackgroundColor(globalGroupColor)
                            .setWidth(globalGroupWidth)
                             //.disableCollapse()
                            .setTab("Forces")
                            ;
                        Toggle addSpring = userInterface.addToggle("AddSpring")
                                        .setPosition(calculateButtonPositionX(1, calculateButtonWidth(3)), calculateButtonPositionY(1, calculateButtonHeight(rowCount)))
                                        .setSize(calculateButtonWidth(3),calculateButtonHeight(rowCount))
                                        .setLabel("Spring")
                                        .setValue(defaultSpringSelector)
                                        .setVisible(true)
                                        .setGroup(ForceGeneration)
                                        .onChange(new CallbackListener() {
                                                public void controlEvent(CallbackEvent theEvent) {
                                                        SpringForceSelectorOnChange();
                                                    }
                                                })
                                            ;
                        Toggle addRod = userInterface.addToggle("AddRod")
                                        .setPosition(calculateButtonPositionX(2, calculateButtonWidth(3)), calculateButtonPositionY(1, calculateButtonHeight(rowCount)))
                                        .setSize(calculateButtonWidth(3),calculateButtonHeight(rowCount))
                                        .setLabel("Rod")
                                        .setValue(defaultRodSelector)
                                        .setVisible(true)
                                        .setGroup(ForceGeneration)
                                        .onChange(new CallbackListener() {
                                                public void controlEvent(CallbackEvent theEvent) {
                                                        RodForceSelectorOnChange();
                                                    }
                                                })
                                            ;
                        Toggle addMotor = userInterface.addToggle("AddMotor")
                                        .setPosition(calculateButtonPositionX(3, calculateButtonWidth(3)), calculateButtonPositionY(1, calculateButtonHeight(rowCount)))
                                        .setSize(calculateButtonWidth(3),calculateButtonHeight(rowCount))
                                        .setLabel("Motor")
                                        .setValue(defaultMotorSelector)
                                        .setVisible(true)
                                        .setGroup(ForceGeneration)
                                        .onChange(new CallbackListener() {
                                                public void controlEvent(CallbackEvent theEvent) {
                                                        MotorForceSelectorOnChange();
                                                    }
                                                })
                                            ;
                        Slider springConstant = userInterface.addSlider("SpringConstant")
                                        .setPosition(calculateButtonPositionX(1, calculateButtonWidth(1)), calculateButtonPositionY(2, calculateButtonHeight(rowCount)))
                                        .setSize(calculateButtonWidth(1),calculateButtonHeight(rowCount))
                                        .setLabel("Spring Constant")
                                        .setVisible(false)
                                        .setRange(0, 300)
                                        .setValue(defaultSpringConstant)
                                        .setGroup(ForceGeneration)
                                        .onChange(new CallbackListener() {
                                                public void controlEvent(CallbackEvent theEvent) {
                                                        SpringConstantSliderElementOnChange();
                                                    }
                                                })
                                            ;
                        Slider springEquilibriumLength = userInterface.addSlider("SpringEquilibriumLength")
                                        .setPosition(calculateButtonPositionX(1, calculateButtonWidth(1)), calculateButtonPositionY(3, calculateButtonHeight(rowCount)))
                                        .setSize(calculateButtonWidth(1),calculateButtonHeight(rowCount))
                                        .setLabel("Equilibrium Length")
                                        .setVisible(false)
                                        .setRange(0, 5)
                                        .setValue(defaultSpringEquilibriumLength)
                                        .setGroup(ForceGeneration)
                                        .onChange(new CallbackListener() {
                                                public void controlEvent(CallbackEvent theEvent) {
                                                        SpringEquilibriumLengthSliderElementOnChange();
                                                    }
                                                })
                                            ;

                        Slider springDamping = userInterface.addSlider("SpringDamping")
                                        .setPosition(calculateButtonPositionX(1, calculateButtonWidth(1)), calculateButtonPositionY(4, calculateButtonHeight(rowCount)))
                                        .setSize(calculateButtonWidth(1),calculateButtonHeight(rowCount))
                                        .setLabel("Damping")
                                        .setVisible(false)
                                        .setRange(0, 1)
                                        .setValue(defaultSpringDamping)
                                        .setGroup(ForceGeneration)
                                        .onChange(new CallbackListener() {
                                                public void controlEvent(CallbackEvent theEvent) {
                                                        SpringDampingSliderElementOnChange();
                                                    }
                                                })
                                            ;

                        Toggle springLockToX = userInterface.addToggle("SpringLockToX")
                                        .setPosition(calculateButtonPositionX(1, calculateButtonWidth(1)), calculateButtonPositionY(5, calculateButtonHeight(rowCount)))
                                        .setSize(calculateButtonWidth(1),calculateButtonHeight(rowCount))
                                        .setLabel("Lock translation to x-axis")
                                        .setVisible(false)
                                        .setValue(defaultLockToXAxis)
                                        .setGroup(ForceGeneration)
                                        .onChange(new CallbackListener() {
                                                public void controlEvent(CallbackEvent theEvent) {
                                                        SpringLockToXSelectorElementOnChange();
                                                    }
                                                })
                                            ;
                        Toggle springLockToY = userInterface.addToggle("SpringLockToY")
                                        .setPosition(calculateButtonPositionX(1, calculateButtonWidth(1)), calculateButtonPositionY(6, calculateButtonHeight(rowCount)))
                                        .setSize(calculateButtonWidth(1),calculateButtonHeight(rowCount))
                                        .setLabel("Lock translation to y-axis")
                                        .setVisible(false)
                                        .setValue(defaultLockToYAxis)
                                        .setGroup(ForceGeneration)
                                        .onChange(new CallbackListener() {
                                                public void controlEvent(CallbackEvent theEvent) {
                                                        SpringLockToYSelectorElementOnChange();
                                                    }
                                                })
                                            ;
                        Toggle springIsPerfect = userInterface.addToggle("SpringIsPerfect")
                                        .setPosition(calculateButtonPositionX(1, calculateButtonWidth(2)), calculateButtonPositionY(7, calculateButtonHeight(rowCount)))
                                        .setSize(calculateButtonWidth(2),calculateButtonHeight(rowCount))
                                        .setLabel("Perfect Spring")
                                        .setVisible(false)
                                        .setValue(defaultSpringIsPerfect)
                                        .setGroup(ForceGeneration)
                                        .onChange(new CallbackListener() {
                                                public void controlEvent(CallbackEvent theEvent) {
                                                        SpringIsPerfectSelectorElementOnChange();
                                                    }
                                                })
                                            ;
                        Toggle springIsHingeable = userInterface.addToggle("SpringIsHingeable")
                                        .setPosition(calculateButtonPositionX(2, calculateButtonWidth(2)), calculateButtonPositionY(7, calculateButtonHeight(rowCount)))
                                        .setSize(calculateButtonWidth(2),calculateButtonHeight(rowCount))
                                        .setLabel("Hingeable")
                                        .setVisible(false)
                                        .setValue(defaultSpringIsHingeable)
                                        .setGroup(ForceGeneration)
                                        .onChange(new CallbackListener() {
                                                public void controlEvent(CallbackEvent theEvent) {
                                                        SpringIsHingeableSelectorElementOnChange();
                                                    }
                                                })
                                            ;
                        Toggle springSnapToCenter = userInterface.addToggle("SpringSnapToCenter")
                                        .setPosition(calculateButtonPositionX(1, calculateButtonWidth(2)), calculateButtonPositionY(8, calculateButtonHeight(rowCount)))
                                        .setSize(calculateButtonWidth(2),calculateButtonHeight(rowCount))
                                        .setLabel("Snap to Center")
                                        .setVisible(false)
                                        .setValue(defaultSnapToCenter)
                                        .setGroup(ForceGeneration)
                                        .onChange(new CallbackListener() {
                                                public void controlEvent(CallbackEvent theEvent) {
                                                        SpringSnapToCenterSelectorElementOnChange();
                                                    }
                                                })
                                            ;

                        Toggle springSnapToEdge = userInterface.addToggle("SpringSnapToEdge")
                                        .setPosition(calculateButtonPositionX(2, calculateButtonWidth(2)), calculateButtonPositionY(8, calculateButtonHeight(rowCount)))
                                        .setSize(calculateButtonWidth(2),calculateButtonHeight(rowCount))
                                        .setLabel("Snap to Edge")
                                        .setVisible(false)
                                        .setValue(defaultSnapToEdge)
                                        .setGroup(ForceGeneration)
                                        .onChange(new CallbackListener() {
                                                public void controlEvent(CallbackEvent theEvent) {
                                                        SpringSnapToEdgeSelectorElementOnChange();
                                                    }
                                                })
                                            ;


                        Toggle rodIsHingeable = userInterface.addToggle("RodIsHingeable")
                                        .setPosition(calculateButtonPositionX(1, calculateButtonWidth(1)), calculateButtonPositionY(2, calculateButtonHeight(rowCount)))
                                        .setSize(calculateButtonWidth(1),calculateButtonHeight(rowCount))
                                        .setLabel("Hingeable")
                                        .setVisible(false)
                                        .setValue(defaultRodIsHingeable)
                                        .setGroup(ForceGeneration)
                                        .onChange(new CallbackListener() {
                                                public void controlEvent(CallbackEvent theEvent) {
                                                        RodIsHingeableSelectorElementOnChange();
                                                    }
                                                })
                                            ;
                        Toggle rodSnapToCenter = userInterface.addToggle("RodSnapToCenter")
                                        .setPosition(calculateButtonPositionX(1, calculateButtonWidth(2)), calculateButtonPositionY(3, calculateButtonHeight(rowCount)))
                                        .setSize(calculateButtonWidth(2),calculateButtonHeight(rowCount))
                                        .setLabel("Snap to Center")
                                        .setVisible(false)
                                        .setValue(defaultSnapToCenter)
                                        .setGroup(ForceGeneration)
                                        .onChange(new CallbackListener() {
                                                public void controlEvent(CallbackEvent theEvent) {
                                                        RodSnapToCenterSelectorElementOnChange();
                                                    }
                                                })
                                            ;

                        Toggle rodSnapToEdge = userInterface.addToggle("RodSnapToEdge")
                                        .setPosition(calculateButtonPositionX(2, calculateButtonWidth(2)), calculateButtonPositionY(3, calculateButtonHeight(rowCount)))
                                        .setSize(calculateButtonWidth(2),calculateButtonHeight(rowCount))
                                        .setLabel("Snap to Edge")
                                        .setVisible(false)
                                        .setValue(defaultSnapToEdge)
                                        .setGroup(ForceGeneration)
                                        .onChange(new CallbackListener() {
                                                public void controlEvent(CallbackEvent theEvent) {
                                                        RodSnapToEdgeSelectorElementOnChange();
                                                    }
                                                })
                                            ;


                        Slider motorTargetAngularVelocity = userInterface.addSlider("MotorTargetAngularVelocity")
                                        .setPosition(calculateButtonPositionX(1, calculateButtonWidth(1)), calculateButtonPositionY(2, calculateButtonHeight(rowCount)))
                                        .setSize(calculateButtonWidth(1),calculateButtonHeight(rowCount))
                                        .setLabel("Target Angular Velocity")
                                        .setVisible(false)
                                        .setRange(-10, 10)
                                        .setValue(defaultMotorTargetAngularVelocity)
                                        .setGroup(ForceGeneration)
                                        .onChange(new CallbackListener() {
                                                public void controlEvent(CallbackEvent theEvent) {
                                                        MotorTargetAngularVelocitySliderElementOnChange();
                                                    }
                                                })
                                            ;
                        Toggle motorDrawMotor = userInterface.addToggle("MotorDrawMotor")
                                        .setPosition(calculateButtonPositionX(1, calculateButtonWidth(2)), calculateButtonPositionY(3, calculateButtonHeight(rowCount)))
                                        .setSize(calculateButtonWidth(2),calculateButtonHeight(rowCount))
                                        .setLabel("Draw Motor")
                                        .setVisible(false)
                                        .setValue(defaultMotorDrawMotor)
                                        .setGroup(ForceGeneration)
                                        .onChange(new CallbackListener() {
                                                public void controlEvent(CallbackEvent theEvent) {
                                                        MotorDrawMotorSelectorElementOnChange();
                                                    }
                                                })
                                            ;
                        Toggle motorDrawMotorForce = userInterface.addToggle("MotorDrawMotorForce")
                                        .setPosition(calculateButtonPositionX(2, calculateButtonWidth(2)), calculateButtonPositionY(3, calculateButtonHeight(rowCount)))
                                        .setSize(calculateButtonWidth(2),calculateButtonHeight(rowCount))
                                        .setLabel("Draw Motor Force")
                                        .setVisible(false)
                                        .setValue(defaultMotorDrawMotorForce)
                                        .setGroup(ForceGeneration)
                                        .onChange(new CallbackListener() {
                                                public void controlEvent(CallbackEvent theEvent) {
                                                        MotorDrawMotorForceSelectorElementOnChange();
                                                    }
                                                })
                                            ;
/*------------------------------------ Editor Tab ----------------------------------------------- */
                Group editorGroup = userInterface.addGroup("EditorGroup")
                        .setPosition(calculateGroupPositionX(), calculateGroupPositionY())
                        .setBackgroundHeight(globalGroupHeight)
                        .setBarHeight(globalGroupBarHeight)
                        .setBackgroundColor(globalGroupColor)
                        .setWidth(globalGroupWidth)
                         //.disableCollapse()
                        .setTab("Editor")
                        ;

                        Toggle enableEditor = userInterface.addToggle("EditorEnableEditor")
                            .setPosition(calculateButtonPositionX(1, calculateButtonWidth(1)), calculateButtonPositionY(1, calculateButtonHeight(rowCount)))
                            .setSize(calculateButtonWidth(1),calculateButtonHeight(rowCount))
                            .setLabel("Enable Editor")
                            .setVisible(true)
                            .setValue(false)
                            .setGroup(editorGroup)
                            .onChange(new CallbackListener() {
                                    public void controlEvent(CallbackEvent theEvent) {
                                            EditorEnableEditorSelectorElementOnChange();
                                        }
                                    })
                                ;

/*
====================================================================================================
======================================== Formatting ================================================
====================================================================================================
*/

userInterface.getController("Circle").getCaptionLabel().align(ControlP5.CENTER, ControlP5.CENTER);
userInterface.getController("Box").getCaptionLabel().align(ControlP5.CENTER, ControlP5.CENTER);

userInterface.getController("RectangleWidth").getCaptionLabel().align(ControlP5.CENTER, ControlP5.CENTER);
userInterface.getController("RectangleHeight").getCaptionLabel().align(ControlP5.CENTER, ControlP5.CENTER);
userInterface.getController("CircleRadius").getCaptionLabel().align(ControlP5.CENTER, ControlP5.CENTER);

userInterface.getController("Density").getCaptionLabel().align(ControlP5.CENTER, ControlP5.CENTER);
userInterface.getController("Restitution").getCaptionLabel().align(ControlP5.CENTER, ControlP5.CENTER);

userInterface.getController("StrokeWeight").getCaptionLabel().align(ControlP5.RIGHT, ControlP5.CENTER);
userInterface.getController("FillColour").getCaptionLabel().align(ControlP5.CENTER, ControlP5.CENTER);
userInterface.getController("StrokeColour").getCaptionLabel().align(ControlP5.CENTER, ControlP5.CENTER);

userInterface.getController("RedStroke").getCaptionLabel().align(ControlP5.RIGHT, ControlP5.CENTER);
userInterface.getController("GreenStroke").getCaptionLabel().align(ControlP5.RIGHT, ControlP5.CENTER);
userInterface.getController("BlueStroke").getCaptionLabel().align(ControlP5.RIGHT, ControlP5.CENTER);

userInterface.getController("RedFill").getCaptionLabel().align(ControlP5.RIGHT, ControlP5.CENTER);
userInterface.getController("GreenFill").getCaptionLabel().align(ControlP5.RIGHT, ControlP5.CENTER);
userInterface.getController("BlueFill").getCaptionLabel().align(ControlP5.RIGHT, ControlP5.CENTER);

userInterface.getController("ColorBox").getCaptionLabel().align(ControlP5.RIGHT, ControlP5.CENTER);

userInterface.getController("isStatic").getCaptionLabel().align(ControlP5.CENTER, ControlP5.CENTER);
userInterface.getController("transStatic").getCaptionLabel().align(ControlP5.CENTER, ControlP5.CENTER);
userInterface.getController("rotStatic").getCaptionLabel().align(ControlP5.CENTER, ControlP5.CENTER);

userInterface.getController("Angle").getCaptionLabel().align(ControlP5.RIGHT, ControlP5.CENTER);
userInterface.getController("AngularVelocity").getCaptionLabel().align(ControlP5.RIGHT, ControlP5.CENTER);

userInterface.getController("AddGravity").getCaptionLabel().align(ControlP5.RIGHT, ControlP5.CENTER);

userInterface.getController("AddSpring").getCaptionLabel().align(ControlP5.CENTER, ControlP5.CENTER);
userInterface.getController("AddRod").getCaptionLabel().align(ControlP5.CENTER, ControlP5.CENTER);
userInterface.getController("AddMotor").getCaptionLabel().align(ControlP5.CENTER, ControlP5.CENTER);

userInterface.getController("SpringConstant").getCaptionLabel().align(ControlP5.RIGHT, ControlP5.CENTER);
userInterface.getController("SpringEquilibriumLength").getCaptionLabel().align(ControlP5.RIGHT, ControlP5.CENTER);
userInterface.getController("SpringDamping").getCaptionLabel().align(ControlP5.RIGHT, ControlP5.CENTER);

userInterface.getController("SpringLockToX").getCaptionLabel().align(ControlP5.CENTER, ControlP5.CENTER);
userInterface.getController("SpringLockToY").getCaptionLabel().align(ControlP5.CENTER, ControlP5.CENTER);

userInterface.getController("SpringIsPerfect").getCaptionLabel().align(ControlP5.CENTER, ControlP5.CENTER);
userInterface.getController("SpringIsHingeable").getCaptionLabel().align(ControlP5.CENTER, ControlP5.CENTER);

userInterface.getController("SpringSnapToCenter").getCaptionLabel().align(ControlP5.CENTER, ControlP5.CENTER);
userInterface.getController("SpringSnapToEdge").getCaptionLabel().align(ControlP5.CENTER, ControlP5.CENTER);


userInterface.getController("RodIsHingeable").getCaptionLabel().align(ControlP5.CENTER, ControlP5.CENTER);
userInterface.getController("RodSnapToCenter").getCaptionLabel().align(ControlP5.CENTER, ControlP5.CENTER);
userInterface.getController("RodSnapToEdge").getCaptionLabel().align(ControlP5.CENTER, ControlP5.CENTER);

userInterface.getController("MotorTargetAngularVelocity").getCaptionLabel().align(ControlP5.RIGHT, ControlP5.CENTER);
userInterface.getController("MotorDrawMotor").getCaptionLabel().align(ControlP5.CENTER, ControlP5.CENTER);
userInterface.getController("MotorDrawMotorForce").getCaptionLabel().align(ControlP5.CENTER, ControlP5.CENTER);





userInterface.getTab("default").hide();

       // TODO: IMPLEMENT A STARTING ANGLE FOR THE RIGIDRODS, SO OBJECTS CAN BE JOINTED AT
       //ANGLES AND STAY FIXED

    }

/*
====================================================================================================
======================================== Helper Methods ============================================
====================================================================================================
*/
   public int calculateButtonWidth(int buttonCount) {
        return (globalGroupWidth - 2 * globalGroupPaddingX - (buttonCount - 1) * globalInterElementPaddingX) / buttonCount;
     }

    public int calculateButtonHeight(int rowCount) {
     rowCount--;
    return (globalGroupHeight - 2 * globalGroupPaddingY - (rowCount - 1) * globalInterElementPaddingY) / rowCount;
    }

    public int calculateButtonPositionX(int buttonNumber, int buttonWidth) {
     buttonNumber--;
     return  globalGroupPaddingX + buttonNumber * (buttonWidth + globalInterElementPaddingX);
    }
    public int calculateButtonPositionY(int rowNumber, int buttonHeight) {
     rowNumber--;
     return globalGroupPaddingX + rowNumber * (buttonHeight + globalInterElementPaddingY);
    }

    public int calculateGroupPositionX() {
     return width - globalGroupWidth - globalScreenGroupPaddingX;
    }
    public int calculateGroupPositionY() {
     return globalScreenGroupPaddingY;
    }

    public void getActiveTab() {
        if(userInterface.getTab("default").isActive()) {
            interactivityListener.setGenerateRigidbodies(false);
            interactivityListener.setGenerateForces(false);
        } else if(userInterface.getTab("Rigidbodies").isActive()) {
            interactivityListener.setGenerateRigidbodies(true);
            interactivityListener.setGenerateForces(false);
        } else if(userInterface.getTab("Forces").isActive()) {
            interactivityListener.setGenerateRigidbodies(false);
            interactivityListener.setGenerateForces(true);
        }
    }

/*
====================================================================================================
======================================= Element Interactivity ======================================
====================================================================================================
*/
/*--------------------------------- Rigidbodies Tab ----------------------------------------------*/
/*------------------------------ Global Shape Selector Methods -----------------------------------*/
private void ShapeSelectorElementOnSelect() {

    interactivityListener.setGenerateRigidbodies(true);
    interactivityListener.setGenerateForces(false);


    userInterface.getController("Density").setVisible(true);
    userInterface.getController("Restitution").setVisible(true);

    if(isFillColourSelectedDefault) {
        userInterface.getController("RedFill").setVisible(true);
        userInterface.getController("GreenFill").setVisible(true);
        userInterface.getController("BlueFill").setVisible(true);

        userInterface.getController("RedStroke").setVisible(false);
        userInterface.getController("GreenStroke").setVisible(false);
        userInterface.getController("BlueStroke").setVisible(false);
           
        //Default enabled color selector
        userInterface.getController("FillColour").setValue(1);
    } else {
        userInterface.getController("RedFill").setVisible(false);
        userInterface.getController("GreenFill").setVisible(false);
        userInterface.getController("BlueFill").setVisible(false);

        userInterface.getController("RedStroke").setVisible(true);
        userInterface.getController("GreenStroke").setVisible(true);
        userInterface.getController("BlueStroke").setVisible(true);
            
        //Default enabled color selector
        userInterface.getController("StrokeColour").setValue(1);
    }

    userInterface.getController("ColorBox").setVisible(true);

    userInterface.getController("FillColour").setVisible(true);
    userInterface.getController("StrokeColour").setVisible(true);
    userInterface.getController("StrokeWeight").setVisible(true);
                                                            
    userInterface.getController("isStatic").setVisible(true);
    userInterface.getController("transStatic").setVisible(true);
    userInterface.getController("rotStatic").setVisible(true);

    userInterface.getController("Angle").setVisible(true);
    userInterface.getController("AngularVelocity").setVisible(true);
    userInterface.getController("AddGravity").setVisible(true);
    
}

private void ShapeSelectorElementOnDeselect() {

    userInterface.getController("RectangleWidth").setVisible(false);
    userInterface.getController("RectangleHeight").setVisible(false);

    userInterface.getController("CircleRadius").setVisible(false);

    userInterface.getController("Density").setVisible(false);
    userInterface.getController("Restitution").setVisible(false);

    userInterface.getController("RedFill").setVisible(false);
    userInterface.getController("GreenFill").setVisible(false);
    userInterface.getController("BlueFill").setVisible(false);

    userInterface.getController("RedStroke").setVisible(false);
    userInterface.getController("GreenStroke").setVisible(false);
    userInterface.getController("BlueStroke").setVisible(false);

    userInterface.getController("ColorBox").setVisible(false);

    userInterface.getController("StrokeWeight").setVisible(false);
    userInterface.getController("FillColour").setVisible(false);
    userInterface.getController("StrokeColour").setVisible(false);

    userInterface.getController("isStatic").setVisible(false);
    userInterface.getController("transStatic").setVisible(false);
    userInterface.getController("rotStatic").setVisible(false);

    userInterface.getController("Angle").setVisible(false);
    userInterface.getController("AngularVelocity").setVisible(false);

    userInterface.getController("AddGravity").setVisible(false);
}
/*-------------------------------- Global Colouring Element Methods ------------------------------*/
 private void ColouringElementOnDeselect() {
     if(userInterface.getController("FillColour").getValue() == 0
     && userInterface.getController("StrokeColour").getValue() == 0){
         
        userInterface.getController("RedFill").setVisible(false);
        userInterface.getController("GreenFill").setVisible(false);
        userInterface.getController("BlueFill").setVisible(false);

        userInterface.getController("RedStroke").setVisible(false);
        userInterface.getController("GreenStroke").setVisible(false);
        userInterface.getController("BlueStroke").setVisible(false);

        userInterface.getController("ColorBox").setVisible(false);
     }
 }

/* --------------------------------- Circle Shape Selector Element -------------------------------*/

private void CircleShapeSelectorOnChange() {
    if(userInterface.getController("Circle").getValue() == 1){
        ShapeSelectorElementOnSelect();
        CircleShapeSelectorElementOnSelect();
        CircleShapeSelectorInteractivityListener();

    } else if(userInterface.getController("Circle").getValue() == 0
            && userInterface.getController("Box").getValue() == 0){
        
        ShapeSelectorElementOnDeselect();
    }
}

private void CircleShapeSelectorElementOnSelect() {

    userInterface.getController("Box").setValue(0);

    userInterface.getController("RectangleWidth").setVisible(false);
    userInterface.getController("RectangleHeight").setVisible(false);
    userInterface.getController("CircleRadius").setVisible(true);
}

private void CircleShapeSelectorInteractivityListener() {

    interactivityListener.setShapeType(ShapeType.CIRCLE);
}

/* --------------------------------- Rectangle Shape Selector Element ----------------------------*/
private void RectangleShapeSelectorOnChange() {
    if(userInterface.getController("Box").getValue() == 1){
        
        ShapeSelectorElementOnSelect();
        RectangleShapeSelectorElementOnSelect();
        RectangleShapeSelectorElementInteractivityListener();

    } else if(userInterface.getController("Circle").getValue() == 0
            && userInterface.getController("Box").getValue() == 0){
        
        ShapeSelectorElementOnDeselect();
    }
}
private void RectangleShapeSelectorElementOnSelect() {

    userInterface.getController("Circle").setValue(0);

    userInterface.getController("RectangleWidth").setVisible(true);
    userInterface.getController("RectangleHeight").setVisible(true);


    userInterface.getController("CircleRadius").setVisible(false);
}


private void RectangleShapeSelectorElementInteractivityListener() {

    interactivityListener.setShapeType(ShapeType.BOX);

}

/*-------------------------------------- Density Element -----------------------------------------*/
private void DensityElementOnChange() {

    float density = userInterface.getController("Density").getValue();
    interactivityListener.setDensity(density);
}

/*-------------------------------------- Restitution Element -------------------------------------*/
private void RestitutionElementOnChange() {

    float restitution = userInterface.getController("Restitution").getValue();
    interactivityListener.setRestitution(restitution);
}

/*-------------------------------------- Box Width Element ---------------------------------------*/
private void RectangleWidthElementOnChange() {
    if(userInterface.getController("Box").getValue() == 1){

        float width = userInterface.getController("RectangleWidth").getValue();
        interactivityListener.setWidth(width);
    }
}

/*-------------------------------------- Box Height Element --------------------------------------*/
private void RectangleHeightElementOnChange() {
    if(userInterface.getController("Box").getValue() == 1) {

        float height = userInterface.getController("RectangleHeight").getValue();
        interactivityListener.setHeight(height);
    }
}

/*-------------------------------------- Circle Radius Element -----------------------------------*/
private void CircleRadiusElementOnChange() {
    if(userInterface.getController("Circle").getValue() == 1) {

        float radius = userInterface.getController("CircleRadius").getValue();
        interactivityListener.setRadius(radius);
    }
}

/*--------------------------------- Fill Colour Selector Element ---------------------------------*/
private void FillColourSelectorOnChange() {
    if(userInterface.getController("FillColour").getValue() == 1) {

        FillColourElementOnSelect();
    } else if (userInterface.getController("FillColour").getValue() == 0
            && userInterface.getController("StrokeColour").getValue() == 0) {
                
                ColouringElementOnDeselect();
    }
}

private void FillColourElementOnSelect() {

        userInterface.getController("StrokeColour").setValue(0);

        userInterface.getController("RedFill").setVisible(true);
        userInterface.getController("GreenFill").setVisible(true);
        userInterface.getController("BlueFill").setVisible(true);

        userInterface.getController("RedStroke").setVisible(false);
        userInterface.getController("GreenStroke").setVisible(false);
        userInterface.getController("BlueStroke").setVisible(false);

        userInterface.getController("ColorBox").setVisible(true);
}

/*--------------------------------- Stroke Colour Selector Element -------------------------------*/
private void StrokeColourSelectorOnChange() {

    if(userInterface.getController("StrokeColour").getValue() == 1) {

        StrokeColourElementOnSelect();
    } else if (userInterface.getController("FillColour").getValue() == 0
            && userInterface.getController("StrokeColour").getValue() == 0) {

                ColouringElementOnDeselect();
    }
}

private void StrokeColourElementOnSelect() {

    userInterface.getController("FillColour").setValue(0);

    userInterface.getController("RedStroke").setVisible(true);
    userInterface.getController("GreenStroke").setVisible(true);
    userInterface.getController("BlueStroke").setVisible(true);

    userInterface.getController("RedFill").setVisible(false);
    userInterface.getController("GreenFill").setVisible(false);
    userInterface.getController("BlueFill").setVisible(false);
    userInterface.getController("ColorBox").setVisible(true);
}

/*--------------------------------- Fill Slider Elements -----------------------------------------*/
private void FillSliderElementOnChange() {

    int red = (int)userInterface.getController("RedFill").getValue();
    int green = (int)userInterface.getController("GreenFill").getValue();
    int blue = (int)userInterface.getController("BlueFill").getValue();

    userInterface.getController("ColorBox").setColorForeground(color(red, green, blue));
    userInterface.getController("ColorBox").setColorActive(color(red, green, blue));

    interactivityListener.setFillColor(new PVector(red, green, blue));
}

/*--------------------------------- Stroke Slider Elements ------------------------------------*/
private void StrokeSliderElementOnChange() {

    int red = (int)userInterface.getController("RedStroke").getValue();
    int green = (int)userInterface.getController("GreenStroke").getValue();
    int blue = (int)userInterface.getController("BlueStroke").getValue();
    
    userInterface.getController("ColorBox").setColorForeground(color(red, green, blue));
    userInterface.getController("ColorBox").setColorActive(color(red, green, blue));
    interactivityListener.setStrokeColor(new PVector(red, green, blue));
}


/*--------------------------------- Stroke Weight Slider Element ---------------------------------*/
private void StrokeWeightElementOnChange() {

    float strokeWeight = userInterface.getController("StrokeWeight").getValue();
    interactivityListener.setStrokeWeight(strokeWeight);
}

/*--------------------------------- IsStatic Selector Element ------------------------------------*/
private void IsStaticSelectorElementOnChange() {

     if(userInterface.getController("isStatic").getValue() == 1){
        
        userInterface.getController("transStatic").setValue(0);
        userInterface.getController("rotStatic").setValue(0);

        interactivityListener.setIsTranslationallyStatic(false);
        interactivityListener.setIsRotationallyStatic(false);

        interactivityListener.setIsStatic(true);

    }
    else {

        interactivityListener.setIsStatic(false);
    }
}
/*--------------------------------- IsTransStatic Selector Element --------------------------------*/
private void IsTransStaticSelectorElementOnChange() {

    if(userInterface.getController("transStatic").getValue() == 1){

        userInterface.getController("rotStatic").setValue(0);
        userInterface.getController("isStatic").setValue(0);

        interactivityListener.setIsStatic(false);
        interactivityListener.setIsRotationallyStatic(false);

        interactivityListener.setIsTranslationallyStatic(true);

    } else {
        
        interactivityListener.setIsTranslationallyStatic(false);
    }
}

/*--------------------------------- IsRotStatic Selector Element ----------------------------------*/
private void IsRotStaticSelectorElementOnChange() {

    if(userInterface.getController("rotStatic").getValue() == 1){

        userInterface.getController("transStatic").setValue(0);
        userInterface.getController("isStatic").setValue(0);

        interactivityListener.setIsTranslationallyStatic(false);
        interactivityListener.setIsStatic(false);

        interactivityListener.setIsRotationallyStatic(true);

    } else {
        
        interactivityListener.setIsRotationallyStatic(false);
    }
}

/*--------------------------------- Angle Slider Element -----------------------------------------*/
private void AngleSliderElementOnChange() {

    float angle = userInterface.getController("Angle").getValue();
    interactivityListener.setAngle(radians(angle));
}

/*--------------------------------- Angular Velocity Slider Element -------------------------------*/
private void AngularVelocitySliderElementOnChange() {

    float angularVelocity = userInterface.getController("AngularVelocity").getValue();
    interactivityListener.setAngularVelocity(angularVelocity);
}
/*--------------------------------- Add Gravity Selector Element ----------------------------------*/
private void AddGravitySelectorElementOnChange() {
    
        if(userInterface.getController("AddGravity").getValue() == 1) {
    
            interactivityListener.setAddGravity(true);
        } else {
    
            interactivityListener.setAddGravity(false);
        }
}

/*--------------------------------- Forces Tab ---------------------------------------------------*/

private void ForceSelectorElementDeselect() {

    /*-------------------------------- Spring Elements -----------------------------------*/
    userInterface.getController("SpringConstant").setVisible(false);
    userInterface.getController("SpringEquilibriumLength").setVisible(false);
    userInterface.getController("SpringDamping").setVisible(false);

    userInterface.getController("SpringLockToX").setVisible(false);
    userInterface.getController("SpringLockToY").setVisible(false);

    userInterface.getController("SpringIsPerfect").setVisible(false);
    userInterface.getController("SpringIsHingeable").setVisible(false);

    userInterface.getController("SpringSnapToCenter").setVisible(false);
    userInterface.getController("SpringSnapToEdge").setVisible(false);

    /*-------------------------------- Rod Elements --------------------------------------*/
    userInterface.getController("RodIsHingeable").setVisible(false);
    userInterface.getController("RodSnapToCenter").setVisible(false);
    userInterface.getController("RodSnapToEdge").setVisible(false);


    /*-------------------------------- Motor Elements ------------------------------------*/
    userInterface.getController("MotorTargetAngularVelocity").setVisible(false);
    userInterface.getController("MotorDrawMotor").setVisible(false);
    userInterface.getController("MotorDrawMotorForce").setVisible(false);

}
/*--------------------------------- Spring Force Selector Element --------------------------------*/
private void SpringForceSelectorOnChange() {
    if(userInterface.getController("AddSpring").getValue() == 1) {

        ForceSelectorElementDeselect();
        interactivityListener.setForceType(ForceType.SPRING);
        interactivityListener.setGenerateRigidbodies(false);
        interactivityListener.setGenerateForces(true);

        userInterface.getController("AddRod").setValue(0);
        userInterface.getController("AddMotor").setValue(0);

        userInterface.getController("SpringConstant").setVisible(true);
        userInterface.getController("SpringEquilibriumLength").setVisible(true);
        userInterface.getController("SpringDamping").setVisible(true);

        userInterface.getController("SpringLockToX").setVisible(true);
        userInterface.getController("SpringLockToY").setVisible(true);

        userInterface.getController("SpringIsPerfect").setVisible(true);
        userInterface.getController("SpringIsHingeable").setVisible(true);

        userInterface.getController("SpringSnapToCenter").setVisible(true);
        userInterface.getController("SpringSnapToEdge").setVisible(true);


    } else if(userInterface.getController("AddSpring").getValue() == 0 && userInterface.getController("AddRod").getValue() == 0 && userInterface.getController("AddMotor").getValue() == 0) {

            ForceSelectorElementDeselect();
            interactivityListener.setGenerateRigidbodies(false);
            interactivityListener.setGenerateForces(false);
    }
}
/*--------------------------------- Rod Force Selector Element -----------------------------------*/
private void RodForceSelectorOnChange() {

        if(userInterface.getController("AddRod").getValue() == 1) {
        
        ForceSelectorElementDeselect();
        interactivityListener.setForceType(ForceType.ROD);
        interactivityListener.setGenerateRigidbodies(false);
        interactivityListener.setGenerateForces(true);

        userInterface.getController("AddSpring").setValue(0);
        userInterface.getController("AddMotor").setValue(0);

        userInterface.getController("RodIsHingeable").setVisible(true);
        userInterface.getController("RodSnapToCenter").setVisible(true);
        userInterface.getController("RodSnapToEdge").setVisible(true);

    } else if(userInterface.getController("AddSpring").getValue() == 0 && userInterface.getController("AddRod").getValue() == 0 && userInterface.getController("AddMotor").getValue() == 0) {

            ForceSelectorElementDeselect();
            interactivityListener.setGenerateRigidbodies(false);
            interactivityListener.setGenerateForces(false);
    }
}
/*--------------------------------- Motor Force Selector Element ---------------------------------*/
private void MotorForceSelectorOnChange() {
    if(userInterface.getController("AddMotor").getValue() == 1) {

        ForceSelectorElementDeselect();
        interactivityListener.setForceType(ForceType.MOTOR);
        interactivityListener.setGenerateRigidbodies(false);
        interactivityListener.setGenerateForces(true);

        interactivityListener.setSnapToCenter(true);
        interactivityListener.setSnapToEdge(false);

        userInterface.getController("AddSpring").setValue(0);
        userInterface.getController("AddRod").setValue(0);

        userInterface.getController("MotorTargetAngularVelocity").setVisible(true);
        userInterface.getController("MotorDrawMotor").setVisible(true);
        userInterface.getController("MotorDrawMotorForce").setVisible(true);

    } else if(userInterface.getController("AddSpring").getValue() == 0 && userInterface.getController("AddRod").getValue() == 0 && userInterface.getController("AddMotor").getValue() == 0) {
            ForceSelectorElementDeselect();
            interactivityListener.setGenerateRigidbodies(false);
            interactivityListener.setGenerateForces(false);
    }

}
/*--------------------------------- Spring Constant Slider Element --------------------------------*/
private void SpringConstantSliderElementOnChange() {
    float springConstant = userInterface.getController("SpringConstant").getValue();
    interactivityListener.setSpringConstant(springConstant);
}
/*--------------------------------- Spring Equilibrium Length Slider Element ----------------------*/
private void SpringEquilibriumLengthSliderElementOnChange() {
    float springEquilibriumLength = userInterface.getController("SpringEquilibriumLength").getValue();
    interactivityListener.setSpringEquilibriumLength(springEquilibriumLength);
}
/*--------------------------------- Spring Damping Slider Element --------------------------------*/
private void SpringDampingSliderElementOnChange() {
    float springDamping = userInterface.getController("SpringDamping").getValue();
    interactivityListener.setSpringDamping(springDamping);
}
/*--------------------------------- Spring Lock To X Selector Element -----------------------------*/
private void SpringLockToXSelectorElementOnChange() {
    boolean lockToX = userInterface.getController("SpringLockToX").getValue() == 1 ? true : false;
    interactivityListener.setLockToXAxis(lockToX);
}
/*--------------------------------- Spring Lock To Y Selector Element -----------------------------*/
private void SpringLockToYSelectorElementOnChange() {
    boolean lockToY = userInterface.getController("SpringLockToY").getValue() == 1 ? true : false;
    interactivityListener.setLockToYAxis(lockToY);
}

/*--------------------------------- Spring Is Perfect Selector Element ----------------------------*/
private void SpringIsPerfectSelectorElementOnChange() {
    boolean isPerfect = userInterface.getController("SpringIsPerfect").getValue() == 1 ? true : false;
    interactivityListener.setSpringIsPerfect(isPerfect);
}

/*--------------------------------- Spring Is Hingeable Selector Element --------------------------*/
private void SpringIsHingeableSelectorElementOnChange() {
    boolean isHingeable = userInterface.getController("SpringIsHingeable").getValue() == 1 ? true : false;
    interactivityListener.setSpringIsHingeable(isHingeable);
}
/*--------------------------------- Spring Snap To Center Selector Element ------------------------*/
private void SpringSnapToCenterSelectorElementOnChange() {
    if(userInterface.getController("SpringSnapToCenter").getValue() == 1) {
        userInterface.getController("SpringSnapToEdge").setValue(0);
    }
    boolean snapToCenter = userInterface.getController("SpringSnapToCenter").getValue() == 1 ? true : false;
    interactivityListener.setSnapToCenter(snapToCenter);
}

/*--------------------------------- Spring Snap To Edge Selector Element --------------------------*/
private void SpringSnapToEdgeSelectorElementOnChange() {

    if(userInterface.getController("SpringSnapToEdge").getValue() == 1) {
        userInterface.getController("SpringSnapToCenter").setValue(0);
    }
    boolean snapToEdge = userInterface.getController("SpringSnapToEdge").getValue() == 1 ? true : false;
    interactivityListener.setSnapToEdge(snapToEdge);
}



/*--------------------------------- Rod Is Hingeable Selector Element -----------------------------*/
private void RodIsHingeableSelectorElementOnChange() {
    boolean isHingeable = userInterface.getController("RodIsHingeable").getValue() == 1 ? true : false;
    interactivityListener.setRodIsHingeable(isHingeable);
}

/*--------------------------------- Rod Snap To Center Selector Element ---------------------------*/
private void RodSnapToCenterSelectorElementOnChange() {
    if(userInterface.getController("RodSnapToCenter").getValue() == 1) {
        userInterface.getController("RodSnapToEdge").setValue(0);
    }
    boolean snapToCenter = userInterface.getController("RodSnapToCenter").getValue() == 1 ? true : false;
    interactivityListener.setSnapToCenter(snapToCenter);

}

/*--------------------------------- Rod Snap To Edge Selector Element -----------------------------*/
private void RodSnapToEdgeSelectorElementOnChange() {
    if(userInterface.getController("RodSnapToEdge").getValue() == 1) {

        userInterface.getController("RodSnapToCenter").setValue(0);
    }

    boolean snapToEdge = userInterface.getController("RodSnapToEdge").getValue() == 1 ? true : false;
    interactivityListener.setSnapToEdge(snapToEdge);

}



/*--------------------------------- Motor Target Angular Velocity Slider Element -------------------*/
private void MotorTargetAngularVelocitySliderElementOnChange() {
    float targetAngularVelocity = userInterface.getController("MotorTargetAngularVelocity").getValue();
    interactivityListener.setMotorTargetAngularVelocity(targetAngularVelocity);
}

/*--------------------------------- Motor Draw Motor Selector Element -----------------------------*/
private void MotorDrawMotorSelectorElementOnChange() {
    boolean drawMotor = userInterface.getController("MotorDrawMotor").getValue() == 1 ? true : false;
    interactivityListener.setMotorDrawMotor(drawMotor);
}
/*--------------------------------- Motor Draw Motor Force Selector Element -----------------------*/
private void MotorDrawMotorForceSelectorElementOnChange() {
    boolean drawMotorForce = userInterface.getController("MotorDrawMotorForce").getValue() == 1 ? true : false;
    interactivityListener.setMotorDrawMotorForce(drawMotorForce);
}

/* --------------------------------- Editor Tab --------------------------------------------------*/
private void EditorEnableEditorSelectorElementOnChange() {
    if(userInterface.getController("EditorEnableEditor").getValue() == 1) {
        interactivityListener.setEnableEditor(true);
    } else {
        interactivityListener.setEnableEditor(false);
    }
}

/*
====================================================================================================
======================================== Getters and Setters =======================================
====================================================================================================
*/

public int getGroupHeight() {
    return this.globalGroupHeight;
}
public int getGroupWidth() {
    return this.globalGroupWidth;
}

    }
public class Gravity implements ForceRegistry {
  private final Rigidbody rigidbody;

  public Gravity(Rigidbody rigidbody) {
    this.rigidbody = rigidbody;
  }

  @Override
  public PVector getForce(Rigidbody rigidbody, PVector position) {
    return PVector.mult(GRAVITY_VECTOR, rigidbody.getMass());
  }

  @Override
  public void draw() {
    // Do nothing
  }

    @Override
    public PVector getApplicationPoint(Rigidbody rigidbody, PVector position) {
      return rigidbody.getPosition();
    }

}


public class InteractivityListener {

  public PVector position;
  public float zoom;

  public boolean showCursorTrail = true;
  public int lastTime;
  public ArrayList<PVector> trail = new ArrayList<PVector>();
/*
====================================================================================================
================================= GUI Variables for Rigidbody Generation ===========================
====================================================================================================
*/
  private float width;
  private float height;

  private float softbodyWidth;
  private float softbodyHeight;

  private PVector[] vertices;

  private float radius;
  private PVector rigidbodyPosition;

  private float density;
  private float restitution;

  
  private float angle;
  private float angularVelocity;

  private boolean generateRigidbodies = true;
  private boolean generateForces = false;

    //TODO IMPLEMENT THIS
  private boolean showObjectTrail;

  private boolean isStatic;
  private boolean isTranslationallyStatic;
  private boolean isRotationallyStatic;
  private boolean isCollidable;

  private boolean addGravity;

  private float strokeWeight;
  private PVector strokeColor;
  private PVector fillColor;

  private ShapeType shapeType = ShapeType.SOFTBODY;
  

  public InteractivityListener() {
    position = new PVector(-50, -50);
    zoom = 10f;
  }
/*
====================================================================================================
=============================== GUI Variables for Force Generation =================================
====================================================================================================
*/

/*------------------------------ Global Variables ----------------------------*/
    private ForceType forceType;


    private ArrayList<Rigidbody> selectedRigidbodies = new ArrayList<Rigidbody>();

    private boolean isFirstClickOnRigidbody = false;
    private boolean drawForces = false;
    private boolean oneRigidbodySelected = false;
    private boolean twoRigidbodiesSelected = false;

    private int opacity = 166;
    private Rigidbody tempBody;

    private Rigidbody selectedRigidbody;
    private Rigidbody selectedRigidbody1;
    private Rigidbody selectedRigidbody2;

    private PVector anchorPoint;
    private PVector localAnchorA;

    private boolean snapToCenter;
    private boolean snapToEdge;
    private boolean snapToVertices;

    private boolean enableEditor;

/*----------------------------- Spring Variables -----------------------------*/

    private boolean lockTranslationToXAxis;
    private boolean lockTranslationToYAxis;
  
    private boolean isPerfectSpring;

    private float equilibriumLength;
    private float springLength;
    private float springConstant;
    private float springDamping;

    private boolean isSpringHingeable;


/*--------------------------- Rod Variables ---------------------------------*/
    
    private boolean isRodHingeable;
    private boolean isTwoBodyRod;

/*--------------------------- Motor Variables ----------------------------*/
    private float motorTargetAngularVelocity;
    private boolean motorDrawMotor;
    private boolean motorDrawMotorForce;

/*
====================================================================================================
======================================= GUI Methods ================================================
====================================================================================================
*/

  public void zoom(float amount, float mouseX, float mouseY) {
    PVector mouseBeforeZoom = screenToWorld(mouseX, mouseY);
    zoom *= amount;
    PVector mouseAfterZoom = screenToWorld(mouseX, mouseY);
    PVector shift = PVector.sub(mouseBeforeZoom, mouseAfterZoom);
    position.add(shift);
}


  public void applyTransform() {
    translate(width/2, height/2);
    scale(zoom);
    translate(-position.x, -position.y);
  }

  public void resetTransform() {
    translate(position.x, position.y);
    scale(1/zoom);
    translate(-width/2, -height/2);
  }
  
   public PVector screenToWorld(float x, float y) {
    float worldX = (x - width/2) / zoom + position.x;
    float worldY = (y - height/2) / zoom + position.y;
    return new PVector(worldX, worldY);
  }

  public void zoom(float amount) {
    zoom *= amount;
  }

  public void move(float dx, float dy) {
    position.x += dx / zoom;
    position.y += dy / zoom;
  }

  public float[] getCameraExtents(float padding) {

  float left = screenToWorld(padding, padding).x;
  float right = screenToWorld(width - padding, padding).x;
  float top = screenToWorld(padding, padding).y;
  float bottom = screenToWorld(width - padding, height - padding).y;

  return new float[] {left, right, top, bottom};
}
//Overloaded method that returns the camera extents as PVector coordinates
public PVector[] getWorldBoundsWithPadding(float padding) {
  PVector topLeft = screenToWorld(padding, padding);
  PVector topRight = screenToWorld(width - padding, padding);
  PVector bottomLeft = screenToWorld(padding, height - padding);
  PVector bottomRight = screenToWorld(width - padding, height - padding);

  return new PVector[] {topLeft, topRight, bottomLeft, bottomRight};
}

public Rigidbody getClickedRigidbody() {
    PVector mousePosition = interactivityListener.screenToWorld(mouseX, mouseY);
    for (Rigidbody rigidbody : rigidbodyList) {
        if (rigidbody.contains(mousePosition.x, mousePosition.y)) {
            return rigidbody;
        }
    }
    return null;
}





/*
====================================================================================================
======================================= Generation Methods =========================================
====================================================================================================
*/

/*
====================================================================================================
======================================= Rigidbody Generation Methods ================================
====================================================================================================
*/
public void GenerateRigidbody() {
    if(getClickedRigidbody() == null){
     if(this.shapeType == ShapeType.BOX) {

            Rigidbody rigidbody = RigidbodyGenerator.CreateBoxBody( this.width, this.height,
                                                                    this.density, this.restitution,
                                                                    this.isStatic, this.isCollidable,
                                                                    this.strokeWeight, this.strokeColor,
                                                                    this.fillColor);
                                                    

            //YOU CAN CHANGE THIS TO EITHER MOUSE COORDS OR THE NEW THING UR TRYING
            rigidbody.SetInitialPosition(screenToWorld(mouseX, mouseY));
            rigidbody.setIsTranslationallyStatic(this.isTranslationallyStatic);
            rigidbody.setIsRotationallyStatic(this.isRotationallyStatic);
            rigidbody.RotateTo(this.angle);
            rigidbody.setAngularVelocity(this.angularVelocity);

            if(this.addGravity) {
                rigidbody.addForceToForceRegistry(new Gravity(rigidbody));
            }

            AddBodyToBodyEntityList(rigidbody);
  
        }
        if(this.shapeType == ShapeType.CIRCLE) {

            Rigidbody rigidbody = RigidbodyGenerator.CreateCircleBody(this.radius, this.density,
                                                                      this.restitution, this.isStatic,
                                                                      this.isCollidable, this.strokeWeight,
                                                                      this.strokeColor, this.fillColor);

                                        
            //SAME GOES FOR HERE
            rigidbody.SetInitialPosition(screenToWorld(mouseX, mouseY));
            rigidbody.setIsTranslationallyStatic(this.isTranslationallyStatic);
            rigidbody.setIsRotationallyStatic(this.isRotationallyStatic);
            rigidbody.RotateTo(this.angle);
            rigidbody.setAngularVelocity(this.angularVelocity);

            if(this.addGravity) {
                rigidbody.addForceToForceRegistry(new Gravity(rigidbody));
            }

            AddBodyToBodyEntityList(rigidbody);
        }

        if(this.shapeType == ShapeType.SOFTBODY) {
            Softbody softbody = new Softbody(screenToWorld(mouseX, mouseY), 0.0f, this.softbodyWidth, this.softbodyHeight);
            softbody.CreateBoxSoftbody();

        }

    }
}

/*
====================================================================================================
======================================= Force Generation Methods ===================================
====================================================================================================
*/


public void addSelectedRigidbody() {
    //Just in case
    if(this.selectedRigidbodies.size() > 2) {
        this.selectedRigidbodies.clear();
    }
    this.selectedRigidbodies.add(getClickedRigidbody());

    if(this.selectedRigidbodies.size() == 1) {
        firstMouseClickInformation();
    }
}

public PVector getMouseCoordinatesOverRigidbody() {
    if(!IsMouseOverUI()) {
        Rigidbody rigidbody = getClickedRigidbody();
        PVector mousePos = screenToWorld(mouseX, mouseY);
        if(rigidbody != null) {
            PVector localAnchorA = PhysEngMath.SnapController(this, rigidbody, mousePos);
            PVector worldAnchorA = PhysEngMath.Transform(localAnchorA, rigidbody.getPosition(), rigidbody.getAngle());
            return worldAnchorA.copy();
        } else {
            return mousePos;
        }
    } else {
        return null;
    }
}

public void drawMouseOverRigidbody() {

    Rigidbody rigidbody = getClickedRigidbody();
    PVector coordinate = getMouseCoordinatesOverRigidbody();

    fill(255, 0, 0);
    strokeWeight(0.1f);
    stroke(255, 0, 0);
    ellipse(coordinate.x, coordinate.y, 0.1f, 0.1f);

    if(showCursorTrail) {
        trail.add(new PVector(coordinate.x, coordinate.y));

    // If the trail is too long, remove the oldest position
    if (trail.size() > 20) {
        trail.remove(0);
    }

    // Draw the trail
    noFill();
    stroke(255, 0, 0);
    strokeWeight(0.1f);
    beginShape();
    for (int i = 0; i < trail.size(); i++) {
        if (i == 0 || i == trail.size() - 1) {
            // The first and last points are control points and are not part of the actual curve
            curveVertex(trail.get(i).x, trail.get(i).y);
        } else {
            curveVertex(trail.get(i).x, trail.get(i).y);
        }
    }
    endShape();

    // Draw the current mouse position
    fill(255, 0, 0);
    ellipse(coordinate.x, coordinate.y, 0.1f, 0.1f);
    }
}

public void drawInteractions() {
    drawMouseOverRigidbody();
    if(this.generateForces){
        drawForces();
    } else if(this.generateRigidbodies) {
        drawBodies();
    }
}

public void drawBodies() {
    if(this.generateRigidbodies) {

        PVector mouseCoordinates = screenToWorld(mouseX, mouseY);
        pushMatrix();
        translate(mouseCoordinates.x, mouseCoordinates.y);
        rotate(this.angle);

        if(this.shapeType == ShapeType.CIRCLE) {

            float diameter = this.radius * 2.0f;
            fill(this.fillColor.x, this.fillColor.y, this.fillColor.z, this.opacity);
            strokeWeight(this.strokeWeight);
            stroke(this.strokeColor.x, this.strokeColor.y, this.strokeColor.z, this.opacity);
            ellipseMode(CENTER);

            ellipse(0, 0, diameter,  diameter);

            PVector va = new PVector();
            PVector vb = new  PVector(radius, 0);
            va = PhysEngMath.Transform(va, new PVector(), this.angle);
            vb = PhysEngMath.Transform(vb, new PVector(), this.angle);
            line(va.x, va.y, vb.x, vb.y);

        } else if (this.shapeType == ShapeType.BOX) {

            fill(this.fillColor.x, this.fillColor.y, this.fillColor.z, this.opacity);
            stroke(this.strokeColor.x, this.strokeColor.y, this.strokeColor.z, this.opacity);
            strokeWeight(this.strokeWeight);
            rectMode(CENTER);
            rect(0, 0, this.width, this.height);
        }
    }
    popMatrix();
}

public void drawForces() {
    PVector worldAnchorA;
    PVector worldAnchorB;

    if(selectedRigidbodies.size() > 0) {
        if(isFirstClickOnRigidbody) {
            worldAnchorA = PhysEngMath.Transform(this.localAnchorA, this.tempBody.getPosition(), this.tempBody.getAngle());
            worldAnchorB = getMouseCoordinatesOverRigidbody();
        } else {
            worldAnchorA = this.anchorPoint;
            worldAnchorB = getMouseCoordinatesOverRigidbody();
        }
        
        if(this.forceType == ForceType.SPRING) {
            fill(255, 255, 255, opacity);
            PVector direction = PVector.sub(worldAnchorA, worldAnchorB);

            float length = direction.mag();
            direction.normalize();

            float segments = 10;
            float segmentLength = length / segments;

            float offsetMagnitude = 0.5f;

            //Draw the rod
            strokeWeight(0.3f);
            stroke(0, 0, 0, opacity); // Black
            line(worldAnchorA.x, worldAnchorA.y, worldAnchorB.x, worldAnchorB.y);
            stroke(255, 255, 255, opacity); // White
            strokeWeight(0.1f);
            line(worldAnchorA.x, worldAnchorA.y, worldAnchorB.x, worldAnchorB.y);
            
            //Draw the spring
            for(int i = 0; i < segments; i++) {
                PVector segmentStart = PVector.add(worldAnchorB, PVector.mult(direction, segmentLength * i));
                PVector segmentEnd = PVector.add(worldAnchorB, PVector.mult(direction, segmentLength * (i + 1)));

                // Calculate the midpoint of the segment
                PVector midPoint = PVector.lerp(segmentStart, segmentEnd, 0.5f);

                // Alternate the offset direction to give appearance of spring
                PVector offset1, offset2;
                if(i % 2 == 0) {
                    offset1 = PVector.mult(new PVector(-direction.y, direction.x), offsetMagnitude);
                    offset2 = PVector.mult(new PVector(direction.y, -direction.x), offsetMagnitude);
                } else {
                    offset1 = PVector.mult(new PVector(direction.y, -direction.x), offsetMagnitude);
                    offset2 = PVector.mult(new PVector(-direction.y, direction.x), offsetMagnitude);
                }

                // Add the offsets to the midpoint
                PVector midPoint1 = PVector.add(midPoint, offset1);
                PVector midPoint2 = PVector.add(midPoint, offset2);

                // Draw the lines
                strokeWeight(0.2f);
                stroke(0, 0, 0, opacity);
                line(segmentStart.x, segmentStart.y, midPoint1.x, midPoint1.y);
                line(midPoint1.x, midPoint1.y, segmentEnd.x, segmentEnd.y);
                line(segmentStart.x, segmentStart.y, midPoint2.x, midPoint2.y);
                line(midPoint2.x, midPoint2.y, segmentEnd.x, segmentEnd.y);
                strokeWeight(0.1f);
                stroke(255, 255, 255, opacity);
                line(segmentStart.x, segmentStart.y, midPoint1.x, midPoint1.y);
                line(midPoint1.x, midPoint1.y, segmentEnd.x, segmentEnd.y);
                line(segmentStart.x, segmentStart.y, midPoint2.x, midPoint2.y);
                line(midPoint2.x, midPoint2.y, segmentEnd.x, segmentEnd.y);
            }

        } else if(this.forceType == ForceType.ROD) {
            strokeWeight(0.15f);
            stroke(0, 0, 0, opacity);
            line(worldAnchorA.x, worldAnchorA.y, worldAnchorB.x, worldAnchorB.y);
            strokeWeight(0.1f);
            stroke(255, 255, 255, opacity);
            line(worldAnchorA.x, worldAnchorA.y, worldAnchorB.x, worldAnchorB.y);

        } else if(this.forceType == ForceType.MOTOR) {
            if(this.tempBody != null) {
            PVector position = this.tempBody.getPosition();
            boolean isClockwise = this.motorTargetAngularVelocity > 0;

            float size = this.tempBody.getRadius() * 0.5f;
            float arrowSize = size * 0.15f;
            float startAngle = 0;
            float endAngle = 3 * PI/2;// Change this to control the curvature of the arrow
            
            pushMatrix();
            translate(position.x, position.y);
            rotate(this.tempBody.getAngle() + PI/6);

            noFill();
            strokeWeight(0.1f);
            stroke(255, 0, 0, opacity);
            arc(0, 0, size, size, startAngle, endAngle);

            // Calculate the start and end of the arc
            float startX =  size * cos(startAngle)/2;
            float startY = size * sin(startAngle)/2;
            float endX = size * cos(endAngle)/2;
            float endY = size * sin(endAngle)/2;


            if(isClockwise) {
                strokeWeight(0.1f);
                stroke(255, 0, 0, opacity);
                triangle(endX, endY-arrowSize, endX, endY+arrowSize, endX+arrowSize*2, endY);
            } else {
                strokeWeight(0.1f);
                stroke(255, 0, 0, opacity);
                triangle(startX-arrowSize, startY, startX + arrowSize, startY, startX, startY - 2 * arrowSize);
            }
            popMatrix();
        }
        }
    }
}

public void updateSelectedRigidbodies() {
    if(this.selectedRigidbodies.size() == 2) {

        //For one body selected
        if(this.selectedRigidbodies.get(0) != null && this.selectedRigidbodies.get(1) == null) {

            this.selectedRigidbody = this.selectedRigidbodies.get(0);

            this.selectedRigidbody1 = null;
            this.selectedRigidbody2 = null;
            this.tempBody = null;

            this.oneRigidbodySelected = true;
            this.twoRigidbodiesSelected = false;

        } else if(this.selectedRigidbodies.get(0) == null && this.selectedRigidbodies.get(1) != null){
            
            this.selectedRigidbody = this.selectedRigidbodies.get(1);

            this.selectedRigidbody1 = null;
            this.selectedRigidbody2 = null;
            this.tempBody = null;

            this.oneRigidbodySelected = true;
            this.twoRigidbodiesSelected = false;
        
        }else if(this.selectedRigidbodies.get(0) != null && this.selectedRigidbodies.get(1) != null) {

            this.selectedRigidbody1 = this.selectedRigidbodies.get(0);
            this.selectedRigidbody2 = this.selectedRigidbodies.get(1);

            this.selectedRigidbody = null;
            this.tempBody = null;

            this.oneRigidbodySelected = false;
            this.twoRigidbodiesSelected = true;

        } else if(this.selectedRigidbodies.get(0) == null && this.selectedRigidbodies.get(1) == null) {

            this.selectedRigidbody = null;
            this.selectedRigidbody1 = null;
            this.selectedRigidbody2 = null;
            this.tempBody = null;

            this.oneRigidbodySelected = false;
            this.twoRigidbodiesSelected = false;
        }
        this.selectedRigidbodies.clear();

    } else if(this.selectedRigidbodies.size() == 1) {
            
            if(this.selectedRigidbodies.get(0) != null) {
    
                this.tempBody = this.selectedRigidbodies.get(0);

                this.selectedRigidbody = null;
                this.selectedRigidbody1 = null;
                this.selectedRigidbody2 = null;
    
                this.oneRigidbodySelected = true;
                this.twoRigidbodiesSelected = false;
    
            } else if(this.selectedRigidbodies.get(0) == null) {
                
                this.tempBody = null;
                this.selectedRigidbody = null;
                this.selectedRigidbody1 = null;
                this.selectedRigidbody2 = null;
    
                this.oneRigidbodySelected = false;
                this.twoRigidbodiesSelected = false;
            }
    }
}


public void createForces() {
    if(this.selectedRigidbody != null && this.selectedRigidbody1 == null && this.selectedRigidbody2 == null) {
        if(this.forceType == ForceType.SPRING) {

            Spring spring;
            PVector mouseCoordinates = screenToWorld(mouseX, mouseY);
            if(isFirstClickOnRigidbody) {

                spring = new Spring(this.selectedRigidbody, this.localAnchorA, mouseCoordinates);
            } else {

                this.localAnchorA = PhysEngMath.SnapController(this, this.selectedRigidbody, mouseCoordinates);
                spring = new Spring(this.selectedRigidbody, this.localAnchorA, this.anchorPoint);
            }

            spring.setPerfectSpring(this.isPerfectSpring);
            spring.setLockTranslationToXAxis(this.lockTranslationToXAxis);
            spring.setLockTranslationToYAxis(this.lockTranslationToYAxis);

            spring.setEquilibriumLength(this.equilibriumLength);
            spring.setSpringConstant(this.springConstant);

            spring.setDamping(this.springDamping);
            spring.setIsHingeable(this.isSpringHingeable);

            this.selectedRigidbody.addForceToForceRegistry(spring);

        } else if(this.forceType == ForceType.ROD) {
            Rod rod1;
            PVector mouseCoordinates = screenToWorld(mouseX, mouseY);

            if(isFirstClickOnRigidbody) {
                rod1 = new Rod(this.selectedRigidbody, this.localAnchorA, mouseCoordinates);
            } else {
                this.localAnchorA = PhysEngMath.SnapController(this, this.selectedRigidbody, mouseCoordinates);
                rod1 = new Rod(this.selectedRigidbody, this.localAnchorA, this.anchorPoint);
            }

            rod1.setIsHingeable(this.isRodHingeable);


            this.selectedRigidbody.addForceToForceRegistry(rod1);

        } else if(this.forceType == ForceType.MOTOR) {
            Motor motor = new Motor(this.selectedRigidbody, this.motorTargetAngularVelocity);
            motor.setDrawMotor(this.motorDrawMotor);
            motor.setDrawMotorForce(this.motorDrawMotorForce);
            
            Iterator<ForceRegistry> iterator = this.selectedRigidbody.getForceRegistry().iterator();
            
            while (iterator.hasNext()) {
                ForceRegistry force = iterator.next();
                
                if (force instanceof Motor) {
                    iterator.remove();
                }
            }
            this.selectedRigidbody.addForceToForceRegistry(motor);
        }

    } else if(this.selectedRigidbody1 != null && this.selectedRigidbody2 != null && this.selectedRigidbody == null && this.selectedRigidbody1 != this.selectedRigidbody2) {
        if(this.forceType == ForceType.SPRING) {


            PVector localAnchorB = PhysEngMath.SnapController(this, this.selectedRigidbody2, screenToWorld(mouseX, mouseY));

            Spring spring = new Spring(this.selectedRigidbody1, this.selectedRigidbody2, this.localAnchorA, localAnchorB);

            spring.setPerfectSpring(this.isPerfectSpring);

            spring.setLockTranslationToXAxis(this.lockTranslationToXAxis);
            spring.setLockTranslationToYAxis(this.lockTranslationToYAxis);

            spring.setEquilibriumLength(this.equilibriumLength);

            spring.setSpringConstant(this.springConstant);

            spring.setDamping(this.springDamping);

            spring.setIsHingeable(this.isSpringHingeable);

            this.selectedRigidbody1.addForceToForceRegistry(spring);
            this.selectedRigidbody2.addForceToForceRegistry(spring);

        } else if(this.forceType == ForceType.ROD) {
            Rod rod1;

            PVector localAnchorB = PhysEngMath.SnapController(this, this.selectedRigidbody2, screenToWorld(mouseX, mouseY));

            rod1 = new Rod(this.selectedRigidbody1, this.selectedRigidbody2, this.localAnchorA, localAnchorB);

            rod1.setIsHingeable(this.isRodHingeable);



            this.selectedRigidbody1.addForceToForceRegistry(rod1);


            this.selectedRigidbody2.addForceToForceRegistry(rod1);
        }

} else if(this.selectedRigidbody1 != null && this.selectedRigidbody2 != null && this.selectedRigidbody1 == this.selectedRigidbody2) {
    
        if(this.forceType == ForceType.ROD) {
            PVector mouseCoordinates = screenToWorld(mouseX, mouseY);

            Rod rod1 = new Rod(this.selectedRigidbody1, this.localAnchorA, mouseCoordinates);

            rod1.setIsHingeable(this.isRodHingeable);

            this.selectedRigidbody1.addForceToForceRegistry(rod1);

        }
        else if(this.forceType == ForceType.MOTOR) {

            Motor motor = new Motor(this.selectedRigidbody1, this.motorTargetAngularVelocity);
            motor.setDrawMotor(this.motorDrawMotor);
            motor.setDrawMotorForce(this.motorDrawMotorForce);
            
            Iterator<ForceRegistry> iterator = this.selectedRigidbody1.getForceRegistry().iterator();
            
            while (iterator.hasNext()) {
                ForceRegistry force = iterator.next();
                
                if (force instanceof Motor) {
                    iterator.remove();
                }
            }
            this.selectedRigidbody1.addForceToForceRegistry(motor);
        }
    }
}


public void firstMouseClickInformation() {

    Rigidbody clickedBody = getClickedRigidbody();
    PVector mousePos = screenToWorld(mouseX, mouseY);

    if(clickedBody != null) {
        
        this.localAnchorA = PhysEngMath.SnapController(this, clickedBody, mousePos);
        this.anchorPoint = mousePos;
        this.isFirstClickOnRigidbody = true;
    } else {
        this.anchorPoint = mousePos;
        this.isFirstClickOnRigidbody = false;
    }
}




/*
====================================================================================================
======================================= Getters & Setters ==========================================
====================================================================================================
*/


public void setWidth(float width) {
  this.width = width;
}

public void setHeight(float height) {
  this.height = height;
}

public void setRadius(float radius) {
  this.radius = radius;
}

public void setDensity(float density) {
  this.density = density;
}

public void setRestitution(float restitution) {
  this.restitution = restitution;
}

public void setIsStatic(boolean isStatic) {
  this.isStatic = isStatic;
}

public void setCollidable(boolean isCollidable) {
  this.isCollidable = isCollidable;
}

public void setStrokeWeight(float strokeWeight) {
  this.strokeWeight = strokeWeight;
}

public void setStrokeColor(PVector strokeColor) {
  this.strokeColor = strokeColor;
}

public void setFillColor(PVector fillColor) {
  this.fillColor = fillColor;
}

public void setShapeType(ShapeType shapeType) {
  this.shapeType = shapeType;
}

public void setIsTranslationallyStatic(boolean isTranslationallyStatic) {
  this.isTranslationallyStatic = isTranslationallyStatic;
}

public void setIsRotationallyStatic(boolean isRotationallyStatic) {
  this.isRotationallyStatic = isRotationallyStatic;
}

public void setGenerateRigidbodies(boolean generateRigidbodies) {
  this.generateRigidbodies = generateRigidbodies;
}

public void setGenerateForces(boolean generateForces) {
  this.generateForces = generateForces;
}

public void setAngle(float angle) {
  this.angle = angle;
}

public void setAngularVelocity(float angularVelocity) {
  this.angularVelocity = angularVelocity;
}

public void setForceType(ForceType forceType) {
  this.forceType = forceType;
}

public void setAddGravity(boolean addGravity) {
  this.addGravity = addGravity;
}

public void setSpringIsPerfect(boolean isPerfectSpring) {
  this.isPerfectSpring = isPerfectSpring;
}

public void setSpringIsHingeable(boolean isSpringHingeable) {
  this.isSpringHingeable = isSpringHingeable;
}
public void setSpringEquilibriumLength(float equilibriumLength) {
  this.equilibriumLength = equilibriumLength;
}

public void setSpringDamping(float damping) {
  this.springDamping = damping;
}

public void setSpringConstant(float springConstant) {
  this.springConstant = springConstant;
}

public void setLockToXAxis(boolean lockTranslationToXAxis) {
  this.lockTranslationToXAxis = lockTranslationToXAxis;
}

public void setLockToYAxis(boolean lockTranslationToYAxis) {
  this.lockTranslationToYAxis = lockTranslationToYAxis;
}

public void setRigidbodyPosition(PVector position) {
  this.rigidbodyPosition = position;
}



public void setRodIsHingeable(boolean isRodHingeable) {
  this.isRodHingeable = isRodHingeable;
}

public void setSnapToCenter(boolean snapToCenter) {
  this.snapToCenter = snapToCenter;
}

public void setSnapToEdge(boolean snapToEdge) {
  this.snapToEdge = snapToEdge;
}

public void setSnapToVertices(boolean snapToVertices) {
  this.snapToVertices = snapToVertices;
}

public void setMotorDrawMotorForce(boolean motorDrawMotorForce) {
  this.motorDrawMotorForce = motorDrawMotorForce;
}

public void setMotorDrawMotor(boolean motorDrawMotor) {
  this.motorDrawMotor = motorDrawMotor;
}

public void setMotorTargetAngularVelocity(float motorTargetAngularVelocity) {
  this.motorTargetAngularVelocity = motorTargetAngularVelocity;
}

public void setSelectedRigidbody(Rigidbody selectedRigidbody) {
  this.selectedRigidbody = selectedRigidbody;
}

public void setSelectedRigidbody1() {
  this.selectedRigidbody1 = this.selectedRigidbody;
}

public void setSelectedRigidbody2(Rigidbody selectedRigidbody2) {
  this.selectedRigidbody2 = selectedRigidbody2;
}

public void setDrawCursorTrail(boolean showCursorTrail) {
  this.showCursorTrail = showCursorTrail;
}

public void setEnableEditor(boolean enableEditor) {
  this.enableEditor = enableEditor;
}

public void setVertices(PVector[] vertices) {
  this.vertices = vertices;
}

public void setSoftbodyWidth(float softbodyWidth) {
  this.softbodyWidth = softbodyWidth;
}

public void setSoftbodyHeight(float softbodyHeight) {
  this.softbodyHeight = softbodyHeight;
}

public float getWidth() {
  return this.width;
}

public float getHeight() {
  return this.height;
}

public float getRadius() {
  return this.radius;
}

public float getDensity() {
  return this.density;
}

public float getRestitution() {
  return this.restitution;
}

public boolean getIsStatic() {
  return this.isStatic;
}

public boolean getCollidable() {
  return this.isCollidable;
}

public float getStrokeWeight() {
  return this.strokeWeight;
}

public PVector getStrokeColor() {
  return this.strokeColor;
}

public PVector getFillColor() {
    return this.fillColor;
}

public ShapeType getShapeType() {
  return this.shapeType;
}

public boolean getIsTranslationallyStatic() {
  return this.isTranslationallyStatic;
}

public boolean getIsRotationallyStatic() {
  return this.isRotationallyStatic;
}

public boolean getGenerateRigidbodies() {
  return this.generateRigidbodies;
}

public boolean getGenerateForces() {
  return this.generateForces;
}

public float getAngle() {
  return this.angle;
}

public float getAngularVelocity() {
  return this.angularVelocity;
}

public boolean getAddGravity() {
  return this.addGravity;
}

public boolean getIsPerfectSpring() {
  return this.isPerfectSpring;
}


public boolean getSnapToEdge() {
    return this.snapToEdge;
}

public boolean getSnapToCenter() {
    return this.snapToCenter;
}

public boolean getSnapToVertices() {
    return this.snapToVertices;
}
public boolean getMotorDrawMotorForce() {
    return this.motorDrawMotorForce;
}

public boolean getMotorDrawMotor() {
    return this.motorDrawMotor;
}

public float getMotorTargetAngularVelocity() {
    return this.motorTargetAngularVelocity;
}

public Rigidbody getSelectedRigidbody() {
    return this.selectedRigidbody;
}

public Rigidbody getSelectedRigidbody1() {
    return this.selectedRigidbody1;
}

public Rigidbody getSelectedRigidbody2() {
    return this.selectedRigidbody2;
}

public boolean getEnableEditor() {
    return this.enableEditor;
}

public PVector[] getVertices() {
    return this.vertices;
}

public float getSoftbodyWidth(){
    return this.softbodyWidth;
}

public float getSoftbodyHeight(){
    return this.softbodyHeight;
}

}










public class Motor implements ForceRegistry {

    private final Rigidbody rigidbody;
    private PVector localAnchor;

    private float targetAngularVelocity;

    private boolean drawMotorForce;
    private boolean drawMotor;


    public Motor(Rigidbody rigidbody) {
        this.rigidbody = rigidbody;
        this.localAnchor = new PVector(this.rigidbody.getRadius(), 0);
        this.drawMotorForce = true;
    }

    public Motor(Rigidbody rigidbody, float targetAngularVelocity) {
        this.rigidbody = rigidbody;
        this.targetAngularVelocity = targetAngularVelocity;
        this.localAnchor = new PVector(this.rigidbody.getRadius(), 0);
        this.drawMotorForce = true;
    }


@Override
public PVector getForce(Rigidbody rigidbody, PVector position) {

    if(this.rigidbody != rigidbody) {
        throw new IllegalArgumentException("Rigidbody is not the same as the one this force is applied to");
    }

    this.rigidbody.setAngularVelocity(targetAngularVelocity);
    
    return new PVector(0, 0);
    
    
}

@Override
public void draw() {

if(!drawMotorForce) {
    return;
}
    PVector position = this.rigidbody.getPosition();
    boolean isClockwise = targetAngularVelocity > 0;

    float size = this.rigidbody.getRadius() * 0.5f;
    float arrowSize = size * 0.15f;
    float startAngle = 0;
    float endAngle = 3 * PI/2;// Change this to control the curvature of the arrow

    // Draw the curved part of the arrow
    pushMatrix();
    translate(position.x, position.y);
    rotate(this.rigidbody.getAngle() + PI/6);
    noFill();
    stroke(255, 0, 0); // Red color
    arc(0, 0, size, size, startAngle, endAngle);

    // Calculate the start and end of the arc
    float startX =  size * cos(startAngle)/2;
    float startY = size * sin(startAngle)/2;
    float endX = size * cos(endAngle)/2;
    float endY = size * sin(endAngle)/2;

    fill(255, 0, 0); // Red color
    noStroke();
    
    if(isClockwise) {
        triangle(endX, endY-arrowSize, endX, endY+arrowSize, endX+arrowSize*2, endY);
    } else {
        triangle(startX-arrowSize, startY, startX + arrowSize, startY, startX, startY - 2 * arrowSize);
    }

    popMatrix();

}
@Override
public PVector getApplicationPoint(Rigidbody rigidbody, PVector position) {
    return PhysEngMath.Transform(localAnchor, position, rigidbody.getAngle());
}


/*
====================================================================================================
======================================== Getters and Setters ========================================
====================================================================================================
*/
    public void setDrawMotor(boolean drawMotor) {
        this.drawMotor = drawMotor;
    }

    public void setDrawMotorForce(boolean drawMotorForce) {
        this.drawMotorForce = drawMotorForce;
    }

    public void setTargetAngularVelocity(float targetAngularVelocity) {
        this.targetAngularVelocity = targetAngularVelocity;
    }

    public void setLocalAnchor(PVector localAnchor) {
        this.localAnchor = localAnchor;
    }

    public boolean getDrawMotor() {
        return drawMotor;
    }

    public boolean getDrawMotorForce() {
        return drawMotorForce;
    }

    public float getTargetAngularVelocity() {
        return targetAngularVelocity;
    }

    public PVector getLocalAnchor() {
        return localAnchor;
    }



}

public int qCount = 0;
public boolean switchTab = true;

public boolean onePressed = false;
public boolean twoPressed = false;
public boolean threePressed = false;
public boolean fourPressed = false;
public boolean fivePressed = false;
public boolean sixPressed = false;

public boolean dPressed = false;
public boolean shiftPressed = false;
public boolean tabPressed = false;
public boolean wPressed = false;
public boolean sPressed = false;
public boolean aPressed = false;
public boolean qPressed = false;
public boolean cPressed = false;
public boolean rPressed = false;
public boolean ePressed = false;

public void keyPressed() {
    if (key == 'd' || key == 'D') {
        dPressed = true;
    }

    if (key == 'w' || key == 'W') {
        wPressed = true;
    }
    if (key == 's' || key == 'S') {
        sPressed = true;
    }

    if (key == 'a' || key == 'A') {
        aPressed = true;
    }

    if(key == 'q' || key == 'Q') {
        qPressed = true;
    }

    if(key == 'e' || key == 'E') {
        ePressed = true;
    }
    if (keyCode == SHIFT) {
        shiftPressed = true;
    }

    if(key == ' ') {
        isPaused = !isPaused;
    }
    if(key == 'r') {
        rigidbodyList.clear();
        softbodyList.clear();
    }
    if(key == BACKSPACE || key == DELETE) {

        Rigidbody rigidbody = interactivityListener.getClickedRigidbody();
        if(rigidbody != null) {
            rigidbodyList.remove(rigidbody);
        }
    }
    if(key == 'c') {
        interactivityListener.position = new PVector(-50, -50);
        interactivityListener.zoom = 10f;
    }
    if((key == 'b' || key == 'B') && (userInterface.getController("Box").getValue() == 1)) {
        Softbody softbody = new Softbody(interactivityListener.screenToWorld(mouseX, mouseY), 0, interactivityListener.getWidth(), interactivityListener.getHeight());
        softbody.CreateBoxSoftbody();
    }

    if(key == 'q' || key == 'Q') {
        if(userInterface.getTab("Forces").isActive()){
            qCount++;
            if(qCount == 1) {
                interactivityListener.setSnapToCenter(true);
                interactivityListener.setSnapToEdge(false);
    
                if(userInterface.getController("AddSpring").getValue() == 1) {
                    userInterface.getController("SpringSnapToCenter").setValue(1);
                    userInterface.getController("SpringSnapToEdge").setValue(0);
                } else if(userInterface.getController("AddRod").getValue() == 1) {
                    userInterface.getController("RodSnapToCenter").setValue(1);
                    userInterface.getController("RodSnapToEdge").setValue(0);
                }
            } else if(qCount == 2) {
                interactivityListener.setSnapToCenter(false);
                interactivityListener.setSnapToEdge(true);
    
                if(userInterface.getController("AddSpring").getValue() == 1) {
                    userInterface.getController("SpringSnapToCenter").setValue(0);
                    userInterface.getController("SpringSnapToEdge").setValue(1);
                } else if(userInterface.getController("AddRod").getValue() == 1) {
                    userInterface.getController("RodSnapToCenter").setValue(0);
                    userInterface.getController("RodSnapToEdge").setValue(1);
                }
            } else if(qCount == 3) {
                interactivityListener.setSnapToCenter(false);
                interactivityListener.setSnapToEdge(false);
    
                if(userInterface.getController("AddSpring").getValue() == 1) {
                    userInterface.getController("SpringSnapToCenter").setValue(0);
                    userInterface.getController("SpringSnapToEdge").setValue(0);
                } else if(userInterface.getController("AddRod").getValue() == 1) {
                    userInterface.getController("RodSnapToCenter").setValue(0);
                    userInterface.getController("RodSnapToEdge").setValue(0);
                }
                qCount = 0;
            }
        }
    }

    if(qPressed) {
        if(shiftPressed) {
            if(userInterface.getTab("Rigidbodies").isActive()) {
                userInterface.getController("Angle").setValue(userInterface.getController("Angle").getValue() - 10);
            }
        } else {
            if(userInterface.getTab("Rigidbodies").isActive()) {
                userInterface.getController("Angle").setValue(userInterface.getController("Angle").getValue() - 1);
            }
        }
    }

    if(ePressed) {
        if(shiftPressed){
            if(userInterface.getTab("Rigidbodies").isActive()) {
                userInterface.getController("Angle").setValue(userInterface.getController("Angle").getValue() + 10);
            }
        } else {
            if(userInterface.getTab("Rigidbodies").isActive()) {
                userInterface.getController("Angle").setValue(userInterface.getController("Angle").getValue() + 1);
            }
        }
    }

 

    if(key == '1') {
        if(userInterface.getTab("Forces").isActive()) {
            userInterface.getController("AddSpring").setValue(1);
            userInterface.getController("AddRod").setValue(0);
            userInterface.getController("AddMotor").setValue(0);

        } else if(userInterface.getTab("Rigidbodies").isActive()) {
            userInterface.getController("Circle").setValue(1);
            userInterface.getController("Box").setValue(0);
        }
    }
    if(key == '2') {
        if(userInterface.getTab("Forces").isActive()) {
            userInterface.getController("AddSpring").setValue(0);
            userInterface.getController("AddRod").setValue(1);
            userInterface.getController("AddMotor").setValue(0);

        } else if(userInterface.getTab("Rigidbodies").isActive()) {
            userInterface.getController("Circle").setValue(0);
            userInterface.getController("Box").setValue(1);
        }
    }
    if(key == '3') {
        if(userInterface.getTab("Forces").isActive()) {
            userInterface.getController("AddSpring").setValue(0);
            userInterface.getController("AddRod").setValue(0);
            userInterface.getController("AddMotor").setValue(1);
        }
    }
    if(key == '4') {
        if(userInterface.getTab("Rigidbodies").isActive()) {
            if(userInterface.getController("isStatic").getValue() == 1) {
                userInterface.getController("isStatic").setValue(0);
            } else {
                userInterface.getController("isStatic").setValue(1);
            }

            userInterface.getController("transStatic").setValue(0);
            userInterface.getController("rotStatic").setValue(0);

        } else if(userInterface.getTab("Forces").isActive()) {
            if(userInterface.getController("AddSpring").getValue() == 1) {
                if(userInterface.getController("SpringLockToX").getValue() == 1) {
                    userInterface.getController("SpringLockToX").setValue(0);
                } else {
                    userInterface.getController("SpringLockToX").setValue(1);
                }
            }
        }
    }
    if(key == '5') {
        if(userInterface.getTab("Rigidbodies").isActive()) {
            if(userInterface.getController("transStatic").getValue() == 1) {
                userInterface.getController("transStatic").setValue(0);
            } else {
                userInterface.getController("transStatic").setValue(1);
            }

            userInterface.getController("isStatic").setValue(0);
            userInterface.getController("rotStatic").setValue(0);
        } else if(userInterface.getTab("Forces").isActive()) {

            if(userInterface.getController("AddSpring").getValue() == 1){
                if(userInterface.getController("SpringLockToY").getValue() == 1) {
                    userInterface.getController("SpringLockToY").setValue(0);
                } else {
                    userInterface.getController("SpringLockToY").setValue(1);
                }
            }
        }
    }

    if(key == '6') {
        if(userInterface.getTab("Rigidbodies").isActive()) {
            if(userInterface.getController("rotStatic").getValue() == 1) {
                userInterface.getController("rotStatic").setValue(0);
            } else {
                userInterface.getController("rotStatic").setValue(1);
            }

            userInterface.getController("isStatic").setValue(0);
            userInterface.getController("transStatic").setValue(0);
        }
    }

    if(key == TAB) {
        if(switchTab) {
            userInterface.getTab("Rigidbodies").bringToFront();

        } else {
            userInterface.getTab("Forces").bringToFront();
        }   
        switchTab = !switchTab;
    }

    if(aPressed) {
        if(shiftPressed) {
            if(userInterface.getTab("Rigidbodies").isActive()) {
                if(userInterface.getController("Circle").getValue() == 1) {
                    userInterface.getController("CircleRadius").setValue(userInterface.getController("CircleRadius").getValue() - 0.5f);
                }
                if(userInterface.getController("Box").getValue() == 1) {
                    userInterface.getController("RectangleWidth").setValue(userInterface.getController("RectangleWidth").getValue() - 1f);
                }
            } else if(userInterface.getTab("Forces").isActive()) {
                if(userInterface.getController("AddSpring").getValue() == 1) {
                    userInterface.getController("SpringConstant").setValue(userInterface.getController("SpringConstant").getValue() - 20f);
                }
                if(userInterface.getController("AddMotor").getValue() == 1) {
                    userInterface.getController("MotorTargetAngularVelocity").setValue(userInterface.getController("MotorTargetAngularVelocity").getValue() - 1f);
                }
            }
        } else {
            if(userInterface.getTab("Rigidbodies").isActive()) {
                if(userInterface.getController("Circle").getValue() == 1) {
                    userInterface.getController("CircleRadius").setValue(userInterface.getController("CircleRadius").getValue() - 0.05f);
                }
                if(userInterface.getController("Box").getValue() == 1) {
                    userInterface.getController("RectangleWidth").setValue(userInterface.getController("RectangleWidth").getValue() - 0.1f);
                }
            } else if(userInterface.getTab("Forces").isActive()) {
                if(userInterface.getController("AddSpring").getValue() == 1) {
                    userInterface.getController("SpringConstant").setValue(userInterface.getController("SpringConstant").getValue() - 1f);
                }
                if(userInterface.getController("AddMotor").getValue() == 1) {
                    userInterface.getController("MotorTargetAngularVelocity").setValue(userInterface.getController("MotorTargetAngularVelocity").getValue() - 0.1f);
                }
            }
        }
    }

    if(dPressed) {
        if(shiftPressed){
            if(userInterface.getTab("Rigidbodies").isActive()) {
                if(userInterface.getController("Circle").getValue() == 1) {
                    userInterface.getController("CircleRadius").setValue(userInterface.getController("CircleRadius").getValue() + 0.5f);
                }
                if(userInterface.getController("Box").getValue() == 1) {
                    userInterface.getController("RectangleWidth").setValue(userInterface.getController("RectangleWidth").getValue() + 1f);
                }
            } else if(userInterface.getTab("Forces").isActive()) {
                if(userInterface.getController("AddSpring").getValue() == 1) {
                    userInterface.getController("SpringConstant").setValue(userInterface.getController("SpringConstant").getValue() + 20f);
                }
                if(userInterface.getController("AddMotor").getValue() == 1) {
                    userInterface.getController("MotorTargetAngularVelocity").setValue(userInterface.getController("MotorTargetAngularVelocity").getValue() + 1f);
                }
            }
        } else {
            if(userInterface.getTab("Rigidbodies").isActive()) {
                if(userInterface.getController("Circle").getValue() == 1) {
                    userInterface.getController("CircleRadius").setValue(userInterface.getController("CircleRadius").getValue() + 0.05f);
                }
                if(userInterface.getController("Box").getValue() == 1) {
                    userInterface.getController("RectangleWidth").setValue(userInterface.getController("RectangleWidth").getValue() + 0.1f);
                }
            } else if(userInterface.getTab("Forces").isActive()) {
                if(userInterface.getController("AddSpring").getValue() == 1) {
                    userInterface.getController("SpringConstant").setValue(userInterface.getController("SpringConstant").getValue() + 1f);
                }
                if(userInterface.getController("AddMotor").getValue() == 1) {
                    userInterface.getController("MotorTargetAngularVelocity").setValue(userInterface.getController("MotorTargetAngularVelocity").getValue() + 0.1f);
                }
            }
        }
    }

   
    if(wPressed) {
        if(shiftPressed){
            if(userInterface.getTab("Rigidbodies").isActive()) {
                if(userInterface.getController("Circle").getValue() == 1) {
                    userInterface.getController("CircleRadius").setValue(userInterface.getController("CircleRadius").getValue() + 0.5f);
                }
                if(userInterface.getController("Box").getValue() == 1) {
                    userInterface.getController("RectangleHeight").setValue(userInterface.getController("RectangleHeight").getValue() + 1f);
                }
            }
        } else {
            if(userInterface.getTab("Rigidbodies").isActive()) {
                if(userInterface.getController("Circle").getValue() == 1) {
                    userInterface.getController("CircleRadius").setValue(userInterface.getController("CircleRadius").getValue() + 0.05f);
                }
                if(userInterface.getController("Box").getValue() == 1) {
                    userInterface.getController("RectangleHeight").setValue(userInterface.getController("RectangleHeight").getValue() + 0.1f);
                }
            }
        }
    }

    if(sPressed) {
        if(shiftPressed){
            if(userInterface.getTab("Rigidbodies").isActive()) {
                if(userInterface.getController("Circle").getValue() == 1) {
                    userInterface.getController("CircleRadius").setValue(userInterface.getController("CircleRadius").getValue() - 0.5f);
                }
                if(userInterface.getController("Box").getValue() == 1) {
                    userInterface.getController("RectangleHeight").setValue(userInterface.getController("RectangleHeight").getValue() - 1f);
                }
            }
        } else {
            if(userInterface.getTab("Rigidbodies").isActive()) {
                if(userInterface.getController("Circle").getValue() == 1) {
                    userInterface.getController("CircleRadius").setValue(userInterface.getController("CircleRadius").getValue() - 0.05f);
                }
                if(userInterface.getController("Box").getValue() == 1) {
                    userInterface.getController("RectangleHeight").setValue(userInterface.getController("RectangleHeight").getValue() - 0.1f);
                }
            }
        }
    }
}

public void keyReleased() {
    if (key == 'd' || key == 'D') {
        dPressed = false;
    }
    if (keyCode == SHIFT) {
        shiftPressed = false;
    }
    if (key == 'w' || key == 'W') {
        wPressed = false;
    }
    if (key == 's' || key == 'S') {
        sPressed = false;
    }
    if (key == 'a' || key == 'A') {
        aPressed = false;
    }
    if(key == 'q' || key == 'Q') {
        qPressed = false;
    }
    if(key == 'e' || key == 'E') {
        ePressed = false;
    }
}


public void mouseWheel(MouseEvent event) {
    if(!userInterface.isMouseOver()) {
        float e = -event.getCount();
        interactivityListener.zoom(pow(1.1f, e), mouseX, mouseY);
    }
}

public void mouseDragged() {
    if(!userInterface.isMouseOver() && mouseButton == RIGHT){
        interactivityListener.move(pmouseX - mouseX, pmouseY - mouseY);
    }
}
public void mouseClicked() {
    System.out.println(interactivityListener.screenToWorld(mouseX, mouseY));
    //Checks if the mouse is over the user in terface, if it isnt, continues
    if(!userInterface.isMouseOver()) {
        //If the user has selected a shape, generate a rigidbody
        if(interactivityListener.getGenerateRigidbodies() && !interactivityListener.getGenerateForces()) {
            interactivityListener.GenerateRigidbody();
        }
        if(interactivityListener.getGenerateForces() && !interactivityListener.getGenerateRigidbodies()) {
            interactivityListener.addSelectedRigidbody();
            interactivityListener.updateSelectedRigidbodies();
            interactivityListener.createForces();
        }
    }
}

public boolean IsMouseOverUI() {
  if(userInterface.isMouseOver() || gui.calculateGroupPositionX() < mouseX && mouseX < gui.calculateGroupPositionX() + gui.globalGroupWidth &&  gui.calculateGroupPositionY() < mouseY && mouseY <  gui.calculateGroupPositionY() +  gui.globalGroupHeight) {
    return true;
    } else {
    return false;
    }
}

public static class PhysEngMath {

    private static final PVector emptyVector = new PVector(0, 0);
  //Precision for float comparison, equal to 0.00005 meters
  public static final float precision = 0.0001f;

  public static float Clamp(float value, float min, float max) {
    if (min == max) {
      return min;
    } else if (min > max) {
      throw new IllegalArgumentException("min must be less than max");
    } else if (value < min) {
      return min;
    } else if (value > max) {
      return max;
    } else {
      return value;
    }
  }
  public static int Clamp(int value, int min, int max) {
    if (min == max) {
      return min;
    } else if (min > max) {
      throw new IllegalArgumentException("min must be less than max");
    } else if (value < min) {
      return min;
    } else if (value > max) {
      return max;
    } else {
      return value;
    }
  }
  


  public static PVector Transform(PVector vertex, PVector position, float angle){
    float sin = sin(angle);
    float cos = cos(angle);
    
    return new PVector(vertex.x * cos - vertex.y * sin + position.x, vertex.x * sin + vertex.y * cos + position.y);
  }
  
  //Overloaded method for Transform
    public static PVector Transform(float x, float y, float angle) {
        float sin = sin(angle);
        float cos = cos(angle);
    
        return new PVector(x * cos - y * sin + x, x * sin + y * cos + y);
  }

  

  public static PVector zeroTransform = Transform(0, 0, 0);



    public static boolean Equals(float a, float b) {
        return Math.abs(a - b) < precision;
    }

public static boolean Equals(PVector a, PVector b) {
    return PVector.sub(a, b).magSq() < precision * precision; //magSq is faster than mag
  }



public static PVector SnapController(InteractivityListener interactivityListener, Rigidbody rigidbody, PVector point) {
    if (rigidbody.getShapeType() == ShapeType.CIRCLE) {
        if (interactivityListener.getSnapToCenter()) {

            return new PVector(0, 0);

        } else if (interactivityListener.getSnapToEdge()) {
            
            return point.sub(rigidbody.getPosition()).normalize().mult(rigidbody.getRadius()).copy();
        } else {
            return PVector.sub(point, rigidbody.getPosition());
        }
    } else {
        if (interactivityListener.getSnapToCenter()) {

            return new PVector(0, 0);

        } else if (interactivityListener.getSnapToEdge()) {

            PVector closestOnPolygon = new PVector();
            float minDistanceSq = Float.MAX_VALUE;
            PVector[] vertices = rigidbody.GetTransformedVertices();

            for (int i = 0; i < vertices.length; i++) {
                PVector closest = getClosestPointOnLine(vertices[i], vertices[(i + 1) % vertices.length], point);
                float distanceSq = point.sub(closest).magSq();

                if (distanceSq < minDistanceSq) {
                    minDistanceSq = distanceSq;
                    closestOnPolygon.set(closest);
                }
            }
            return PVector.sub(closestOnPolygon, rigidbody.getPosition());
        } else {
            return PVector.sub(point, rigidbody.getPosition());
        }
    }
}

  private static PVector getClosestPointOnLine(PVector start, PVector end, PVector point) {
    PVector line = PVector.sub(end, start);
    float len = line.mag();
    line.normalize();
    PVector v = PVector.sub(point, start);
    float d = PVector.dot(v, line);
    d = constrain(d, 0, len);
    return PVector.add(start, line.mult(d));

    }
}
/*------------------------Related to Timekeeping Debugging ---------------------------------------*/
public long totalWorldStepTime;
public long subWorldStepTime;

public int totalBodyCount;
public double systemTime;

public int totalSampleCount;
public int subSampleCount;

public double totalStepTime;
public double subStepTime;
public int bodyCount;

String totalStepTimeUnit;
String subStepTimeUnit;


int lastFrameTime;
float dt;
float fps;
float displayTimeStep;

public static boolean isPaused = false;

/*------------------------------------------------------------------------------------------------*/


/*
====================================================================================================
===================================  PHYSICS ENGINE OBJECTS  =======================================
====================================================================================================
*/
/*------------------------------------ NEVER CHANGE THIS -----------------------------------------*/

public static ArrayList<PVector> pointsOfContactList = new ArrayList<PVector>();

/*-------- Trying this out ----------*/
//public PVectorPool SpringPVectorPool = new PVectorPool(10);
/*-----------------------------------*/


public Rigidbody RigidbodyGenerator = new Rigidbody();
public InteractivityListener interactivityListener = new InteractivityListener();
public Shape render = new Shape();
ControlP5 userInterface;


public static ArrayList<Rigidbody> rigidbodyList = new ArrayList<Rigidbody>();
public static ArrayList<Softbody> softbodyList = new ArrayList<Softbody>();

public ArrayList<ArrayList<Integer>> collisionPairs = new ArrayList<ArrayList<Integer>>();
    

public PVector[] contactList = new PVector[0];
public PVector[] impulseList = new PVector[2];
public PVector[] raList = new PVector[2]; 
public PVector[] rbList = new PVector[2];
public PVector[] frictionImpulseList = new PVector[2];
public float[] jList = new float[2];

/*
====================================================================================================
===================================  PHYSICS ENGINE CONSTANTS  =====================================
====================================================================================================
*/

public final float MIN_BODY_AREA = 0.001f * 0.001f; // m^2
public final float MAX_BODY_AREA = 300f * 300f; // m^2

public final float MIN_BODY_DENSITY = 0.01f; //g/cm^3
public final float MAX_BODY_DENSITY = 300.0f; //g/cm^3

public final float MIN_BODY_WIDTH = 0.01f; // m
public final float MAX_BODY_WIDTH = 300; // m

public final float MIN_BODY_HEIGHT = 0.01f; // m
public final float MAX_BODY_HEIGHT = 10.0f; // m

public final float MIN_BODY_RADIUS = 0.01f;
public final float MAX_BODY_RADIUS = 300f;

public final int MIN_ITERATIONS = 1;
public final int MAX_ITERATIONS = 128;

public PVector BACKGROUND_COLOUR = new PVector(16, 18, 19);


public final PVector GRAVITY_VECTOR = new PVector(0, 9.81f, 0);
public final float GRAVITY_MAG = 9.81f;


/*
====================================================================================================
===================================  PHYSICS ENGINE METHODS  =======================================
====================================================================================================
*/


//Iterations for substeps for each frame
public void Step(float dt, int totalIterations) {
    
    
    /*-----------------Related to Timekeeping Debugging -----------------*/
    long totalWorldStepTimeStart = System.nanoTime();
    /*-------------------------------------------------------------------*/
    
    
    totalIterations = PhysEngMath.Clamp(totalIterations, MIN_ITERATIONS, MAX_ITERATIONS);
    
    for (int currentIteration = 0; currentIteration < totalIterations; currentIteration++) {
        
        /*-----------------Related to Timekeeping Debugging -----------------*/
        long subWorldStepTimeStart = System.nanoTime();
        /*-------------------------------------------------------------------*/
        
        
        this.collisionPairs.clear();

        StepBodies(dt, totalIterations);
        BroadPhaseStep();
        NarrowPhaseStep();
        
        /*-----------------Related to Timekeeping Debugging -----------------*/
        subSampleCount++;
        subWorldStepTime += System.nanoTime() - subWorldStepTimeStart;
        /*-------------------------------------------------------------------*/
}
    /*-----------------Related to Timekeeping Debugging -----------------*/
    totalSampleCount++;
    totalWorldStepTime += System.nanoTime() - totalWorldStepTimeStart;
    /*-------------------------------------------------------------------*/
}


/*
====================================================================================================
=================================== Collision Resolution Methods ===================================
====================================================================================================
*/

public void SeperateBodies(Rigidbody rigidbodyA, Rigidbody rigidbodyB, PVector minimumTranslationVector) {
    
    if (rigidbodyA.getIsStatic() || rigidbodyA.getIsTranslationallyStatic()) {
        
        rigidbodyB.Move(minimumTranslationVector);
        
    } else if (rigidbodyB.getIsStatic() || rigidbodyB.getIsTranslationallyStatic()) {
        
        rigidbodyA.Move(PVector.mult(minimumTranslationVector, -1.0f));
        
    } else {
        
        rigidbodyA.Move(PVector.mult(minimumTranslationVector, -0.5f));
        rigidbodyB.Move(PVector.mult(minimumTranslationVector, 0.5f));
    }
}


public void ResolveCollisionLinear(CollisionManifold collisionManifold) {
    
    Rigidbody rigidbodyA = collisionManifold.getRigidbodyA();
    Rigidbody rigidbodyB = collisionManifold.getRigidbodyB();
    PVector normal = collisionManifold.getNormal();
    float depth = collisionManifold.getDepth();
    
    
    PVector velocityA = rigidbodyA.getVelocity().copy();
    PVector velocityB = rigidbodyB.getVelocity().copy();
    float restitution = min(rigidbodyA.getRestitution(), rigidbodyB.getRestitution());
    PVector relativeVelocity = PVector.sub(velocityB, velocityA);
    
    if (PVector.dot(relativeVelocity, normal) > 0.0f) {
        return;
    }
    
    float invMassA = rigidbodyA.getInvMass();
    float invMassB = rigidbodyB.getInvMass();
    
    float j = -(1f + restitution) * PVector.dot(relativeVelocity, normal) / (invMassA + invMassB);
    
    PVector impulse = PVector.mult(normal, j);
    
    
    velocityA = PVector.add(velocityA, PVector.mult(PVector.mult(impulse, -1), invMassA));
    velocityB = PVector.add(velocityB, PVector.mult(impulse, invMassB));
    
    rigidbodyA.setVelocity(velocityA);
    rigidbodyB.setVelocity(velocityB);
    
}

public void ResolveCollisionRotation(CollisionManifold contact) {
    
    Rigidbody rigidbodyA = contact.getRigidbodyA();
    Rigidbody rigidbodyB = contact.getRigidbodyB();
    float invMassA = rigidbodyA.getInvMass();
    float invMassB = rigidbodyB.getInvMass();
    float invRotationalInertiaA = rigidbodyA.getInvRotationalInertia();
    float invRotationalInertiaB = rigidbodyB.getInvRotationalInertia();
    PVector normal = contact.getNormal();
    PVector velocityA = rigidbodyA.getVelocity();
    PVector velocityB = rigidbodyB.getVelocity();
    float angularVelocityA = rigidbodyA.getAngularVelocity();
    float angularVelocityB = rigidbodyB.getAngularVelocity();

    int contactCount = contact.getContactCount();
    contactList = contact.getPointsOfContact();

    float e = min(rigidbodyA.getRestitution(), rigidbodyB.getRestitution());


    for(int i = 0; i < contactCount; i++) {
        this.impulseList[i] = new PVector();
        this.raList[i] = new PVector();
        this.rbList[i] = new PVector();
    }

    for (int i = 0; i < contactCount; i++) {
        PVector ra = PVector.sub(contactList[i], rigidbodyA.getPosition());
        PVector rb = PVector.sub(contactList[i], rigidbodyB.getPosition());

        raList[i] = ra;
        rbList[i] = rb;

        PVector raPerp = new PVector(-ra.y, ra.x);
        PVector rbPerp = new PVector(-rb.y, rb.x);

        PVector angularLinearVelocityA = PVector.mult(raPerp, angularVelocityA);
        PVector angularLinearVelocityB = PVector.mult(rbPerp, angularVelocityB);

        PVector relativeVelocity = PVector.sub(PVector.add(velocityB, angularLinearVelocityB),
                                               PVector.add(velocityA, angularLinearVelocityA));

        float contactVelocityMag = relativeVelocity.dot(normal);

        if (contactVelocityMag > 0f) {
            continue;
        }

        float raPerpDotN = raPerp.dot(normal);
        float rbPerpDotN = rbPerp.dot(normal);

        float denom = (invMassA + invMassB) +
            ((raPerpDotN * raPerpDotN) * invRotationalInertiaA) +
            ((rbPerpDotN * rbPerpDotN) * invRotationalInertiaB);

        float j = -(1f + e) * contactVelocityMag;
        j /= denom;
        j /= (float)contactCount;

        PVector impulse = PVector.mult(normal, j);
        impulseList[i] = impulse;
    }

    for(int i = 0; i < contactCount; i++) {
        PVector impulse = impulseList[i];
        PVector ra = raList[i];
        PVector rb = rbList[i];

        //float raCrossImpulse = ra.x * impulse.y - ra.y * impulse.x;
        //float rbCrossImpulse = rb.x * impulse.y - rb.y * impulse.x;

        velocityA.add(PVector.mult(impulse, -invMassA));
        velocityB.add(PVector.mult(impulse, invMassB));

        angularVelocityA += ra.cross(impulse).z * -1 * invRotationalInertiaA;
        angularVelocityB += rb.cross(impulse).z * invRotationalInertiaB;

        rigidbodyA.setVelocity(velocityA);
        rigidbodyB.setVelocity(velocityB);
        rigidbodyA.setAngularVelocity(angularVelocityA);
        rigidbodyB.setAngularVelocity(angularVelocityB);
    }
}


public void ResolveCollisionRotationAndFriction(CollisionManifold contact) {

    Rigidbody rigidbodyA = contact.getRigidbodyA();
    Rigidbody rigidbodyB = contact.getRigidbodyB();

    float invMassA = rigidbodyA.getInvMass();
    float invMassB = rigidbodyB.getInvMass();

    float invRotationalInertiaA = rigidbodyA.getInvRotationalInertia();
    float invRotationalInertiaB = rigidbodyB.getInvRotationalInertia();

    PVector positionA = rigidbodyA.getPosition();
    PVector positionB = rigidbodyB.getPosition();

    PVector velocityA = rigidbodyA.getVelocity();
    PVector velocityB = rigidbodyB.getVelocity();

    float angularVelocityA = rigidbodyA.getAngularVelocity();
    float angularVelocityB = rigidbodyB.getAngularVelocity();

    PVector normal = contact.getNormal();
    int contactCount = contact.getContactCount();
    contactList = contact.getPointsOfContact();



    float restitution = min(rigidbodyA.getRestitution(), rigidbodyB.getRestitution());

    float coefficientOfStaticFriction = (rigidbodyA.getCoefficientOfStaticFriction()
                                        + rigidbodyB.getCoefficientOfStaticFriction()) * 0.5f;
    float coefficientOfKineticFriction = (rigidbodyA.getCoefficientOfKineticFriction()
                                         + rigidbodyB.getCoefficientOfKineticFriction()) * 0.5f;
    
    for(int i = 0; i < contactCount; i++) {
        this.impulseList[i] = new PVector();
        this.raList[i] = new PVector();
        this.rbList[i] = new PVector();
        this.frictionImpulseList[i] = new PVector();
        this.jList[i] = 0f;
    }

    for(int i = 0; i < contactCount; i++) {

        PVector ra = PVector.sub(contactList[i], positionA);
        PVector rb = PVector.sub(contactList[i], positionB);

        raList[i] = ra;
        rbList[i] = rb;

        PVector raPerp = new PVector(-ra.y, ra.x);
        PVector rbPerp = new PVector(-rb.y, rb.x);

        PVector angularLinearVelocityA = PVector.mult(raPerp, angularVelocityA);
        PVector angularLinearVelocityB = PVector.mult(rbPerp, angularVelocityB);

        PVector relativeVelocity = PVector.sub(PVector.add(velocityB, angularLinearVelocityB),
                                               PVector.add(velocityA, angularLinearVelocityA));

        float contactVelocityMagnitude = relativeVelocity.dot(normal);
        
        if(contactVelocityMagnitude > 0f) {
            continue;
        }
        
        float raPerpendicularDotN = raPerp.dot(normal);
        float rbPerpendicularDotN = rbPerp.dot(normal);

        float denom = invMassA + invMassB
                    + (raPerpendicularDotN * raPerpendicularDotN) * invRotationalInertiaA
                    + (rbPerpendicularDotN * rbPerpendicularDotN) * invRotationalInertiaB;

        float j = -(1f + restitution) * contactVelocityMagnitude;
        j /= denom;
        j /= (float)contactCount;

        jList[i] = j;

        PVector impulse = PVector.mult(normal, j);
        impulseList[i] = impulse;
    }

    for(int i = 0; i < contactCount; i++) {

        PVector impulse = impulseList[i];
        PVector ra = raList[i];
        PVector rb = rbList[i];

        velocityA.add(PVector.mult(impulse, -invMassA));
        velocityB.add(PVector.mult(impulse, invMassB));

        angularVelocityA += -ra.cross(impulse).z * invRotationalInertiaA;
        angularVelocityB += rb.cross(impulse).z * invRotationalInertiaB;

    }

    for(int i = 0; i < contactCount; i++) {
        PVector ra = PVector.sub(contactList[i], positionA);
        PVector rb = PVector.sub(contactList[i], positionB);

        raList[i] = ra;
        rbList[i] = rb;

        PVector raPerp = new PVector(-ra.y, ra.x);
        PVector rbPerp = new PVector(-rb.y, rb.x);

        PVector angularLinearVelocityA = PVector.mult(raPerp, angularVelocityA);
        PVector angularLinearVelocityB = PVector.mult(rbPerp, angularVelocityB);

        PVector relativeVelocity = PVector.sub(PVector.add(velocityB, angularLinearVelocityB),
                                               PVector.add(velocityA, angularLinearVelocityA));
        PVector tangent = PVector.sub(relativeVelocity, PVector.mult(normal, relativeVelocity.dot(normal)));

        if(PhysEngMath.Equals(tangent, new PVector())) {

            continue;

        } else {

            tangent.normalize();

        }

        float raPerpDotT = raPerp.dot(tangent);
        float rbPerpDotT = rb.dot(tangent);

        float denom = invMassA + invMassB
                    + (raPerpDotT * raPerpDotT) * invRotationalInertiaA
                    + (rbPerpDotT * rbPerpDotT) * invRotationalInertiaB;

        float jt = -relativeVelocity.dot(tangent);
        jt /= denom;
        jt /= (float)contactCount;

        PVector frictionImpulse;
        float j = jList[i];

        if(abs(jt) <= j * coefficientOfStaticFriction) {
            frictionImpulse = PVector.mult(tangent, jt);
        } else {
            frictionImpulse = PVector.mult(tangent, -j * coefficientOfKineticFriction);
        }
        
        this.frictionImpulseList[i] = frictionImpulse;
    }
        for(int i = 0; i < contactCount; i++) {
            PVector frictionImpulse = frictionImpulseList[i];
            PVector ra = raList[i];
            PVector rb = rbList[i];

            velocityA.add(PVector.mult(frictionImpulse, -invMassA));
            velocityB.add(PVector.mult(frictionImpulse, invMassB));

            angularVelocityA += -ra.cross(frictionImpulse).z * invRotationalInertiaA;
            angularVelocityB += rb.cross(frictionImpulse).z * invRotationalInertiaB;

            rigidbodyA.setVelocity(velocityA);
            rigidbodyB.setVelocity(velocityB);

            rigidbodyA.setAngularVelocity(angularVelocityA);
            rigidbodyB.setAngularVelocity(angularVelocityB);
        }

    }

/*
====================================================================================================
============================ Broad & Narrow - Phase Collision Methods ==============================
====================================================================================================
*/

public void BroadPhaseStep() {
    
    for (int i = 0; i < rigidbodyList.size() - 1; i++) {
        
        Rigidbody rigidbodyA = rigidbodyList.get(i);
        AABB rigidbodyA_AABB = rigidbodyA.GetAABB();
        
        
        
        for (int j = i + 1; j < rigidbodyList.size(); j++) {
            
            Rigidbody rigidbodyB = rigidbodyList.get(j);
            AABB rigidbodyB_AABB = rigidbodyB.GetAABB();

            
            if ((rigidbodyA.getIsStatic() && rigidbodyB.getIsStatic())) {
                continue;
            }
            

            //Remove this if shit breaks
            if(!rigidbodyA.getCollidability() || !rigidbodyB.getCollidability()) {
                continue;
            }
            
            if (!Collisions.IntersectAABB(rigidbodyA_AABB, rigidbodyB_AABB)) {
                continue;
            }

            ArrayList<Integer> pair = new ArrayList<Integer>(Arrays.asList(i, j));
            collisionPairs.add(pair);
        }
    }
}

public void NarrowPhaseStep() {
    for (int i = 0; i < collisionPairs.size(); i++)
    {
        ArrayList<Integer> pair = collisionPairs.get(i);

        Rigidbody rigidbodyA = rigidbodyList.get(pair.get(0));
        Rigidbody rigidbodyB = rigidbodyList.get(pair.get(1));
        
        CollisionResult collisionResult = Collisions.Collide(rigidbodyA, rigidbodyB);
            
        if (collisionResult.getIsColliding()) {
            
            PVector minimumTranslationVector = PVector.mult(collisionResult.getNormal(), collisionResult.getDepth());
            
            SeperateBodies(rigidbodyA, rigidbodyB, minimumTranslationVector);
            Collisions.FindCollisionPoints(rigidbodyA, rigidbodyB, collisionResult);
            CollisionManifold collisionManifold = new CollisionManifold(rigidbodyA, rigidbodyB, collisionResult);
            this.ResolveCollisionRotationAndFriction(collisionManifold);

                
        }
    }
}
    

public void StepBodies(float dt, int totalIterations) {
    for(Rigidbody rigidbody : rigidbodyList) {

        if(rigidbody.getIsStatic()) {
            continue;
        }
        rigidbody.update(dt, totalIterations);
    }
}
            
/*
==================================================================================================
======================================== Helper Methods  =========================================
==================================================================================================
*/
public void AddBodyToBodyEntityList(Rigidbody body) {
    rigidbodyList.add(body);
}

public void RemoveBodyFromBodyEntityList(Rigidbody body) {
     rigidbodyList.remove(body);
}
        
public void RemoveBodyFromBodyEntityList(int index) {
   
   if(index < 0 || index >= rigidbodyList.size()) {
        throw new IndexOutOfBoundsException("Index: " + index + ", Size: " + rigidbodyList.size());
    }

    rigidbodyList.remove(index);
}

public Rigidbody GetBodyFromBodyEntityList(int index) {

    if(index < 0 || index >= rigidbodyList.size()) {
        throw new IndexOutOfBoundsException("Index: " + index + ", Size: " + rigidbodyList.size());
    }

    return rigidbodyList.get(index);
}
                        
public void ClearBodyEntityList() {
    rigidbodyList.clear();
}

public void displayTimings() {

if(millis() - systemTime>= 200) {
  totalStepTime = ((totalWorldStepTime) / totalSampleCount);
  subStepTime = ((subWorldStepTime) / subSampleCount);
  bodyCount = rigidbodyList.size();
  
  totalStepTimeUnit = "ns";
  subStepTimeUnit = "ns";

  if(totalStepTime > 1000) {
    totalStepTime /= 1000;
    totalStepTime = new BigDecimal(totalStepTime).setScale(3, RoundingMode.HALF_UP).doubleValue();
    totalStepTimeUnit = "s";
  }
  if(subStepTime > 1000) {
    subStepTime /= 1000;
    subStepTime = new BigDecimal(subStepTime).setScale(3, RoundingMode.HALF_UP).doubleValue();
    subStepTimeUnit = "s";
  }
  if (totalStepTime > 1000) {
    totalStepTime /= 1000;
    totalStepTime = new BigDecimal(totalStepTime).setScale(3, RoundingMode.HALF_UP).doubleValue();
    totalStepTimeUnit = "ms";
  }
  if (subStepTime > 1000) {
    subStepTime /= 1000;
    subStepTime = new BigDecimal(subStepTime).setScale(3, RoundingMode.HALF_UP).doubleValue();
    subStepTimeUnit = "ms";
  }

  //updates the counter and resets values
  totalWorldStepTime = 0;
  subWorldStepTime = 0;
  totalSampleCount = 0;
  subSampleCount = 0;
  systemTime = millis();

  fps = frameRate;
  displayTimeStep = dt;


}
stroke(255);
fill(255);
text("Total Step Time: " + totalStepTime + totalStepTimeUnit, 10, 20);
text("Sub Step Time: " + subStepTime + subStepTimeUnit, 10, 40);
text("Body Count: " + bodyCount, 10, 60);
text("FPS: " + fps, 10, 80);
text("dt: " + displayTimeStep, 10, 100);
/*------------------------------------------------------------------------------------------------*/
}

    
                                        
                                        
public class Rigidbody {

  //Capital letter denotes read only

  private PVector position;
  private PVector previousPosition;
  private PVector linearVelocity;
  private float angle;
  private float angularVelocity;
    
  private ShapeType ShapeType;
  private float Mass;
  private float InvMass;
  private float Density;
  private float Restitution;
  private float Area;
  private float RotationalInertia;
  private float InvRotationalInertia;
  private float Radius;
  private float Width;
  private float Height;
  private float coefficientOfStaticFriction;
  private float coefficientOfKineticFriction;
  

  private PVector[] Vertices;
  private AABB aabb;
  private PVector[] transformedVertices;


  private ArrayList<Rigidbody> collisionExclusionList = new ArrayList<Rigidbody>();

  private Shape shapeRenderer;
  private float strokeWeight;
  private PVector strokeColour;
  private PVector fillColour;
  
  private boolean transformUpdateRequired;
  private boolean aabbUpdateRequired;
  
  private boolean isStatic;
  private boolean isTranslationallyStatic;
  private boolean isRotationallyStatic;
  private boolean isVisible;
  private boolean isCollidable;


  public boolean useVerletIntegration = false;
  public boolean useRK4Integration = true;
  
  private float netTorque = 0f;
  private PVector netForce = new PVector();
  
  private ArrayList<ForceRegistry> forceRegistry = new ArrayList<ForceRegistry>();
  
  
  
  
  
  
  /*
  ==================================================================================================
  ==================================CONSTRUCTORS====================================================
  ==================================================================================================
  */
  public Rigidbody() {
    //do nothing
  }
  
  private Rigidbody(float density, float mass, float rotationalIntertia, float restitution,
    float area, float radius, float width, float height, PVector[] vertices, boolean isStatic,
    boolean isCollidable, float strokeWeight, PVector strokeColour, PVector fillColour, ShapeType shapeType)
  {
    this.Mass = mass;
    this.RotationalInertia = rotationalIntertia;
    this.InvMass = mass > 0 ? 1 / mass : 0;
    this.InvRotationalInertia = rotationalIntertia > 0 ? 1 / rotationalIntertia : 0;


    this.Density = density;
    this.Restitution = restitution;
    this.Area = area;
    this.Radius = radius;
    this.Width = width;
    this.Height = height;

    this.coefficientOfStaticFriction = 0.8f;
    this.coefficientOfKineticFriction = 0.3f;
  

    this.ShapeType = shapeType;
    this.strokeWeight = strokeWeight;
    this.strokeColour = strokeColour;
    this.fillColour = fillColour;


    this.isStatic = isStatic;
    this.isCollidable = true;
    this.isVisible = true;

    this.position = new PVector();
    this.linearVelocity = new PVector();
    this.angle = 0f;
    this.angularVelocity = 0f;
    
    
    if (shapeType == ShapeType.BOX) {

      this.Vertices = vertices;
      this.transformedVertices = new PVector[this.Vertices.length];
      this.aabb = this.GetAABB();
      
    } else if(shapeType == ShapeType.POLYGON){

        this.Vertices = vertices;
        this.transformedVertices = new PVector[this.Vertices.length];
        this.aabb = this.GetAABB();
      
    } else {

        this.Vertices = null;
        this.transformedVertices = null;
    }
    
    //Sets InvMass for static objects to 0

    
    this.aabbUpdateRequired = true;
    this.transformUpdateRequired = true;
  }
  
  
  
  /*
  ==================================================================================================
  ========================== BODY & COLLIDER GEOMETRY METHODS ======================================
  ==================================================================================================
  */
  private PVector[] CreateBoxVertices(float width, float height) {
    float left = -width / 2;
    float right = width / 2;
    float top = height / 2;
    float bottom = -height / 2;
    
    PVector[] vertices = new PVector[4];
    vertices[0] = new PVector(left, top);
    vertices[1] = new PVector(right, top);
    vertices[2] = new PVector(right, bottom);
    vertices[3] = new PVector(left, bottom);
    return vertices;
  }

  
  public PVector[] GetTransformedVertices() {
    if (this.transformUpdateRequired) {

      for (int i = 0; i < this.Vertices.length; i++) {

        PVector vertex = this.Vertices[i];

        this.transformedVertices[i] = PhysEngMath.Transform(vertex, this.position, this.angle);
      }
    }
    
    /*
    The way this transform system works, is that it caches the transformed vertices,
    and only transforms them once a change has been made. This means that,
    if no change is made is made, cached vertices are returned.
    if the transform is updated, the vertices are transformed, and the cache is updated.
    */
    this.aabbUpdateRequired = true;
    this.transformUpdateRequired = false;
    return this.transformedVertices;
  }
  
  
  public Rigidbody CreateCircleBody(float radius, float density,
    float restitution, boolean isStatic, boolean isCollidable, float strokeWeight,
    PVector strokeColour, PVector fillColour) {

    Rigidbody rigidbody;
    
    float area = (float) PI * radius * radius;
    
    //Argument exceptions for area and density
    if (area < MIN_BODY_AREA) {

      throw new IllegalArgumentException("Body area is too small, radius too small. Min area is " + MIN_BODY_AREA);
    }

    if (area > MAX_BODY_AREA) {

      throw new IllegalArgumentException("Body area is too large, radius too large. Max area is " + MAX_BODY_AREA);
    }

    if (density < MIN_BODY_DENSITY) {

      throw new IllegalArgumentException("Density is too small. Min density is " + MIN_BODY_DENSITY);
    }

    if (density > MAX_BODY_DENSITY) {

      throw new IllegalArgumentException("Density is too large. Max density is " + MAX_BODY_DENSITY);
    }
    
    //Clamps restitution between 0 and 1
    restitution = PhysEngMath.Clamp(restitution, 0, 1);


    float mass = 0f;
    float rotationalIntertia = 0f;

    if(!isStatic) {
      mass = area * density;
      rotationalIntertia =  0.5f * mass * radius * radius;
    }
    


    rigidbody = new Rigidbody(density, mass, rotationalIntertia, restitution, area, radius, 0, 0,
                              null, isStatic, isCollidable, strokeWeight,
                              strokeColour, fillColour, ShapeType.CIRCLE);
    
    System.out.println("Rigidbody created with mass: " + mass + " and area: " + area);
    return rigidbody;
  }
  
  public Rigidbody CreateBoxBody(float width, float height, float density,
    float restitution, boolean isStatic, boolean isCollidable, float strokeWeight,
    PVector strokeColour, PVector fillColour) {
    Rigidbody rigidbody;
    
    float area = width * height;
    
    //Argument exceptions for area and density
    if (area < MIN_BODY_AREA) {

      throw new IllegalArgumentException("Body area is too small, dimensions too small. Min area is " + MIN_BODY_AREA);
    }
    if (area > MAX_BODY_AREA) {

      throw new IllegalArgumentException("Body area is too large, dimensions too large. Max area is " + MAX_BODY_AREA);
    }
    if (density < MIN_BODY_DENSITY) {

      throw new IllegalArgumentException("Density is too small. Min density is " + MIN_BODY_DENSITY);
    }
    if (density > MAX_BODY_DENSITY) {

      throw new IllegalArgumentException("Density is too large. Max density is " + MAX_BODY_DENSITY);
    }
    
    //Clamps restitution between 0 and 1
    restitution = PhysEngMath.Clamp(restitution, 0, 1);
    
    //calculates mass from density and area
    float mass = 0f;
    float rotationalIntertia = 0f;

    if(!isStatic) {
      mass = area * density;
      rotationalIntertia = 0.5f * mass * width * width + height * height;
    }

    PVector[] vertices = CreateBoxVertices(width, height);
    
    rigidbody = new Rigidbody(density, mass, rotationalIntertia, restitution, area, 0, width,
                              height, vertices, isStatic, isCollidable, strokeWeight, strokeColour,
                              fillColour, ShapeType.BOX);
    
    System.out.println("Rigidbody created with mass: " + mass + " and area: " + area);
    
    return rigidbody;
  }

  public AABB GetAABB() {
    if(this.aabbUpdateRequired) {

    float minX = Float.MAX_VALUE;
    float minY = Float.MAX_VALUE;

    float maxX = -Float.MAX_VALUE;
    float maxY = -Float.MAX_VALUE;
    
    if(this.ShapeType == ShapeType.CIRCLE) {
      
      minX = this.position.x - this.Radius;
      minY = this.position.y - this.Radius;
      maxX = this.position.x + this.Radius;
      maxY = this.position.y + this.Radius;

    } else if (this.ShapeType == ShapeType.BOX) {
  PVector[] vertices = this.GetTransformedVertices();
  for (PVector vertex : vertices) {
    if (vertex.x < minX) {
      minX = vertex.x;
    }
    if (vertex.x > maxX) {
      maxX = vertex.x;
    }
    if (vertex.y < minY) {
      minY = vertex.y;
    }
    if (vertex.y > maxY) {
      maxY = vertex.y;
    }
  }
    }

this.aabb = new AABB(new PVector(minX, minY), new PVector(maxX, maxY));
  this.aabbUpdateRequired = false;

  }
  return this.aabb;
}

  /*
  ==================================================================================================
  ==================================METHODS=========================================================
  ==================================================================================================
  */
  public void Move(PVector amount) {
    this.position.add(amount);

    this.transformUpdateRequired = true;
    this.aabbUpdateRequired = true;
  }
  
  public void MoveTo(PVector position) {
    this.position = position;

    this.transformUpdateRequired = true;
    this.aabbUpdateRequired = true;
  }

  public void SetInitialPosition(PVector position) {
    this.position = position;
    this.previousPosition = position.copy();
    this.transformUpdateRequired = true;
    this.aabbUpdateRequired = true;
  }
  
  public void Rotate(float amount) {
    this.angle += amount;

    this.transformUpdateRequired = true;
    this.aabbUpdateRequired = true;
  }

  public void RotateTo(float angle) {
    this.angle = angle;

    this.transformUpdateRequired = true;
    this.aabbUpdateRequired = true;
  }


/*----------------------------- Mouse Detection Stuff ------------------------------------*/
  
public boolean contains(float x, float y) {

    if(this.ShapeType == ShapeType.CIRCLE) {
      return this.containsCircle(x, y);
    } else {
      return this.containsPolygon(x, y);
    }
}

public boolean containsCircle(float x, float y) {
    float distance = PVector.dist(this.position, new PVector(x, y));

    return (distance <= this.Radius);
}


public boolean containsPolygon(float x, float y) {
    boolean inside = false;
    PVector[] vertices = this.transformedVertices;

    for (int i = 0, j = vertices.length - 1; i < vertices.length; j = i++) {
        if ((vertices[i].y > y) != (vertices[j].y > y) &&
            (x < (vertices[j].x - vertices[i].x) * (y - vertices[i].y) / (vertices[j].y - vertices[i].y) + vertices[i].x)) {
            inside = !inside;
        }
    }
    
    return inside;
}



public PVector[] reverseVertices() {
    PVector[] vertices = this.transformedVertices;
    PVector[] reversedVertices = new PVector[vertices.length];

    for (int i = 0; i < vertices.length; i++) {
        reversedVertices[i] = vertices[vertices.length - 1 - i];
    }
    return reversedVertices;
}

/*-------------------------------------------------------------------------------------*/
  

  /*
  ==================================================================================================
  ==================================UPDATE==========================================================
  ==================================================================================================
  */

  public void update(float dt, int iterations) {
    if(!isPaused) {
        if(this.isStatic) {

            this.aabbUpdateRequired = false;

            return;
        } else if (this.isTranslationallyStatic) {

            this.aabbUpdateRequired = true;
            this.transformUpdateRequired = true;

            dt /= (float)iterations;
            this.angularIntegration(dt);

        } else if (this.isRotationallyStatic) {

            this.aabbUpdateRequired = true;
            this.transformUpdateRequired = true;

            dt /= (float)iterations;
            this.RK4Position(dt);

        } else {
            this.aabbUpdateRequired = true;
            this.transformUpdateRequired = true;

            dt /= (float)iterations;                
            this.RK4Position(dt);
            this.angularIntegration(dt);
        }
    }
}
  
  
  
  /*
  ==================================================================================================
  ================================== INTEGRATOR ====================================================
  ==================================================================================================
  */

     public void RK4Position(float dt) {

        /*-------------- RK4 Position And Velocity Integration --------------*/
        PVector k1_v = PVector.mult(calculateAcceleration(this.position), dt);
        PVector k1_r = PVector.mult(this.linearVelocity, dt);

        PVector k2_v = PVector.mult(calculateAcceleration(PVector.add(this.position, PVector.mult(k1_r, 0.5f))), dt);
        PVector k2_r = PVector.mult(PVector.add(this.linearVelocity, PVector.mult(k1_v, 0.5f)), dt);

        PVector k3_v = PVector.mult(calculateAcceleration(PVector.add(this.position, PVector.mult(k2_r, 0.5f))), dt);
        PVector k3_r = PVector.mult(PVector.add(this.linearVelocity, PVector.mult(k2_v, 0.5f)), dt);

        PVector k4_v = PVector.mult(calculateAcceleration(PVector.add(this.position, k3_r)), dt);
        PVector k4_r = PVector.mult(PVector.add(this.linearVelocity, k3_v), dt);
        /*-------------------------------------------------------------------*/


        /*-------------- Reusable Vectors --------------*/
        PVector two_k2_r = PVector.mult(k2_r, 2);
        PVector two_k3_r = PVector.mult(k3_r, 2);

        PVector two_k2_v = PVector.mult(k2_v, 2);
        PVector two_k3_v = PVector.mult(k3_v, 2);
        /*-----------------------------------------------*/


        /*-------------- Final Position and Velocity --------------*/
        PVector finalPosition = PVector.add(this.position, PVector.div(PVector.add(k1_r, PVector.add(two_k2_r, PVector.add(two_k3_r, k4_r))), 6));
        PVector finalVelocity = PVector.add(this.linearVelocity, PVector.div(PVector.add(k1_v, PVector.add(two_k2_v, PVector.add(two_k3_v, k4_v))), 6));
        /*---------------------------------------------------------*/


        /*----------------- Update To New Values -----------------*/
        this.position = finalPosition;
        this.linearVelocity = finalVelocity;
        this.transformUpdateRequired = true;
        /*--------------------------------------------------------*/

  }


  public void angularIntegration(float dt) {

    this.angularVelocity += this.netTorque * this.InvRotationalInertia * dt;
    this.angle += this.angularVelocity*dt;


  }



    public PVector calculateAcceleration(PVector position) {

        ArrayList<ForceRegistry> rodList = new ArrayList<ForceRegistry>();
        /*--------------- Force Reset --------------*/
        this.netForce.set(0,0,0);
        this.netTorque = 0f;
        /*------------------------------------------*/

        /*------------ Net Force Calculation ------------*/
        for (ForceRegistry force : this.forceRegistry) {

            if(force instanceof Rod){
              rodList.add(force);
              continue;
            }

            PVector currentForce = force.getForce(this, position);
            this.netForce.add(currentForce);

            PVector leverArm = PVector.sub(force.getApplicationPoint(this, this.position), this.position);
            this.netTorque += leverArm.cross(currentForce).z;

        }

        for(ForceRegistry rod : rodList) {
            PVector currentForce = rod.getForce(this, position);
            this.netForce.add(currentForce);

            PVector leverArm = PVector.sub(rod.getApplicationPoint(this, this.position), this.position);
            this.netTorque += leverArm.cross(currentForce).z;

        }
        /*-----------------------------------------------*/

        /*------------ Acceleration Calculation ------------*/
        return this.netForce.mult(this.InvMass);
        /*--------------------------------------------------*/

    }

  
  /*
  ==================================================================================================
  ==================================READ-ONLY FIELDS================================================
  ==================================================================================================
  */
  
  public float getMass() {
    return this.Mass;
  }
  
  public float getDensity() {
    return this.Density;
  }
  
  public float getRestitution() {
    return this.Restitution;
  }
  
  public float getArea() {
    return this.Area;
  }
  
  public float getRadius() {
    return this.Radius;
  }
  
  public float getWidth() {
    return this.Width;
  }
  
  public float getHeight() {
    return this.Height;
  }
  
  public ShapeType getShapeType() {
    return this.ShapeType;
  }

  public PVector[] getVertices() {
    return this.Vertices;
  }
  
  public float getInvMass() {
    return this.InvMass;
  }

  public float getRotationalInertia() {
    return this.RotationalInertia;
  }

  public float getInvRotationalInertia() {
    return this.InvRotationalInertia;
  }


  
  /*
  ==================================================================================================
  ==================================GETTERS & SETTERS===============================================
  ==================================================================================================
  */
  
  public boolean getTransformUpdateRequired() {
    return this.transformUpdateRequired;
  }
  
  public void setTransformUpdateRequired(boolean transformUpdateRequired) {
    this.transformUpdateRequired = transformUpdateRequired;
  }

  public boolean getAABBUpdateRequired() {
    return this.aabbUpdateRequired;
  }

  public void setAABBUpdateRequired(boolean aabbUpdateRequired) {
    this.aabbUpdateRequired = aabbUpdateRequired;
  }
  
  public PVector getPosition() {
    return this.position;
  }
  
  public void setPosition(PVector position) {
    this.transformUpdateRequired = true;
    this.aabbUpdateRequired = true;
    this.position = position;
  }
  public PVector getVelocity() {
    return this.linearVelocity;
  }
  
  public void setVelocity(PVector velocity) {
    this.linearVelocity = velocity;
  }
  
  public float getStrokeWeight() {
    return this.strokeWeight;
  }
  
  public void setStrokeWeight(float strokeWeight) {
    this.strokeWeight = strokeWeight;
  }
  
  public PVector getStrokeColour() {
    return this.strokeColour;
  }
  
  public void setStrokeColour(PVector strokeColour) {
    this.strokeColour = strokeColour;
  }
  //Overloaded method for setting stroke colour with 3 floats
  public void setStrokeColour(float r, float g, float b) {
    this.strokeColour = new PVector(r, g, b);
  }
  
  public PVector getFillColour() {
    return this.fillColour;
  }
  
  
  public void setFillColour(PVector fillColour) {
    this.fillColour = fillColour;
  }
  //Overloaded method for setting fill colour with 3 floats
  public void setFillColour(float r, float g, float b) {
    this.fillColour = new PVector(r, g, b);
  }
  
  public ArrayList<ForceRegistry> getForceRegistry() {
    return this.forceRegistry;
  }
  
  public ForceRegistry getForceFromForceRegistry(int index) {
    return this.forceRegistry.get(index);
  }
  
  public int getForceRegistrySize() {
    return this.forceRegistry.size();
  }
  
  public void addForceToForceRegistry(ForceRegistry forceRegistry) {
    this.forceRegistry.add(forceRegistry);
  }

  public void clearForceRegistry() {
    this.forceRegistry.clear();
  }

  public void removeForceFromForceRegistry(ForceRegistry forceRegistry) {
    this.forceRegistry.remove(forceRegistry);
  }
  
  public void removeForceFromForceRegistry(int index) {
    this.forceRegistry.remove(index);
  }
  
  public boolean getIsStatic() {
    return this.isStatic;
  }
  
  public void setIsStatic(boolean isStatic) {
    this.isStatic = isStatic;
  }

  public boolean getIsVisible() {
    return this.isVisible;
  }

  public void setIsVisible(boolean isVisible) {
    this.isVisible = isVisible;
  }
    public float getAngle() {
    return this.angle;
  }

  public void setAngle(float angle) {
    this.transformUpdateRequired = true;
    this.angle = angle;
  }

  public float getAngularVelocity(){
    return this.angularVelocity;
  }

  public void setAngularVelocity(float angularVelocity) {
    this.angularVelocity = angularVelocity;
  }


public float getCoefficientOfKineticFriction() {
    return this.coefficientOfKineticFriction;
}

public void setCoefficientOfKineticFriction(float coefficientOfKineticFriction) {
    this.coefficientOfKineticFriction = coefficientOfKineticFriction;
}

public float getCoefficientOfStaticFriction() {
    return this.coefficientOfStaticFriction;
}

public void setCoefficientOfStaticFriction(float coefficientOfStaticFriction) {
    this.coefficientOfStaticFriction = coefficientOfStaticFriction;
}

public boolean getIsTranslationallyStatic() {
    return this.isTranslationallyStatic;
}

public void setIsTranslationallyStatic(boolean isTranslationallyStatic) {
    this.isTranslationallyStatic = isTranslationallyStatic;
}

public boolean getIsRotationallyStatic() {
    return this.isRotationallyStatic;
}

public void setIsRotationallyStatic(boolean isRotationallyStatic) {
    this.isRotationallyStatic = isRotationallyStatic;
}

  
public boolean getCollidability() {
    return this.isCollidable;
}

public void setCollidability(boolean isCollidable) {
    this.isCollidable = isCollidable;
}
}
public class Rod implements ForceRegistry {
/*-------------------------------------------------------------------------------------------------*/
    private float length;
    private float stiffness = 1000000.0f;
    private float damping = 1f;

    private float angleStiffness = 1000000.0f;
    private float angleDamping = 0f;


    private PVector localAnchorA = new PVector();
    private PVector localAnchorB = new PVector();
    private PVector anchorPoint = new PVector();

    private float initialAngleA = 0f;
    private float initialAngleB = 0f;

    private boolean isHingeable;
    private boolean isTwoBodyRod;

    private Rigidbody rigidbodyA;
    private Rigidbody rigidbodyB;


/*-------------------------------------------------------------------------------------------------*/
    private PVector worldAnchorA = new PVector();
    private PVector worldAnchorB = new PVector();

    private PVector relativeVelocity = new PVector();

    private PVector velocityA = new PVector();
    private PVector velocityB = new PVector();

    private PVector dampingForce = new PVector();
    private PVector direction = new PVector();
    private PVector rodForce = new PVector();
    private PVector force = new PVector();
    public float netTorque = 0f;
    private PVector rigidbodyOrientation = new PVector();

/*-------------------------------------------------------------------------------------------------*/
//Reusable stuff


    public Rod(Rigidbody rigidbodyA, PVector localAnchorA, PVector anchorPoint) {

        this.rigidbodyA = rigidbodyA;

        this.anchorPoint.set(anchorPoint);
        this.localAnchorA.set(localAnchorA);

        this.initialAngleA = rigidbodyA.getAngle();

        this.isTwoBodyRod = false;

        this.length = PhysEngMath.Transform(localAnchorA, rigidbodyA.getPosition(), rigidbodyA.getAngle()).sub(anchorPoint).mag();


    }

    public Rod(Rigidbody rigidbodyA, Rigidbody rigidbodyB, PVector localAnchorA, PVector localAnchorB) {

        this.rigidbodyA = rigidbodyA;
        this.rigidbodyB = rigidbodyB;

        this.initialAngleA = rigidbodyA.getAngle();
        this.initialAngleB = rigidbodyB.getAngle();

        this.localAnchorA.set(localAnchorA);
        this.localAnchorB.set(localAnchorB);

        this.isTwoBodyRod = true;
        this.length = PhysEngMath.Transform(localAnchorB, rigidbodyB.getPosition(), rigidbodyB.getAngle()).sub(PhysEngMath.Transform(localAnchorA, rigidbodyA.getPosition(), rigidbodyA.getAngle())).mag();

    }


@Override
public PVector getForce(Rigidbody rigidbody, PVector position) {

    float displacement;
    float currentAngleA;
    float currentAngleB;
    float dot;
    float currentRigidbodyAngle;
    this.netTorque = 0f;
    this.force.set(0,0,0);

    if(isTwoBodyRod) {
        if(rigidbody == rigidbodyA) {
                this.worldAnchorA.set(PhysEngMath.Transform(this.localAnchorA, position, this.rigidbodyA.getAngle()));
                this.worldAnchorB.set(PhysEngMath.Transform(this.localAnchorB, this.rigidbodyB.getPosition(), this.rigidbodyB.getAngle()));

                this.velocityA.set(rigidbodyA.getVelocity());
                this.velocityB.set(rigidbodyB.getVelocity());

                this.direction.set(this.worldAnchorB.sub(this.worldAnchorA));

                displacement = direction.mag();
                this.direction.normalize();

                this.relativeVelocity.set(PVector.sub(this.velocityA, this.velocityB));

                dot = PVector.dot(relativeVelocity, this.direction);
                this.dampingForce.set(this.direction.copy().mult(damping * dot));


                /*
                if(!this.isHingeable) {
                    float rigidbodyAngle = rigidbodyA.getAngle();
                    this.rigidbodyOrientation.set(cos(rigidbodyAngle), sin(rigidbodyAngle));

                    float angleBetween = PVector.angleBetween(this.direction, this.rigidbodyOrientation);

                    if (direction.copy().cross(rigidbodyOrientation).z < 0) {
                        angleBetween = -angleBetween;
                    }

                    float angleDifference = angleBetween - this.initialAngleA;
                    //this.netTorque = -angleStiffness * angleDifference - angleDamping * rigidbody.getAngularVelocity();
                    //rigidbodyA.setAngle(rigidbodyA.getAngle()-angleDifference);
                    //force.add(0, 0, correctiveTorque);
                }
                */

                this.force.add(this.direction.mult(this.stiffness * (displacement - this.length)));
                this.force.add(this.dampingForce);
                
                return this.force;

            } else {
                this.worldAnchorA.set(PhysEngMath.Transform(this.localAnchorA, this.rigidbodyA.getPosition(), this.rigidbodyA.getAngle()));
                this.worldAnchorB.set(PhysEngMath.Transform(this.localAnchorB, position, this.rigidbodyB.getAngle()));

                this.velocityA.set(rigidbodyA.getVelocity());
                this.velocityB.set(rigidbodyB.getVelocity());


                this.direction.set(this.worldAnchorB.sub(this.worldAnchorA));
                displacement = direction.mag();
                this.direction.normalize();


                this.relativeVelocity.set(PVector.add(this.velocityA, this.velocityB));
                dot = PVector.dot(relativeVelocity, this.direction);

                this.dampingForce.set(this.direction.copy().mult(-damping * dot));

                /*
                if(!this.isHingeable) {
                    float rigidbodyAngle = rigidbodyB.getAngle();
                    this.rigidbodyOrientation.set(cos(rigidbodyAngle), sin(rigidbodyAngle));

                    float angleBetween = PVector.angleBetween(this.direction, this.rigidbodyOrientation);

                    if (this.direction.copy().cross(this.rigidbodyOrientation).z < 0) {
                        angleBetween = -angleBetween;
                    }

                    float angleDifference = angleBetween - this.initialAngleB;
                    //this.netTorque = -angleStiffness * angleDifference - angleDamping * rigidbody.getAngularVelocity();
                    //rigidbodyB.setAngle(rigidbodyB.getAngle()-angleDifference);
                    //force.add(0, 0, correctiveTorque);
                }
                */

                this.force.add(this.dampingForce);
                this.force.add(this.direction.mult(this.stiffness * (displacement - this.length)));
                
                return this.force.mult(-1);

            } 

    } else {

        this.worldAnchorA.set(PhysEngMath.Transform(this.localAnchorA, position, this.rigidbodyA.getAngle()));
        this.worldAnchorB.set(this.anchorPoint);

        this.velocityA.set(rigidbodyA.getVelocity());
        this.velocityB.set(0,0);    

        this.direction.set(this.worldAnchorB.sub(this.worldAnchorA));
        displacement = direction.mag();
        this.direction.normalize();

        this.relativeVelocity.set(this.velocityB.sub(this.velocityA));
        dot = PVector.dot(relativeVelocity, this.direction);

        this.dampingForce.set(this.direction.copy().mult(-damping * dot));

        /*
        if(!this.isHingeable) {
            float rigidbodyAngle = rigidbodyA.getAngle();
            this.rigidbodyOrientation.set(cos(rigidbodyAngle), sin(rigidbodyAngle));

            float angleBetween = PVector.angleBetween(this.direction, this.rigidbodyOrientation);

            if (this.direction.copy().cross(this.rigidbodyOrientation).z < 0) {
                angleBetween = -angleBetween;
            }

            float angleDifference = angleBetween - this.initialAngleA;
            //this.netTorque = -angleStiffness * angleDifference - angleDamping * rigidbody.getAngularVelocity();
            //r
            //rigidbodyB.setAngle(rigidbodyB.getAngle()-angleDifference);
            //force.add(0, 0, correctiveTorque);
        }
        */

        this.dampingForce.set(this.direction.copy().mult(-damping * PVector.dot(relativeVelocity, this.direction)));

        this.force.add(this.direction.mult(this.stiffness * (displacement - this.length)));
        this.force.add(this.dampingForce);
        
        return this.force;
                
    }
}



@Override
public void draw() {

    if(isTwoBodyRod){

        PVector worldAnchorA = PhysEngMath.Transform(localAnchorA, rigidbodyA.getPosition(), rigidbodyA.getAngle());
        PVector worldAnchorB = PhysEngMath.Transform(localAnchorB, rigidbodyB.getPosition(), rigidbodyB.getAngle());

        strokeWeight(0.15f);
        stroke(0);
        line(worldAnchorA.x, worldAnchorA.y, worldAnchorB.x, worldAnchorB.y);
        strokeWeight(0.1f);
        stroke(255);
        line(worldAnchorA.x, worldAnchorA.y, worldAnchorB.x, worldAnchorB.y);
    } else {

        PVector worldAnchorA = getApplicationPoint(rigidbodyA, rigidbodyA.getPosition());
        PVector worldAnchorB = anchorPoint;
        strokeWeight(0.15f);
        stroke(0);
        line(worldAnchorA.x, worldAnchorA.y, worldAnchorB.x, worldAnchorB.y);
        strokeWeight(0.1f);
        stroke(255);
        line(worldAnchorA.x, worldAnchorA.y, worldAnchorB.x, worldAnchorB.y);

    }
}


@Override
public PVector getApplicationPoint(Rigidbody rigidbody, PVector position) {
        if(rigidbody == rigidbodyA) {
            return PhysEngMath.Transform(localAnchorA, rigidbodyA.getPosition(), rigidbody.getAngle());
        } else {
            return PhysEngMath.Transform(localAnchorB, rigidbodyB.getPosition(), rigidbody.getAngle());
        }
}


/*
====================================================================================================
===================================GETTERS AND SETTERS==============================================
====================================================================================================
*/
public void setLength(float length) {
    this.length = length;
  }
public void setIsHingeable(boolean isHingeable) {
    this.isHingeable = isHingeable;
  }
public float getNetTorque() {
    return this.netTorque;
  }


public void setAnchorPoint(PVector anchorPoint) {
    this.anchorPoint = anchorPoint;
  }

public void setLocalAnchorA(PVector localAnchorA) {
    this.localAnchorA = localAnchorA;
  }

public void setLocalAnchorB(PVector localAnchorB) {
    this.localAnchorB = localAnchorB;
  }

public void setStiffness(float stiffness) {
    this.stiffness = stiffness;
  }

public void setDamping(float damping) {
    this.damping = damping;
  }

public void setTwoBodyRod(boolean isTwoBodyRod) {
    this.isTwoBodyRod = isTwoBodyRod;
  }


public float getLength() {
    return length;
  }

public boolean getIsHingeable() {
    return isHingeable;
  }

public PVector getAnchorPoint() {
    return anchorPoint;
  }

public PVector getLocalAnchorA() {
    return localAnchorA;
  }

public PVector getLocalAnchorB() {
    return localAnchorB;
  }

public float getStiffness() {
    return stiffness;
  }

public float getDamping() {
    return damping;
  }

public boolean getTwoBodyRod() {
    return isTwoBodyRod;
  }

public Rigidbody getRigidbodyA() {
    return rigidbodyA;
  }

public Rigidbody getRigidbodyB() {
    return rigidbodyB;
  }

}

  

public class Shape {
  
  public Shape() {
  }
  
  public void draw() {
    background(16, 18, 19);
    drawRigidbodies();
    //drawAABB(); //DONT REMOVE THIS, IT BREAKS SOMETHING
  /*---------------------------------Collision Point Debugging--------------------------------------*/
    //drawCollisionPoints();
  /*-----------------------------------------------------------------------------------------------*/
  drawForces();
  }

/*
====================================================================================================
==================================-=== Drawing Methods =============================================
====================================================================================================
*/
  public void drawRigidbodies() {
    for(int body = 0; body < rigidbodyList.size(); body++) {

      Rigidbody rigidbody = rigidbodyList.get(body);
        if(rigidbody.getIsVisible()) {
          
          if (rigidbody.getShapeType() == ShapeType.CIRCLE) {
            drawCircle(rigidbody.getPosition(), rigidbody.getRadius(),
                      rigidbody.getAngle(), rigidbody.getStrokeWeight(), rigidbody.getFillColour(),
                       rigidbody.getStrokeColour());
          }

          if (rigidbody.getShapeType() == ShapeType.BOX) {
            drawPolygon(rigidbody.getPosition(), rigidbody.GetTransformedVertices(),
                        rigidbody.getStrokeWeight(), rigidbody.getFillColour(),
                        rigidbody.getStrokeColour());
          }
        }
      }
  }
  public void drawCircle(PVector position, float radius, float angle, float strokeWeight, PVector fillColour,
    PVector strokeColour) {
    
    float diameter = radius * 2.0f;
    fill(fillColour.x, fillColour.y, fillColour.z);
    stroke(strokeColour.x, strokeColour.y, strokeColour.z);
    strokeWeight(strokeWeight);
    ellipseMode(CENTER);
    ellipse(position.x, position.y,  diameter,  diameter);

    PVector va = new PVector();
    PVector vb = new PVector(radius, 0);
    va = PhysEngMath.Transform(va, position, angle);
    vb = PhysEngMath.Transform(vb, position, angle);
    line(va.x, va.y, vb.x, vb.y);
    }
  
  public void drawBox(PVector position, float width, float height, float angle, float strokeWeight,
    PVector fillColour, PVector strokeColour) {
    
    fill(fillColour.x, fillColour.y, fillColour.z);
    stroke(strokeColour.x, strokeColour.y, strokeColour.z);
    strokeWeight(strokeWeight);
    rectMode(CENTER);
    pushMatrix();
    rect(position.x, position.y, width, height);
    popMatrix();
  }
  
  public void drawPolygon(PVector position, PVector[] transformedVertices, float strokeWeight,
    PVector fillColour, PVector strokeColour) {
    
    fill(fillColour.x, fillColour.y, fillColour.z);
    stroke(strokeColour.x, strokeColour.y, strokeColour.z);
    strokeWeight(strokeWeight);
    beginShape();
    for (PVector transformedVertex : transformedVertices) {
      vertex(transformedVertex.x, transformedVertex.y);
    }
    endShape(CLOSE);
  }

  public void drawAABB() {
    for(Rigidbody rigidbody : rigidbodyList) {
      if(rigidbody.getIsVisible()) {
        AABB aabb = rigidbody.GetAABB();

        /*
        rectMode(CORNERS);
        //stroke(255, 0, 0);
        noStroke();
        noFill();
        rect(aabb.getMin().x, aabb.getMin().y, aabb.getMax().x, aabb.getMax().y);
        */
      }
    }
  }

/*-----------------------------------------------------------------------------------------------*/
public void drawForces() {
    for(Rigidbody rigidbody : rigidbodyList) {
        for(ForceRegistry force : rigidbody.getForceRegistry()) {
            force.draw();
        }
    }
}
/*---------------------------------Collision Point Debugging--------------------------------------*/
  public void drawCollisionPoints() {
      for(PVector point : pointsOfContactList) {
        stroke(0, 0, 0);
        strokeWeight(0.1f);
        noFill();
        rectMode(CENTER);
        rect(point.x, point.y, 1, 1);
      }
        pointsOfContactList.clear();
    }

  
/*-----------------------------------------------------------------------------------------------*/

}

public enum ShapeType {
  CIRCLE,
  BOX,
  POLYGON,
  SOFTBODY
}
public class Softbody {

    private PVector initialPosition;

    private float radius;
    private float rectWidth;
    private float rectHeight;

    private float stiffness = 1000;
    private float damping = 1f;

    private int numRowParticles;
    private int numColumnParticles;

    private float particleRadius = 0.5f;

    private ArrayList<Rigidbody> softbodyEntityList = new ArrayList<Rigidbody>();
    private ArrayList<Rigidbody> edgeParticles = new ArrayList<Rigidbody>();
    private Rigidbody[][] softBodyParticles;

    

    public Softbody(PVector initialPosition, float radius, float RectWidth, float RectHeight) {
        this.initialPosition = initialPosition;
        this.radius = radius;

        this.rectWidth = (int)round(RectWidth);
        this.rectHeight = (int)round(RectHeight);

        //Create a way to calculate this later
        this.numRowParticles = (int)round(this.rectWidth/this.particleRadius);
        this.numColumnParticles = (int)round(this.rectHeight/this.particleRadius);
        softBodyParticles = new Rigidbody[numRowParticles][numColumnParticles];

        softbodyList.add(this);
    }


    public void CreateBoxSoftbody() {
        float spacingX = 2f;
        float spacingY = 2f;

        float initialParticlePositionX = this.initialPosition.x - this.rectWidth/2;
        float initialParticlePositionY = this.initialPosition.y - this.rectHeight/2;

        for(int row = 0; row < numRowParticles; row++) {
            for(int column = 0; column < numColumnParticles; column++) {

                PVector currentParticlePosition = new PVector(initialParticlePositionX + row*spacingX, initialParticlePositionY + column*spacingY);

                Rigidbody currentParticle = RigidbodyGenerator.CreateCircleBody(particleRadius, 0.5f, 0.1f, false, true, 0.1f, new PVector(0,0,0), new PVector(255,255,255));
                currentParticle.setPosition(currentParticlePosition);

                softBodyParticles[row][column] = currentParticle;
                //currentParticle.setCollidability(false);
                currentParticle.addForceToForceRegistry(new Gravity(currentParticle));
                currentParticle.setIsVisible(false);
                AddBodyToBodyEntityList(currentParticle);
            }
        }


for(int row = 0; row < numRowParticles; row++) {
    for(int column = 0; column < numColumnParticles; column++) {

        Rigidbody currentParticle = softBodyParticles[row][column];

        // Link to particle below if it exists
        if(row < numRowParticles - 1) {
            Rigidbody particleToLinkTo = softBodyParticles[row+1][column];
            addSpringBetweenParticles(currentParticle, particleToLinkTo);
        }

        // Link to particle to the right if it exists
        if(column < numColumnParticles - 1) {
            Rigidbody particleToLinkTo = softBodyParticles[row][column+1];
            addSpringBetweenParticles(currentParticle, particleToLinkTo);
        }

        // Link to bottom-right diagonal if it exists
        if(row < numRowParticles - 1 && column < numColumnParticles - 1) {
            Rigidbody particleToLinkTo = softBodyParticles[row+1][column+1];
            addSpringBetweenParticles(currentParticle, particleToLinkTo);
        }

        // Link to top-right diagonal if it exists
        if(row > 0 && column < numColumnParticles - 1) {
            Rigidbody particleToLinkTo = softBodyParticles[row-1][column+1];
            addSpringBetweenParticles(currentParticle, particleToLinkTo);
        }
        
    }
}

    }

private void addSpringBetweenParticles(Rigidbody particleA, Rigidbody particleB) {
    Spring spring = new Spring(particleA, particleB, new PVector(), new PVector());
    
    spring.setSpringConstant(this.stiffness);
    spring.setDamping(this.damping);
    spring.drawSpring = false;

    particleA.addForceToForceRegistry(spring);
    particleB.addForceToForceRegistry(spring);
}

    public void updateSoftbody() {
      draw();
    }

    public void draw() {
        
        beginShape();
        for (int column = 0; column < numColumnParticles; column++) {
          PVector pos = softBodyParticles[0][column].getPosition();
          vertex(pos.x, pos.y);
        }
        // Right edge
        for (int row = 0; row < numRowParticles; row++) {
          PVector pos = softBodyParticles[row][numColumnParticles - 1].getPosition();
          vertex(pos.x, pos.y);
        }
        // Bottom edge
        for (int column = numColumnParticles - 1; column >= 0; column--) {
          PVector pos = softBodyParticles[numRowParticles - 1][column].getPosition();
          vertex(pos.x, pos.y);
        }
        // Left edge
        for (int row = numRowParticles - 1; row >= 0; row--) {
          PVector pos = softBodyParticles[row][0].getPosition();
          vertex(pos.x, pos.y);
        }
        endShape(CLOSE);

    }


/*

public void draw() {

    beginShape();
    PVector center = calculateCenter();
    // Top edge
    for (int column = 0; column < numColumnParticles; column++) {
        PVector pos = softBodyParticles[0][column].getPosition();
        PVector offset = pos.copy().sub(center).normalize().mult(particleRadius);
        vertex(pos.x + offset.x, pos.y + offset.y);
    }
    // Right edge
    for (int row = 0; row < numRowParticles; row++) {
        PVector pos = softBodyParticles[row][numColumnParticles - 1].getPosition();
        PVector offset = pos.copy().sub(center).normalize().mult(particleRadius);
        vertex(pos.x + offset.x, pos.y + offset.y);
    }
    // Bottom edge
    for (int column = numColumnParticles - 1; column >= 0; column--) {
        PVector pos = softBodyParticles[numRowParticles - 1][column].getPosition();
        PVector offset = pos.copy().sub(center).normalize().mult(particleRadius);
        vertex(pos.x + offset.x, pos.y + offset.y);
    }
    // Left edge
    for (int row = numRowParticles - 1; row >= 0; row--) {
        PVector pos = softBodyParticles[row][0].getPosition();
        PVector offset = pos.copy().sub(center).normalize().mult(radius);
        vertex(pos.x + offset.x, pos.y + offset.y);
    }

    endShape(CLOSE);
}

private PVector calculateCenter() {
    float totalX = 0;
    float totalY = 0;
    int count = 0;

    for (int row = 0; row < numRowParticles; row++) {
        for (int col = 0; col < numColumnParticles; col++) {
            PVector pos = softBodyParticles[row][col].getPosition();
            totalX += pos.x;
            totalY += pos.y;
            count++;
        }
    }

    if (count == 0) {
        return new PVector(0, 0); // or some default value in case there are no particles
    }

    float centerX = totalX / count;
    float centerY = totalY / count;

    return new PVector(centerX, centerY);
}
*/
}

public class Spring implements ForceRegistry {

    private Rigidbody rigidbodyA;
    private Rigidbody rigidbodyB;

    private PVector anchorPoint = new PVector();
    private PVector localAnchorA = new PVector();
    private PVector localAnchorB = new PVector();
    
    private boolean drawSpring = true;

    //Some default values
    private boolean lockTranslationToXAxis = false;
    private boolean lockTranslationToYAxis = false;
    
    private boolean isPerfectSpring = false;
    private boolean isHingeable = true;

    private float equilibriumLength = 1f; //Equilibrium length is a percentage of the total magnitude of the length
    private float springConstant = 50;
    private float damping = 0.5f;
    
    private float springLength;

    private boolean isTwoBodySpring;
    //TODO: IMPLEMENT THIS
    private float initialRotationA;
    private float initialRotationB;


    /*--------------- Reusable --------------- */
    private PVector worldAnchorA = new PVector();
    private PVector worldAnchorB = new PVector();

    private PVector velocityA = new PVector();
    private PVector velocityB = new PVector();

    private PVector direction = new PVector();



    public Spring(Rigidbody rigidbody, PVector localAnchorA, PVector anchorPoint) {

        this.rigidbodyA = rigidbody;
        this.localAnchorA.set(localAnchorA);
        this.anchorPoint.set(anchorPoint);

        this.springLength = PhysEngMath.Transform(localAnchorA, rigidbodyA.getPosition(), rigidbodyA.getAngle()).sub(anchorPoint).mag();

        this.isTwoBodySpring = false;
        this.isHingeable = true;

    }

    public Spring(Rigidbody rigidbodyA, Rigidbody rigidbodyB, PVector localAnchorA, PVector localAnchorB) {
        
        this.rigidbodyA = rigidbodyA;
        this.rigidbodyB = rigidbodyB;
        
        this.localAnchorA.set(localAnchorA);
        this.localAnchorB.set(localAnchorB);
        
        this.springLength = PhysEngMath.Transform(localAnchorB, rigidbodyB.getPosition(), rigidbodyB.getAngle()).sub(PhysEngMath.Transform(localAnchorA, rigidbodyA.getPosition(), rigidbodyA.getAngle())).mag();

        this.isTwoBodySpring = true;
        this.isHingeable = true;

    }

    @Override
    public PVector getForce(Rigidbody rigidbody, PVector position) {
        float totalForceMagnitude = 0f;
        float displacement = 0f;

        if(isTwoBodySpring) {
            velocityA.set(rigidbodyA.getVelocity());
            velocityB.set(rigidbodyB.getVelocity());
    
            if(rigidbody == rigidbodyA) {
                worldAnchorA.set(PhysEngMath.Transform(this.localAnchorA, position, rigidbodyA.getAngle()));
                worldAnchorB.set(PhysEngMath.Transform(this.localAnchorB, rigidbodyB.getPosition(), rigidbodyB.getAngle()));

                if(lockTranslationToYAxis) rigidbodyA.setVelocity(velocityA.set(0, velocityA.y));
                else if(lockTranslationToXAxis) rigidbodyA.setVelocity(velocityA.set(velocityA.x, 0));

                this.direction.set(worldAnchorB.sub(worldAnchorA));
                displacement = direction.mag();

                if(!isPerfectSpring){                                                                                    
                    totalForceMagnitude = (displacement - this.springLength * this.equilibriumLength) * this.springConstant;
                    direction.normalize();
                    totalForceMagnitude += (direction.dot(velocityB.sub(velocityA)) * this.damping);
                } else {
                    totalForceMagnitude = (displacement - this.springLength * this.equilibriumLength) * this.springConstant;
                }
                return this.direction.mult(totalForceMagnitude);
    
            } else {
                worldAnchorA.set(PhysEngMath.Transform(this.localAnchorA, rigidbodyA.getPosition(), rigidbodyA.getAngle()));
                worldAnchorB.set(PhysEngMath.Transform(this.localAnchorB, position, rigidbodyB.getAngle()));
            
                this.direction.set(worldAnchorB.sub(worldAnchorA));
                displacement = direction.mag();
                direction.normalize();

                if(lockTranslationToYAxis) rigidbodyB.setVelocity(velocityB.set(0, velocityB.y));
                else if(lockTranslationToXAxis) rigidbodyB.setVelocity(velocityB.set(velocityB.x, 0));

                if(!isPerfectSpring){                                                                                    
                    totalForceMagnitude = (displacement - this.springLength * this.equilibriumLength) * this.springConstant;
                    totalForceMagnitude += (direction.dot(velocityB.sub(velocityA)) * this.damping);
                } else {
                    totalForceMagnitude = (displacement - this.springLength * this.equilibriumLength) * this.springConstant;
                }

                return this.direction.mult(-totalForceMagnitude);
            }
        } else {
            worldAnchorA.set(PhysEngMath.Transform(this.localAnchorA, position, rigidbodyA.getAngle()));
            worldAnchorB.set(anchorPoint);
    
            velocityA.set(rigidbodyA.getVelocity());
            velocityB.set(0,0);

            this.direction.set(worldAnchorB.sub(worldAnchorA));
            displacement = direction.mag();
            direction.normalize();

            if(lockTranslationToYAxis) rigidbodyA.setVelocity(velocityA.set(0, velocityA.y));
            else if(lockTranslationToXAxis) rigidbodyA.setVelocity(velocityA.set(velocityA.x, 0));
            
            if(!isPerfectSpring){                                                                                    
                totalForceMagnitude = (displacement - this.springLength * this.equilibriumLength) * this.springConstant;
                direction.normalize();
                totalForceMagnitude += (direction.dot(velocityB.sub(velocityA)) * this.damping);
            } else {
                totalForceMagnitude = (displacement- this.springLength * this.equilibriumLength) * this.springConstant;
            }

            return this.direction.mult(totalForceMagnitude);
        }
    
} 

  

//TODO: IMPLEMENT A WAY TO MAKE THE SPRING SCALE WITH ITS LENGTH, SO THAT VISUALLY A LARGE SPRING
//WILL HAVE THICKER LINES, AND MORE OFFSET, ETC
    @Override
    public void draw() {
        if(this.drawSpring) {
            PVector worldAnchorA;
            PVector worldAnchorB;
            PVector direction;
            float length;

            if(isTwoBodySpring) {
                worldAnchorA = PhysEngMath.Transform(localAnchorA, rigidbodyA.getPosition(), rigidbodyA.getAngle());
                worldAnchorB = PhysEngMath.Transform(localAnchorB, rigidbodyB.getPosition(), rigidbodyB.getAngle());
            } else {
                worldAnchorA = PhysEngMath.Transform(localAnchorA, rigidbodyA.getPosition(), rigidbodyA.getAngle());
                worldAnchorB = this.anchorPoint;
            }

            direction = PVector.sub(worldAnchorA, worldAnchorB);
            length = direction.mag();
            direction.normalize();

            fill(255);

            float segments = 5;
            float segmentLength = length / segments;

            // Set the offset to a constant value
            float offsetMagnitude = 0.5f; // Adjust this value to change the size of the zigzags

            // Draw the rod
            strokeWeight(0.3f);
            stroke(0); // Black
            line(worldAnchorA.x, worldAnchorA.y, worldAnchorB.x, worldAnchorB.y);
            stroke(255); // White
            strokeWeight(0.1f);
            line(worldAnchorA.x, worldAnchorA.y, worldAnchorB.x, worldAnchorB.y);
            
            PVector segmentStart = new PVector();
            PVector segmentEnd = new PVector();
            PVector midPoint = new PVector();
            PVector midPoint1 = new PVector();
            PVector midPoint2 = new PVector();
            PVector directionSegmentLength = PVector.mult(direction, segmentLength);
            PVector offset1 = new PVector();
            PVector offset2 = new PVector();

            for(int i = 0; i < segments; i++) {

                segmentStart.set(PVector.add(worldAnchorB, PVector.mult(directionSegmentLength, i)));
                segmentEnd.set(PVector.add(worldAnchorB, PVector.mult(directionSegmentLength, i + 1)));

                // Calculate the midpoint of the segment
                midPoint.set(PVector.lerp(segmentStart, segmentEnd, 0.5f));

                if(i % 2 == 0) {
                    offset1.set(new PVector(-direction.y, direction.x).mult(offsetMagnitude));
                    offset2.set(new PVector(direction.y, -direction.x).mult(offsetMagnitude));
                } else {
                    offset1.set(new PVector(direction.y, -direction.x).mult(offsetMagnitude));
                    offset2.set(new PVector(-direction.y, direction.x).mult(offsetMagnitude));
                }

                // Add the offsets to the midpoint
                midPoint1.set(PVector.add(midPoint, offset1));
                midPoint2.set(PVector.add(midPoint, offset2));

                // Draw the lines
                strokeWeight(0.2f);
                stroke(0);
                line(segmentStart.x, segmentStart.y, midPoint1.x, midPoint1.y);
                line(midPoint1.x, midPoint1.y, segmentEnd.x, segmentEnd.y);
                line(segmentStart.x, segmentStart.y, midPoint2.x, midPoint2.y);
                line(midPoint2.x, midPoint2.y, segmentEnd.x, segmentEnd.y);
                strokeWeight(0.1f);
                stroke(255);
                line(segmentStart.x, segmentStart.y, midPoint1.x, midPoint1.y);
                line(midPoint1.x, midPoint1.y, segmentEnd.x, segmentEnd.y);
                line(segmentStart.x, segmentStart.y, midPoint2.x, midPoint2.y);
                line(midPoint2.x, midPoint2.y, segmentEnd.x, segmentEnd.y);
            }
        } else {
            return;
        }
    }

    @Override
    public PVector getApplicationPoint(Rigidbody rigidbody, PVector position) {
            if(rigidbody == rigidbodyA) {
                return PhysEngMath.Transform(localAnchorA, position, rigidbodyA.getAngle());
            } else {
                return PhysEngMath.Transform(localAnchorB, position, rigidbodyB.getAngle());
            }
    }

/*
====================================================================================================
================================== Getters & Setters ===============================================
====================================================================================================
*/

    public void setIsHingeable(boolean isHingeable) {
        this.isHingeable = isHingeable;
    }

    public void setSpringConstant(float springConstant) {
        this.springConstant = springConstant;
    }

    public void setSpringLength(float springLength) {
        this.springLength = springLength;
    }

    public void setEquilibriumLength(float equilibriumLength) {
        this.equilibriumLength = equilibriumLength;
    }

    public void setDamping(float damping) {
        this.damping = damping;
    }

    public void setLockTranslationToXAxis(boolean lockTranslationToXAxis) {
        this.lockTranslationToXAxis = lockTranslationToXAxis;
    }

    public void setLockTranslationToYAxis(boolean lockTranslationToYAxis) {
        this.lockTranslationToYAxis = lockTranslationToYAxis;
    }

    public void setPerfectSpring(boolean isPerfectSpring) {
        this.isPerfectSpring = isPerfectSpring;
    }

    public void setAnchorPoint(PVector anchorPoint) {
        this.anchorPoint = anchorPoint;
    }

    public void setLocalAnchorA(PVector localAnchorA) {
        this.localAnchorA = localAnchorA;
    }

    public void setLocalAnchorB(PVector localAnchorB) {
        this.localAnchorB = localAnchorB;
    }

    public void setInitialRotationA(float initialRotationA) {
        this.initialRotationA = initialRotationA;
    }

    public void setInitialRotationB(float initialRotationB) {
        this.initialRotationB = initialRotationB;
    }

    public boolean getIsHingeable() {
        return this.isHingeable;
    }

    public float getSpringConstant() {
        return this.springConstant;
    }

    public float getSpringLength() {
        return this.springLength;
    }

    public float getEquilibriumLength() {
        return this.equilibriumLength;
    }

    public float getDamping() {
        return this.damping;
    }

    public boolean getLockTranslationToXAxis() {
        return this.lockTranslationToXAxis;
    }

    public boolean getLockTranslationToYAxis() {
        return this.lockTranslationToYAxis;
    }

    public boolean getPerfectSpring() {
        return this.isPerfectSpring;
    }

    public PVector getAnchorPoint() {
        return this.anchorPoint;
    }

    public PVector getLocalAnchorA() {
        return this.localAnchorA;
    }

    public PVector getLocalAnchorB() {
        return this.localAnchorB;
    }

    public float getInitialRotationA() {
        return this.initialRotationA;
    }

    public float getInitialRotationB() {
        return this.initialRotationB;
    }

    public Rigidbody getRigidbodyA() {
        return this.rigidbodyA;
    }

    public Rigidbody getRigidbodyB() {
        return this.rigidbodyB;
    }

    public boolean getIsTwoBodySpring() {
        return this.isTwoBodySpring;
    }
}


  public void settings() { size(1500, 1000); }

  static public void main(String[] passedArgs) {
    String[] appletArgs = new String[] { "PhysicsEngine" };
    if (passedArgs != null) {
      PApplet.main(concat(appletArgs, passedArgs));
    } else {
      PApplet.main(appletArgs);
    }
  }
}
